//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package model provides an interface for working with high-level objects (models) in PDF files, including
// reading and writing documents.
//
// The document structure of a PDF is constructed of a hierarchy of data models, representing a tree
// of information starting from the Document catalog (Figure 5 p. 80).
// It is based on the core package which handles core functionality such as file i/o, parsing and
// handling of primitive PDF objects (core.PdfObject).
//
// As an example of the interface, the following snippet can read the PDF and output the number of pages:
//
//	f, err := os.Open(inputPath)
//		if err != nil {
//		return nil, err
//	}
//	defer f.Close()
// 	pdfReader, err := unipdf.NewPdfReader(f)
//	if err != nil {
//		fmt.Printf("Failed to read PDF file: %v\n", err)
//		os.Exit(1)
//	}
//	numPages, err := pdfReader.GetNumPages()
//	if err != nil {
//		fmt.Printf("Failed to get number of pages: %v\n", err)
//		os.Exit(1)
//	}
//	fmt.Printf("The PDF file has %d pages\n", numPages)
//
// For more examples, see the unidoc-examples repository on GitHub: https://github.com/unidoc/unidoc-examples
package model

import (
	_b "bufio"
	_eb "bytes"
	_fc "crypto/rand"
	_c "crypto/sha1"
	_fe "crypto/x509"
	_f "encoding/binary"
	_gf "encoding/hex"
	_bb "errors"
	_d "fmt"
	_de "github.com/unidoc/pkcs7"
	_fef "github.com/unidoc/unipdf/v3/common"
	_fed "github.com/unidoc/unipdf/v3/core"
	_ae "github.com/unidoc/unipdf/v3/core/security"
	_fec "github.com/unidoc/unipdf/v3/core/security/crypt"
	_edf "github.com/unidoc/unipdf/v3/internal/cmap"
	_eede "github.com/unidoc/unipdf/v3/internal/imageutil"
	_fdg "github.com/unidoc/unipdf/v3/internal/license"
	_bba "github.com/unidoc/unipdf/v3/internal/sampling"
	_dg "github.com/unidoc/unipdf/v3/internal/textencoding"
	_ce "github.com/unidoc/unipdf/v3/internal/transform"
	_geg "github.com/unidoc/unipdf/v3/model/internal/fonts"
	_db "github.com/unidoc/unipdf/v3/model/sigutil"
	_ed "github.com/unidoc/unipdf/v3/ps"
	_cg "github.com/unidoc/unitype"
	_dc "golang.org/x/xerrors"
	_ee "image"
	_cd "image/color"
	_ "image/gif"
	_ "image/png"
	_ge "io"
	_aa "io/ioutil"
	_bg "math"
	_cdf "math/rand"
	_da "os"
	_cdd "regexp"
	_ef "sort"
	_ba "strconv"
	_eed "strings"
	_g "sync"
	_e "time"
	_ad "unicode"
	_eg "unicode/utf8"
)

// AddAnnotation appends `annot` to the list of page annotations.
func (_abded *PdfPage) AddAnnotation(annot *PdfAnnotation) {
	if _abded._abcb == nil {
		_abded.GetAnnotations()
	}
	_abded._abcb = append(_abded._abcb, annot)
}

// L returns the value of the L component of the color.
func (_cded *PdfColorLab) L() float64 { return _cded[0] }

// GetAscent returns the Ascent of the font `descriptor`.
func (_feca *PdfFontDescriptor) GetAscent() (float64, error) {
	return _fed.GetNumberAsFloat(_feca.Ascent)
}
func (_dfcgf *PdfColorspaceSpecialPattern) String() string {
	return "\u0050a\u0074\u0074\u0065\u0072\u006e"
}

// ToPdfObject implements interface PdfModel.
func (_bfff *PdfAnnotationMovie) ToPdfObject() _fed.PdfObject {
	_bfff.PdfAnnotation.ToPdfObject()
	_gcg := _bfff._ffaab
	_aaccdb := _gcg.PdfObject.(*_fed.PdfObjectDictionary)
	_aaccdb.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u004d\u006f\u0076i\u0065"))
	_aaccdb.SetIfNotNil("\u0054", _bfff.T)
	_aaccdb.SetIfNotNil("\u004d\u006f\u0076i\u0065", _bfff.Movie)
	_aaccdb.SetIfNotNil("\u0041", _bfff.A)
	return _gcg
}

// ImageHandler interface implements common image loading and processing tasks.
// Implementing as an interface allows for the possibility to use non-standard libraries for faster
// loading and processing of images.
type ImageHandler interface {

	// Read any image type and load into a new Image object.
	Read(_cddcf _ge.Reader) (*Image, error)

	// NewImageFromGoImage loads a NRGBA32 unidoc Image from a standard Go image structure.
	NewImageFromGoImage(_abefd _ee.Image) (*Image, error)

	// NewGrayImageFromGoImage loads a grayscale unidoc Image from a standard Go image structure.
	NewGrayImageFromGoImage(_edcgb _ee.Image) (*Image, error)

	// Compress an image.
	Compress(_dfge *Image, _fbcb int64) (*Image, error)
}

const (
	_gcaff = 0x00001
	_bdfaf = 0x00002
	_dcad  = 0x00004
	_dgbeg = 0x00008
	_bgaea = 0x00020
	_fefa  = 0x00040
	_geadc = 0x10000
	_debd  = 0x20000
	_dgbb  = 0x40000
)

// NewPdfField returns an initialized PdfField.
func NewPdfField() *PdfField { return &PdfField{_cbaae: _fed.MakeIndirectObject(_fed.MakeDict())} }

// ToPdfObject returns the PDF representation of the colorspace.
func (_bfbgae *PdfPageResourcesColorspaces) ToPdfObject() _fed.PdfObject {
	_bffdg := _fed.MakeDict()
	for _, _bffbb := range _bfbgae.Names {
		_bffdg.Set(_fed.PdfObjectName(_bffbb), _bfbgae.Colorspaces[_bffbb].ToPdfObject())
	}
	if _bfbgae._bdbfa != nil {
		_bfbgae._bdbfa.PdfObject = _bffdg
		return _bfbgae._bdbfa
	}
	return _bffdg
}

// ToPdfObject returns the text field dictionary within an indirect object (container).
func (_cdgd *PdfFieldText) ToPdfObject() _fed.PdfObject {
	_cdgd.PdfField.ToPdfObject()
	_ccbca := _cdgd._cbaae
	_aeaf := _ccbca.PdfObject.(*_fed.PdfObjectDictionary)
	_aeaf.Set("\u0046\u0054", _fed.MakeName("\u0054\u0078"))
	if _cdgd.DA != nil {
		_aeaf.Set("\u0044\u0041", _cdgd.DA)
	}
	if _cdgd.Q != nil {
		_aeaf.Set("\u0051", _cdgd.Q)
	}
	if _cdgd.DS != nil {
		_aeaf.Set("\u0044\u0053", _cdgd.DS)
	}
	if _cdgd.RV != nil {
		_aeaf.Set("\u0052\u0056", _cdgd.RV)
	}
	if _cdgd.MaxLen != nil {
		_aeaf.Set("\u004d\u0061\u0078\u004c\u0065\u006e", _cdgd.MaxLen)
	}
	return _ccbca
}

var (
	_dgdd  = _cdd.MustCompile("\u005cd\u002b\u0020\u0064\u0069c\u0074\u005c\u0073\u002b\u0028d\u0075p\u005cs\u002b\u0029\u003f\u0062\u0065\u0067\u0069n")
	_ddcc  = _cdd.MustCompile("\u005e\u005cs\u002a\u002f\u0028\u005c\u0053\u002b\u003f\u0029\u005c\u0073\u002b\u0028\u002e\u002b\u003f\u0029\u005c\u0073\u002b\u0064\u0065\u0066\\s\u002a\u0024")
	_feee  = _cdd.MustCompile("\u005e\u005c\u0073*\u0064\u0075\u0070\u005c\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002a\u002f\u0028\u005c\u0077\u002b\u003f\u0029\u0028\u003f\u003a\u005c\u002e\u005c\u0064\u002b)\u003f\u005c\u0073\u002b\u0070\u0075\u0074\u0024")
	_dgece = "\u002f\u0045\u006e\u0063od\u0069\u006e\u0067\u0020\u0032\u0035\u0036\u0020\u0061\u0072\u0072\u0061\u0079"
	_ccde  = "\u0072\u0065\u0061d\u006f\u006e\u006c\u0079\u0020\u0064\u0065\u0066"
	_aadgc = "\u0063\u0075\u0072\u0072\u0065\u006e\u0074\u0066\u0069\u006c\u0065\u0020e\u0065\u0078\u0065\u0063"
)

// ToInteger convert to an integer format.
func (_feacf *PdfColorDeviceCMYK) ToInteger(bits int) [4]uint32 {
	_gdea := _bg.Pow(2, float64(bits)) - 1
	return [4]uint32{uint32(_gdea * _feacf.C()), uint32(_gdea * _feacf.M()), uint32(_gdea * _feacf.Y()), uint32(_gdea * _feacf.K())}
}

// SetContext sets the sub pattern (context).  Either PdfTilingPattern or PdfShadingPattern.
func (_efaef *PdfPattern) SetContext(ctx PdfModel) { _efaef._ggadg = ctx }

// FieldValueProvider provides field values from a data source such as FDF, JSON or any other.
type FieldValueProvider interface {
	FieldValues() (map[string]_fed.PdfObject, error)
}

// GetCharMetrics returns the char metrics for character code `code`.
func (_dcdc pdfFontType3) GetCharMetrics(code _dg.CharCode) (_geg.CharMetrics, bool) {
	if _eafac, _ceca := _dcdc._cadbe[code]; _ceca {
		return _geg.CharMetrics{Wx: _eafac}, true
	}
	if _geg.IsStdFont(_geg.StdFontName(_dcdc._daac)) {
		return _geg.CharMetrics{Wx: 250}, true
	}
	return _geg.CharMetrics{}, false
}

// SetContext sets the specific fielddata type, e.g. would be PdfFieldButton for a button field.
func (_fcea *PdfField) SetContext(ctx PdfModel) { _fcea._ggbfc = ctx }

// ToInteger convert to an integer format.
func (_eff *PdfColorCalGray) ToInteger(bits int) uint32 {
	_feff := _bg.Pow(2, float64(bits)) - 1
	return uint32(_feff * _eff.Val())
}

var _edfca = map[string]struct{}{"\u0054\u0069\u0074l\u0065": {}, "\u0041\u0075\u0074\u0068\u006f\u0072": {}, "\u0053u\u0062\u006a\u0065\u0063\u0074": {}, "\u004b\u0065\u0079\u0077\u006f\u0072\u0064\u0073": {}, "\u0043r\u0065\u0061\u0074\u006f\u0072": {}, "\u0050\u0072\u006f\u0064\u0075\u0063\u0065\u0072": {}, "\u0054r\u0061\u0070\u0070\u0065\u0064": {}, "\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065": {}, "\u004do\u0064\u0044\u0061\u0074\u0065": {}}

// PdfColorspaceSpecialSeparation is a Separation colorspace.
// At the moment the colour space is set to a Separation space, the conforming reader shall determine whether the
// device has an available colorant (e.g. dye) corresponding to the name of the requested space. If so, the conforming
// reader shall ignore the alternateSpace and tintTransform parameters; subsequent painting operations within the
// space shall apply the designated colorant directly, according to the tint values supplied.
//
// Format: [/Separation name alternateSpace tintTransform]
type PdfColorspaceSpecialSeparation struct {
	ColorantName   *_fed.PdfObjectName
	AlternateSpace PdfColorspace
	TintTransform  PdfFunction
	_fdffd         *_fed.PdfIndirectObject
}

// PdfActionMovie represents a movie action.
type PdfActionMovie struct {
	*PdfAction
	Annotation _fed.PdfObject
	T          _fed.PdfObject
	Operation  _fed.PdfObject
}

var _bggfdc = _cdd.MustCompile("\u005c\u0073\u002a\u0044\u005c\u0073\u002a:\u005c\u0073\u002a\u0028\u005c\u0064\u007b\u0034\u007d\u0029\u0028\u005c\u0064\u007b2\u007d)\u0028\u005c\u0064\u007b\u0032\u007d)\u0028\u005c\u0064\u007b\u0032\u007d\u0029(\u005c\u0064\u007b\u0032\u007d\u0029\u0028\u005c\u0064\u007b\u0032\u007d\u0029\u0028\u005b\u002b\u002d\u005a\u005d\u0029\u003f\u0028\u005cd\u007b\u0032\u007d\u0029\u003f\u0027\u003f\u0028\u005c\u0064\u007b\u0032\u007d)\u003f")

// PdfInfo holds document information that will overwrite
// document information global variables defined above.
type PdfInfo struct {
	Title        *_fed.PdfObjectString
	Author       *_fed.PdfObjectString
	Subject      *_fed.PdfObjectString
	Keywords     *_fed.PdfObjectString
	Creator      *_fed.PdfObjectString
	Producer     *_fed.PdfObjectString
	CreationDate *PdfDate
	ModifiedDate *PdfDate
	Trapped      *_fed.PdfObjectName
	_debc        *_fed.PdfObjectDictionary
}

// NewOutlineBookmark returns an initialized PdfOutlineItem for a given bookmark title and page.
func NewOutlineBookmark(title string, page *_fed.PdfIndirectObject) *PdfOutlineItem {
	_dddbc := PdfOutlineItem{}
	_dddbc._ffgd = &_dddbc
	_dddbc.Title = _fed.MakeString(title)
	_fccg := _fed.MakeArray()
	_fccg.Append(page)
	_fccg.Append(_fed.MakeName("\u0046\u0069\u0074"))
	_dddbc.Dest = _fccg
	return &_dddbc
}
func (_eccc *PdfReader) newPdfAnnotationFreeTextFromDict(_aade *_fed.PdfObjectDictionary) (*PdfAnnotationFreeText, error) {
	_eee := PdfAnnotationFreeText{}
	_eecg, _eca := _eccc.newPdfAnnotationMarkupFromDict(_aade)
	if _eca != nil {
		return nil, _eca
	}
	_eee.PdfAnnotationMarkup = _eecg
	_eee.DA = _aade.Get("\u0044\u0041")
	_eee.Q = _aade.Get("\u0051")
	_eee.RC = _aade.Get("\u0052\u0043")
	_eee.DS = _aade.Get("\u0044\u0053")
	_eee.CL = _aade.Get("\u0043\u004c")
	_eee.IT = _aade.Get("\u0049\u0054")
	_eee.BE = _aade.Get("\u0042\u0045")
	_eee.RD = _aade.Get("\u0052\u0044")
	_eee.BS = _aade.Get("\u0042\u0053")
	_eee.LE = _aade.Get("\u004c\u0045")
	return &_eee, nil
}

// PdfShading represents a shading dictionary. There are 7 types of shading,
// indicatedby the shading type variable:
// 1: Function-based shading.
// 2: Axial shading.
// 3: Radial shading.
// 4: Free-form Gouraud-shaded triangle mesh.
// 5: Lattice-form Gouraud-shaded triangle mesh.
// 6: Coons patch mesh.
// 7: Tensor-product patch mesh.
// types 4-7 are contained in a stream object, where the dictionary is given by the stream dictionary.
type PdfShading struct {
	ShadingType *_fed.PdfObjectInteger
	ColorSpace  PdfColorspace
	Background  *_fed.PdfObjectArray
	BBox        *PdfRectangle
	AntiAlias   *_fed.PdfObjectBool
	_cebded     PdfModel
	_cdcge      _fed.PdfObject
}

// PdfAnnotationMovie represents Movie annotations.
// (Section 12.5.6.17).
type PdfAnnotationMovie struct {
	*PdfAnnotation
	T     _fed.PdfObject
	Movie _fed.PdfObject
	A     _fed.PdfObject
}

// Encoder returns the font's text encoder.
func (_aedge *PdfFont) Encoder() _dg.TextEncoder {
	_baeaf := _aedge.actualFont()
	if _baeaf == nil {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0045n\u0063\u006f\u0064er\u0020\u006e\u006f\u0074\u0020\u0069m\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0066\u006f\u0072\u0020\u0066o\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u003d%\u0023\u0054", _aedge._gdaa)
		return nil
	}
	return _baeaf.Encoder()
}

// NewPdfPageResources returns a new PdfPageResources object.
func NewPdfPageResources() *PdfPageResources {
	_cfefdg := &PdfPageResources{}
	_cfefdg._fcdee = _fed.MakeDict()
	return _cfefdg
}

// ImageToRGB convert an indexed image to RGB.
func (_efac *PdfColorspaceSpecialIndexed) ImageToRGB(img Image) (Image, error) {
	N := _efac.Base.GetNumComponents()
	if N < 1 {
		return Image{}, _d.Errorf("\u0062\u0061d \u0062\u0061\u0073e\u0020\u0063\u006f\u006cors\u0070ac\u0065\u0020\u004e\u0075\u006d\u0043\u006fmp\u006f\u006e\u0065\u006e\u0074\u0073\u003d%\u0064", N)
	}
	_ecaea := _eede.NewImageBase(int(img.Width), int(img.Height), 8, N, nil, img._caeaf, img._ccdge)
	_adag := _bba.NewReader(img.getBase())
	_ebge := _bba.NewWriter(_ecaea)
	var (
		_cfbgf uint32
		_cbaef int
		_adga  error
	)
	for {
		_cfbgf, _adga = _adag.ReadSample()
		if _adga == _ge.EOF {
			break
		} else if _adga != nil {
			return img, _adga
		}
		_cbaef = int(_cfbgf)
		_fef.Log.Trace("\u0049\u006ed\u0065\u0078\u0065\u0064\u003a\u0020\u0069\u006e\u0064\u0065\u0078\u003d\u0025\u0064\u0020\u004e\u003d\u0025\u0064\u0020\u006c\u0075t=\u0025\u0064", _cbaef, N, len(_efac._defd))
		if (_cbaef+1)*N > len(_efac._defd) {
			_cbaef = len(_efac._defd)/N - 1
			_fef.Log.Trace("C\u006c\u0069\u0070\u0070in\u0067 \u0074\u006f\u0020\u0069\u006ed\u0065\u0078\u003a\u0020\u0025\u0064", _cbaef)
			if _cbaef < 0 {
				_fef.Log.Debug("\u0045R\u0052\u004fR\u003a\u0020\u0043a\u006e\u0027\u0074\u0020\u0063\u006c\u0069p\u0020\u0069\u006e\u0064\u0065\u0078.\u0020\u0049\u0073\u0020\u0050\u0044\u0046\u0020\u0066\u0069\u006ce\u0020\u0064\u0061\u006d\u0061\u0067\u0065\u0064\u003f")
				break
			}
		}
		for _ddfc := _cbaef * N; _ddfc < (_cbaef+1)*N; _ddfc++ {
			if _adga = _ebge.WriteSample(uint32(_efac._defd[_ddfc])); _adga != nil {
				return img, _adga
			}
		}
	}
	return _efac.Base.ImageToRGB(_ddbab(&_ecaea))
}

// ToPdfObject implements interface PdfModel.
func (_aba *PdfActionSubmitForm) ToPdfObject() _fed.PdfObject {
	_aba.PdfAction.ToPdfObject()
	_agc := _aba._fa
	_gde := _agc.PdfObject.(*_fed.PdfObjectDictionary)
	_gde.SetIfNotNil("\u0053", _fed.MakeName(string(ActionTypeSubmitForm)))
	if _aba.F != nil {
		_gde.Set("\u0046", _aba.F.ToPdfObject())
	}
	_gde.SetIfNotNil("\u0046\u0069\u0065\u006c\u0064\u0073", _aba.Fields)
	_gde.SetIfNotNil("\u0046\u006c\u0061g\u0073", _aba.Flags)
	return _agc
}

// PdfActionType represents an action type in PDF (section 12.6.4 p. 417).
type PdfActionType string

// GetNumPages returns the number of pages in the document.
func (_eeaac *PdfReader) GetNumPages() (int, error) {
	if _eeaac._cdfggf.GetCrypter() != nil && !_eeaac._cdfggf.IsAuthenticated() {
		return 0, _d.Errorf("\u0066\u0069\u006ce\u0020\u006e\u0065\u0065d\u0020\u0074\u006f\u0020\u0062\u0065\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	}
	return len(_eeaac._gdac), nil
}

// SetDSS sets the DSS dictionary (ETSI TS 102 778-4 V1.1.1) of the current
// document revision.
func (_addc *PdfAppender) SetDSS(dss *DSS) {
	if dss != nil {
		_addc.updateObjectsDeep(dss.ToPdfObject(), nil)
	}
	_addc._bcbe = dss
}

// ToPdfObject returns a stream object.
func (_ecagga *XObjectImage) ToPdfObject() _fed.PdfObject {
	_gbcac := _ecagga._agffg
	_acgae := _gbcac.PdfObjectDictionary
	if _ecagga.Filter != nil {
		_acgae = _ecagga.Filter.MakeStreamDict()
		_gbcac.PdfObjectDictionary = _acgae
	}
	_acgae.Set("\u0054\u0079\u0070\u0065", _fed.MakeName("\u0058O\u0062\u006a\u0065\u0063\u0074"))
	_acgae.Set("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u0049\u006d\u0061g\u0065"))
	_acgae.Set("\u0057\u0069\u0064t\u0068", _fed.MakeInteger(*(_ecagga.Width)))
	_acgae.Set("\u0048\u0065\u0069\u0067\u0068\u0074", _fed.MakeInteger(*(_ecagga.Height)))
	if _ecagga.BitsPerComponent != nil {
		_acgae.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _fed.MakeInteger(*(_ecagga.BitsPerComponent)))
	}
	if _ecagga.ColorSpace != nil {
		_acgae.SetIfNotNil("\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065", _ecagga.ColorSpace.ToPdfObject())
	}
	_acgae.SetIfNotNil("\u0049\u006e\u0074\u0065\u006e\u0074", _ecagga.Intent)
	_acgae.SetIfNotNil("\u0049m\u0061\u0067\u0065\u004d\u0061\u0073k", _ecagga.ImageMask)
	_acgae.SetIfNotNil("\u004d\u0061\u0073\u006b", _ecagga.Mask)
	_facbe := _acgae.Get("\u0044\u0065\u0063\u006f\u0064\u0065") != nil
	if _ecagga.Decode == nil && _facbe {
		_acgae.Remove("\u0044\u0065\u0063\u006f\u0064\u0065")
	} else if _ecagga.Decode != nil {
		_acgae.Set("\u0044\u0065\u0063\u006f\u0064\u0065", _ecagga.Decode)
	}
	_acgae.SetIfNotNil("I\u006e\u0074\u0065\u0072\u0070\u006f\u006c\u0061\u0074\u0065", _ecagga.Interpolate)
	_acgae.SetIfNotNil("\u0041\u006c\u0074e\u0072\u006e\u0061\u0074\u0069\u0076\u0065\u0073", _ecagga.Alternatives)
	_acgae.SetIfNotNil("\u0053\u004d\u0061s\u006b", _ecagga.SMask)
	_acgae.SetIfNotNil("S\u004d\u0061\u0073\u006b\u0049\u006e\u0044\u0061\u0074\u0061", _ecagga.SMaskInData)
	_acgae.SetIfNotNil("\u004d\u0061\u0074t\u0065", _ecagga.Matte)
	_acgae.SetIfNotNil("\u004e\u0061\u006d\u0065", _ecagga.Name)
	_acgae.SetIfNotNil("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074", _ecagga.StructParent)
	_acgae.SetIfNotNil("\u0049\u0044", _ecagga.ID)
	_acgae.SetIfNotNil("\u004f\u0050\u0049", _ecagga.OPI)
	_acgae.SetIfNotNil("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061", _ecagga.Metadata)
	_acgae.SetIfNotNil("\u004f\u0043", _ecagga.OC)
	_acgae.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _fed.MakeInteger(int64(len(_ecagga.Stream))))
	_gbcac.Stream = _ecagga.Stream
	return _gbcac
}

// AddOutlineTree adds outlines to a PDF file.
func (_agaae *PdfWriter) AddOutlineTree(outlineTree *PdfOutlineTreeNode) { _agaae._aecef = outlineTree }

// NewPdfFilespec returns an initialized generic PDF filespec model.
func NewPdfFilespec() *PdfFilespec {
	_geabd := &PdfFilespec{}
	_geabd._dfeff = _fed.MakeIndirectObject(_fed.MakeDict())
	return _geabd
}

// PdfAnnotationPrinterMark represents PrinterMark annotations.
// (Section 12.5.6.20).
type PdfAnnotationPrinterMark struct {
	*PdfAnnotation
	MN _fed.PdfObject
}

// PdfAnnotationUnderline represents Underline annotations.
// (Section 12.5.6.10).
type PdfAnnotationUnderline struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	QuadPoints _fed.PdfObject
}

// NewReaderOpts generates a default `ReaderOpts` instance.
func NewReaderOpts() *ReaderOpts { return &ReaderOpts{Password: "", LazyLoad: true} }

// SetOCProperties sets the optional content properties.
func (_cbdbg *PdfWriter) SetOCProperties(ocProperties _fed.PdfObject) error {
	_gcfed := _cbdbg._cdefg
	if ocProperties != nil {
		_fef.Log.Trace("\u0053e\u0074\u0074\u0069\u006e\u0067\u0020\u004f\u0043\u0020\u0050\u0072o\u0070\u0065\u0072\u0074\u0069\u0065\u0073\u002e\u002e\u002e")
		_gcfed.Set("\u004f\u0043\u0050r\u006f\u0070\u0065\u0072\u0074\u0069\u0065\u0073", ocProperties)
		return _cbdbg.addObjects(ocProperties)
	}
	return nil
}

// R returns the value of the red component of the color.
func (_fcag *PdfColorDeviceRGB) R() float64 { return _fcag[0] }
func (_gaec *PdfReader) newPdfActionNamedFromDict(_gagc *_fed.PdfObjectDictionary) (*PdfActionNamed, error) {
	return &PdfActionNamed{N: _gagc.Get("\u004e")}, nil
}

// ImageToRGB returns an error since an image cannot be defined in a pattern colorspace.
func (_afee *PdfColorspaceSpecialPattern) ImageToRGB(img Image) (Image, error) {
	_fef.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0049\u006d\u0061\u0067\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066i\u0065\u0064\u0020\u0069\u006e\u0020\u0050\u0061\u0074\u0074\u0065\u0072n \u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065")
	return img, _bb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u0066\u006f\u0072\u0020\u0069m\u0061\u0067\u0065\u0020\u0028p\u0061\u0074t\u0065\u0072\u006e\u0029")
}

// NewPdfAnnotationPolygon returns a new polygon annotation.
func NewPdfAnnotationPolygon() *PdfAnnotationPolygon {
	_eceb := NewPdfAnnotation()
	_baf := &PdfAnnotationPolygon{}
	_baf.PdfAnnotation = _eceb
	_baf.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_eceb.SetContext(_baf)
	return _baf
}
func _aaef(_ffce _fed.PdfObject) (*PdfBorderStyle, error) {
	_dbbff := &PdfBorderStyle{}
	_dbbff._dfa = _ffce
	var _adab *_fed.PdfObjectDictionary
	_ffce = _fed.TraceToDirectObject(_ffce)
	_adab, _gbfb := _ffce.(*_fed.PdfObjectDictionary)
	if !_gbfb {
		return nil, _bb.New("\u0074\u0079\u0070\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	if _gffg := _adab.Get("\u0054\u0079\u0070\u0065"); _gffg != nil {
		_bcfe, _dbcb := _gffg.(*_fed.PdfObjectName)
		if !_dbcb {
			_fef.Log.Debug("I\u006e\u0063\u006f\u006d\u0070\u0061\u0074\u0069\u0062i\u006c\u0069\u0074\u0079\u0020\u0077\u0069th\u0020\u0054\u0079\u0070e\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0061me\u0020\u006fb\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0054", _gffg)
		} else {
			if *_bcfe != "\u0042\u006f\u0072\u0064\u0065\u0072" {
				_fef.Log.Debug("W\u0061\u0072\u006e\u0069\u006e\u0067,\u0020\u0054\u0079\u0070\u0065\u0020\u0021\u003d\u0020B\u006f\u0072\u0064e\u0072:\u0020\u0025\u0073", *_bcfe)
			}
		}
	}
	if _gece := _adab.Get("\u0057"); _gece != nil {
		_aaeb, _ccgd := _fed.GetNumberAsFloat(_gece)
		if _ccgd != nil {
			_fef.Log.Debug("\u0045\u0072\u0072\u006fr \u0072\u0065\u0074\u0072\u0069\u0065\u0076\u0069\u006e\u0067\u0020\u0057\u003a\u0020%\u0076", _ccgd)
			return nil, _ccgd
		}
		_dbbff.W = &_aaeb
	}
	if _fba := _adab.Get("\u0053"); _fba != nil {
		_ggac, _cggd := _fba.(*_fed.PdfObjectName)
		if !_cggd {
			return nil, _bb.New("\u0062\u006f\u0072\u0064\u0065\u0072\u0020\u0053\u0020\u006e\u006ft\u0020\u0061\u0020\u006e\u0061\u006d\u0065\u0020\u006f\u0062j\u0065\u0063\u0074")
		}
		var _fcfa BorderStyle
		switch *_ggac {
		case "\u0053":
			_fcfa = BorderStyleSolid
		case "\u0044":
			_fcfa = BorderStyleDashed
		case "\u0042":
			_fcfa = BorderStyleBeveled
		case "\u0049":
			_fcfa = BorderStyleInset
		case "\u0055":
			_fcfa = BorderStyleUnderline
		default:
			_fef.Log.Debug("I\u006e\u0076\u0061\u006cid\u0020s\u0074\u0079\u006c\u0065\u0020n\u0061\u006d\u0065\u0020\u0025\u0073", *_ggac)
			return nil, _bb.New("\u0073\u0074\u0079\u006ce \u0074\u0079\u0070\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065c\u006b")
		}
		_dbbff.S = &_fcfa
	}
	if _ebfea := _adab.Get("\u0044"); _ebfea != nil {
		_bade, _bbbc := _ebfea.(*_fed.PdfObjectArray)
		if !_bbbc {
			_fef.Log.Debug("\u0042\u006f\u0072\u0064\u0065\u0072\u0020\u0044\u0020\u0064a\u0073\u0068\u0020\u006e\u006f\u0074\u0020a\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0054", _ebfea)
			return nil, _bb.New("\u0062o\u0072\u0064\u0065\u0072 \u0044\u0020\u0074\u0079\u0070e\u0020c\u0068e\u0063\u006b\u0020\u0065\u0072\u0072\u006fr")
		}
		_cgce, _gccf := _bade.ToIntegerArray()
		if _gccf != nil {
			_fef.Log.Debug("\u0042\u006f\u0072\u0064\u0065\u0072\u0020\u0044 \u0050\u0072\u006fbl\u0065\u006d\u0020\u0063\u006f\u006ev\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0069\u006e\u0074\u0065\u0067e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u003a \u0025\u0076", _gccf)
			return nil, _gccf
		}
		_dbbff.D = &_cgce
	}
	return _dbbff, nil
}

// ImageToRGB converts CalRGB colorspace image to RGB and returns the result.
func (_bbbae *PdfColorspaceCalRGB) ImageToRGB(img Image) (Image, error) {
	_eadg := _bba.NewReader(img.getBase())
	_acbc := _eede.NewImageBase(int(img.Width), int(img.Height), int(img.BitsPerComponent), 3, nil, nil, nil)
	_eabc := _bba.NewWriter(_acbc)
	_ebbb := _bg.Pow(2, float64(img.BitsPerComponent)) - 1
	_dfce := make([]uint32, 3)
	var (
		_dcac                                     error
		_becc, _dfbg, _ggdd, _acdff, _dcgb, _eadc float64
	)
	for {
		_dcac = _eadg.ReadSamples(_dfce)
		if _dcac == _ge.EOF {
			break
		} else if _dcac != nil {
			return img, _dcac
		}
		_becc = float64(_dfce[0]) / _ebbb
		_dfbg = float64(_dfce[1]) / _ebbb
		_ggdd = float64(_dfce[2]) / _ebbb
		_acdff = _bbbae.Matrix[0]*_bg.Pow(_becc, _bbbae.Gamma[0]) + _bbbae.Matrix[3]*_bg.Pow(_dfbg, _bbbae.Gamma[1]) + _bbbae.Matrix[6]*_bg.Pow(_ggdd, _bbbae.Gamma[2])
		_dcgb = _bbbae.Matrix[1]*_bg.Pow(_becc, _bbbae.Gamma[0]) + _bbbae.Matrix[4]*_bg.Pow(_dfbg, _bbbae.Gamma[1]) + _bbbae.Matrix[7]*_bg.Pow(_ggdd, _bbbae.Gamma[2])
		_eadc = _bbbae.Matrix[2]*_bg.Pow(_becc, _bbbae.Gamma[0]) + _bbbae.Matrix[5]*_bg.Pow(_dfbg, _bbbae.Gamma[1]) + _bbbae.Matrix[8]*_bg.Pow(_ggdd, _bbbae.Gamma[2])
		_becc = 3.240479*_acdff + -1.537150*_dcgb + -0.498535*_eadc
		_dfbg = -0.969256*_acdff + 1.875992*_dcgb + 0.041556*_eadc
		_ggdd = 0.055648*_acdff + -0.204043*_dcgb + 1.057311*_eadc
		_becc = _bg.Min(_bg.Max(_becc, 0), 1.0)
		_dfbg = _bg.Min(_bg.Max(_dfbg, 0), 1.0)
		_ggdd = _bg.Min(_bg.Max(_ggdd, 0), 1.0)
		_dfce[0] = uint32(_becc * _ebbb)
		_dfce[1] = uint32(_dfbg * _ebbb)
		_dfce[2] = uint32(_ggdd * _ebbb)
		if _dcac = _eabc.WriteSamples(_dfce); _dcac != nil {
			return img, _dcac
		}
	}
	return _ddbab(&_acbc), nil
}

// SetBorderWidth sets the style's border width.
func (_gga *PdfBorderStyle) SetBorderWidth(width float64) { _gga.W = &width }

// ToPdfObject implements interface PdfModel.
func (_feda *PdfActionGoToR) ToPdfObject() _fed.PdfObject {
	_feda.PdfAction.ToPdfObject()
	_bff := _feda._fa
	_dge := _bff.PdfObject.(*_fed.PdfObjectDictionary)
	_dge.SetIfNotNil("\u0053", _fed.MakeName(string(ActionTypeGoToR)))
	if _feda.F != nil {
		_dge.Set("\u0046", _feda.F.ToPdfObject())
	}
	_dge.SetIfNotNil("\u0044", _feda.D)
	_dge.SetIfNotNil("\u004ee\u0077\u0057\u0069\u006e\u0064\u006fw", _feda.NewWindow)
	return _bff
}
func (_eeee *PdfColorspaceSpecialSeparation) String() string {
	return "\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006f\u006e"
}
func _cbgcd(_aaea *fontCommon) *pdfCIDFontType0 { return &pdfCIDFontType0{fontCommon: *_aaea} }

// OutlineDest represents the destination of an outline item.
// It holds the page and the position on the page an outline item points to.
type OutlineDest struct {
	PageObj *_fed.PdfIndirectObject `json:"-"`
	Page    int64                   `json:"page"`
	Mode    string                  `json:"mode"`
	X       float64                 `json:"x"`
	Y       float64                 `json:"y"`
	Zoom    float64                 `json:"zoom"`
}

func _aaee(_ggfe _fed.PdfObject) (*PdfFontDescriptor, error) {
	_ggaf := &PdfFontDescriptor{}
	_ggfe = _fed.ResolveReference(_ggfe)
	if _gcebe, _eagc := _ggfe.(*_fed.PdfIndirectObject); _eagc {
		_ggaf._eafa = _gcebe
		_ggfe = _gcebe.PdfObject
	}
	_bgfda, _fdfea := _fed.GetDict(_ggfe)
	if !_fdfea {
		_fef.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0046o\u006e\u0074\u0044\u0065\u0073c\u0072\u0069\u0070\u0074\u006f\u0072\u0020\u006e\u006f\u0074\u0020\u0067\u0069\u0076\u0065\u006e\u0020\u0062\u0079\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0054\u0029", _ggfe)
		return nil, _fed.ErrTypeError
	}
	if _adgcd := _bgfda.Get("\u0046\u006f\u006e\u0074\u004e\u0061\u006d\u0065"); _adgcd != nil {
		_ggaf.FontName = _adgcd
	} else {
		_fef.Log.Debug("\u0049n\u0063\u006fm\u0070\u0061\u0074\u0069b\u0069\u006c\u0069t\u0079\u003a\u0020\u0046\u006f\u006e\u0074\u004e\u0061me\u0020\u0028\u0052e\u0071\u0075i\u0072\u0065\u0064\u0029\u0020\u006di\u0073\u0073i\u006e\u0067")
	}
	_gfgb, _ := _fed.GetName(_ggaf.FontName)
	if _geca := _bgfda.Get("\u0054\u0079\u0070\u0065"); _geca != nil {
		_fggea, _agcc := _geca.(*_fed.PdfObjectName)
		if !_agcc || string(*_fggea) != "\u0046\u006f\u006e\u0074\u0044\u0065\u0073\u0063\u0072i\u0070\u0074\u006f\u0072" {
			_fef.Log.Debug("I\u006e\u0063\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069\u0074\u0079\u003a\u0020\u0046\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063\u0072i\u0070t\u006f\u0072\u0020\u0054y\u0070\u0065 \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0025\u0054\u0029\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0071\u0020\u0025\u0054", _geca, _gfgb, _ggaf.FontName)
		}
	} else {
		_fef.Log.Trace("\u0049\u006ec\u006f\u006d\u0070\u0061\u0074i\u0062\u0069\u006c\u0069\u0074y\u003a\u0020\u0054\u0079\u0070\u0065\u0020\u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u002e\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0071\u0020\u0025\u0054", _gfgb, _ggaf.FontName)
	}
	_ggaf.FontFamily = _bgfda.Get("\u0046\u006f\u006e\u0074\u0046\u0061\u006d\u0069\u006c\u0079")
	_ggaf.FontStretch = _bgfda.Get("F\u006f\u006e\u0074\u0053\u0074\u0072\u0065\u0074\u0063\u0068")
	_ggaf.FontWeight = _bgfda.Get("\u0046\u006f\u006e\u0074\u0057\u0065\u0069\u0067\u0068\u0074")
	_ggaf.Flags = _bgfda.Get("\u0046\u006c\u0061g\u0073")
	_ggaf.FontBBox = _bgfda.Get("\u0046\u006f\u006e\u0074\u0042\u0042\u006f\u0078")
	_ggaf.ItalicAngle = _bgfda.Get("I\u0074\u0061\u006c\u0069\u0063\u0041\u006e\u0067\u006c\u0065")
	_ggaf.Ascent = _bgfda.Get("\u0041\u0073\u0063\u0065\u006e\u0074")
	_ggaf.Descent = _bgfda.Get("\u0044e\u0073\u0063\u0065\u006e\u0074")
	_ggaf.Leading = _bgfda.Get("\u004ce\u0061\u0064\u0069\u006e\u0067")
	_ggaf.CapHeight = _bgfda.Get("\u0043a\u0070\u0048\u0065\u0069\u0067\u0068t")
	_ggaf.XHeight = _bgfda.Get("\u0058H\u0065\u0069\u0067\u0068\u0074")
	_ggaf.StemV = _bgfda.Get("\u0053\u0074\u0065m\u0056")
	_ggaf.StemH = _bgfda.Get("\u0053\u0074\u0065m\u0048")
	_ggaf.AvgWidth = _bgfda.Get("\u0041\u0076\u0067\u0057\u0069\u0064\u0074\u0068")
	_ggaf.MaxWidth = _bgfda.Get("\u004d\u0061\u0078\u0057\u0069\u0064\u0074\u0068")
	_ggaf.MissingWidth = _bgfda.Get("\u004d\u0069\u0073s\u0069\u006e\u0067\u0057\u0069\u0064\u0074\u0068")
	_ggaf.FontFile = _bgfda.Get("\u0046\u006f\u006e\u0074\u0046\u0069\u006c\u0065")
	_ggaf.FontFile2 = _bgfda.Get("\u0046o\u006e\u0074\u0046\u0069\u006c\u00652")
	_ggaf.FontFile3 = _bgfda.Get("\u0046o\u006e\u0074\u0046\u0069\u006c\u00653")
	_ggaf.CharSet = _bgfda.Get("\u0043h\u0061\u0072\u0053\u0065\u0074")
	_ggaf.Style = _bgfda.Get("\u0053\u0074\u0079l\u0065")
	_ggaf.Lang = _bgfda.Get("\u004c\u0061\u006e\u0067")
	_ggaf.FD = _bgfda.Get("\u0046\u0044")
	_ggaf.CIDSet = _bgfda.Get("\u0043\u0049\u0044\u0053\u0065\u0074")
	if _ggaf.Flags != nil {
		if _eeff, _aadce := _fed.GetIntVal(_ggaf.Flags); _aadce {
			_ggaf._ffda = _eeff
		}
	}
	if _ggaf.MissingWidth != nil {
		if _afabb, _eecdg := _fed.GetNumberAsFloat(_ggaf.MissingWidth); _eecdg == nil {
			_ggaf._ffegc = _afabb
		}
	}
	if _ggaf.FontFile != nil {
		_gafe, _efgf := _cegdb(_ggaf.FontFile)
		if _efgf != nil {
			return _ggaf, _efgf
		}
		_fef.Log.Trace("f\u006f\u006e\u0074\u0046\u0069\u006c\u0065\u003d\u0025\u0073", _gafe)
		_ggaf.fontFile = _gafe
	}
	if _ggaf.FontFile2 != nil {
		_abaed, _eaef := _geg.NewFontFile2FromPdfObject(_ggaf.FontFile2)
		if _eaef != nil {
			return _ggaf, _eaef
		}
		_fef.Log.Trace("\u0066\u006f\u006et\u0046\u0069\u006c\u0065\u0032\u003d\u0025\u0073", _abaed.String())
		_ggaf._afef = &_abaed
	}
	return _ggaf, nil
}

// PdfActionLaunch represents a launch action.
type PdfActionLaunch struct {
	*PdfAction
	F         *PdfFilespec
	Win       _fed.PdfObject
	Mac       _fed.PdfObject
	Unix      _fed.PdfObject
	NewWindow _fed.PdfObject
}

// Add appends a top level outline item to the outline.
func (_bccbg *Outline) Add(item *OutlineItem) { _bccbg.Entries = append(_bccbg.Entries, item) }

// GetRuneMetrics returns the character metrics for the rune.
// A bool flag is returned to indicate whether or not the entry was found.
func (_effd pdfFontSimple) GetRuneMetrics(r rune) (_geg.CharMetrics, bool) {
	if _effd._abef != nil {
		_cdfg, _ccbf := _effd._abef.Read(r)
		if _ccbf {
			return _cdfg, true
		}
	}
	_adecc := _effd.Encoder()
	if _adecc == nil {
		_fef.Log.Debug("\u004e\u006f\u0020en\u0063\u006f\u0064\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0066\u006f\u006e\u0074\u0073\u003d\u0025\u0073", _effd)
		return _geg.CharMetrics{}, false
	}
	_cedb, _ddcec := _adecc.RuneToCharcode(r)
	if !_ddcec {
		if r != ' ' {
			_fef.Log.Trace("\u004e\u006f\u0020c\u0068\u0061\u0072\u0063o\u0064\u0065\u0020\u0066\u006f\u0072\u0020r\u0075\u006e\u0065\u003d\u0025\u0076\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", r, _effd)
		}
		return _geg.CharMetrics{}, false
	}
	_eaac, _fgef := _effd.GetCharMetrics(_cedb)
	return _eaac, _fgef
}

// ToPdfObject implements interface PdfModel.
func (_ddga *PdfAnnotationCaret) ToPdfObject() _fed.PdfObject {
	_ddga.PdfAnnotation.ToPdfObject()
	_aebg := _ddga._ffaab
	_cgea := _aebg.PdfObject.(*_fed.PdfObjectDictionary)
	_ddga.PdfAnnotationMarkup.appendToPdfDictionary(_cgea)
	_cgea.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u0043\u0061\u0072e\u0074"))
	_cgea.SetIfNotNil("\u0052\u0044", _ddga.RD)
	_cgea.SetIfNotNil("\u0053\u0079", _ddga.Sy)
	return _aebg
}

// PdfAnnotationProjection represents Projection annotations.
type PdfAnnotationProjection struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
}

// ToPdfObject implements interface PdfModel.
func (_cefd *PdfAnnotationLine) ToPdfObject() _fed.PdfObject {
	_cefd.PdfAnnotation.ToPdfObject()
	_ecag := _cefd._ffaab
	_fbf := _ecag.PdfObject.(*_fed.PdfObjectDictionary)
	_cefd.PdfAnnotationMarkup.appendToPdfDictionary(_fbf)
	_fbf.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u004c\u0069\u006e\u0065"))
	_fbf.SetIfNotNil("\u004c", _cefd.L)
	_fbf.SetIfNotNil("\u0042\u0053", _cefd.BS)
	_fbf.SetIfNotNil("\u004c\u0045", _cefd.LE)
	_fbf.SetIfNotNil("\u0049\u0043", _cefd.IC)
	_fbf.SetIfNotNil("\u004c\u004c", _cefd.LL)
	_fbf.SetIfNotNil("\u004c\u004c\u0045", _cefd.LLE)
	_fbf.SetIfNotNil("\u0043\u0061\u0070", _cefd.Cap)
	_fbf.SetIfNotNil("\u0049\u0054", _cefd.IT)
	_fbf.SetIfNotNil("\u004c\u004c\u004f", _cefd.LLO)
	_fbf.SetIfNotNil("\u0043\u0050", _cefd.CP)
	_fbf.SetIfNotNil("\u004de\u0061\u0073\u0075\u0072\u0065", _cefd.Measure)
	_fbf.SetIfNotNil("\u0043\u004f", _cefd.CO)
	return _ecag
}

// GetParamsDict returns *core.PdfObjectDictionary with a set of basic image parameters.
func (_aebge *Image) GetParamsDict() *_fed.PdfObjectDictionary {
	_cgbdb := _fed.MakeDict()
	_cgbdb.Set("\u0057\u0069\u0064t\u0068", _fed.MakeInteger(_aebge.Width))
	_cgbdb.Set("\u0048\u0065\u0069\u0067\u0068\u0074", _fed.MakeInteger(_aebge.Height))
	_cgbdb.Set("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073", _fed.MakeInteger(int64(_aebge.ColorComponents)))
	_cgbdb.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _fed.MakeInteger(_aebge.BitsPerComponent))
	return _cgbdb
}

// ReplaceAcroForm replaces the acrobat form. It appends a new form to the Pdf which
// replaces the original AcroForm.
func (_ffcfb *PdfAppender) ReplaceAcroForm(acroForm *PdfAcroForm) {
	if acroForm != nil {
		_ffcfb.updateObjectsDeep(acroForm.ToPdfObject(), nil)
	}
	_ffcfb._eae = acroForm
}

// NewPdfFontFromTTF loads a TTF font and returns a PdfFont type that can be
// used in text styling functions.
// Uses a WinAnsiTextEncoder and loads only character codes 32-255.
// NOTE: For composite fonts such as used in symbolic languages, use NewCompositePdfFontFromTTF.
func NewPdfFontFromTTF(r _ge.ReadSeeker) (*PdfFont, error) {
	const _edadc = _dg.CharCode(32)
	const _bbgeb = _dg.CharCode(255)
	_ecea, _aafgd := _aa.ReadAll(r)
	if _aafgd != nil {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0066\u006f\u006e\u0074\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074s\u003a\u0020\u0025\u0076", _aafgd)
		return nil, _aafgd
	}
	_aegdc, _aafgd := _geg.TtfParse(_eb.NewReader(_ecea))
	if _aafgd != nil {
		_fef.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020l\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0054\u0054F\u0020\u0066\u006fn\u0074:\u0020\u0025\u0076", _aafgd)
		return nil, _aafgd
	}
	_dbebg := &pdfFontSimple{_dadc: make(map[_dg.CharCode]float64), fontCommon: fontCommon{_afge: "\u0054\u0072\u0075\u0065\u0054\u0079\u0070\u0065"}}
	_dbebg._ebcbf = _dg.NewWinAnsiEncoder()
	_dbebg._daac = _aegdc.PostScriptName
	_dbebg.FirstChar = _fed.MakeInteger(int64(_edadc))
	_dbebg.LastChar = _fed.MakeInteger(int64(_bbgeb))
	_cfecc := 1000.0 / float64(_aegdc.UnitsPerEm)
	if len(_aegdc.Widths) <= 0 {
		return nil, _bb.New("\u0045\u0052\u0052O\u0052\u003a\u0020\u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065 \u0028\u0057\u0069\u0064\u0074\u0068\u0073\u0029")
	}
	_faaec := _cfecc * float64(_aegdc.Widths[0])
	_fefcg := make([]float64, 0, _bbgeb-_edadc+1)
	for _egbbe := _edadc; _egbbe <= _bbgeb; _egbbe++ {
		_deacc, _geedf := _dbebg.Encoder().CharcodeToRune(_egbbe)
		if !_geedf {
			_fef.Log.Debug("\u0052u\u006e\u0065\u0020\u006eo\u0074\u0020\u0066\u006f\u0075n\u0064 \u0028c\u006f\u0064\u0065\u003a\u0020\u0025\u0064)", _egbbe)
			_fefcg = append(_fefcg, _faaec)
			continue
		}
		_eafggc, _cdca := _aegdc.Chars[_deacc]
		if !_cdca {
			_fef.Log.Debug("R\u0075\u006e\u0065\u0020no\u0074 \u0069\u006e\u0020\u0054\u0054F\u0020\u0043\u0068\u0061\u0072\u0073")
			_fefcg = append(_fefcg, _faaec)
			continue
		}
		_geda := _cfecc * float64(_aegdc.Widths[_eafggc])
		_fefcg = append(_fefcg, _geda)
	}
	_dbebg.Widths = _fed.MakeIndirectObject(_fed.MakeArrayFromFloats(_fefcg))
	if len(_fefcg) < int(_bbgeb-_edadc+1) {
		_fef.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u006f\u0066\u0020\u0077\u0069\u0064\u0074\u0068s,\u0020\u0025\u0064 \u003c \u0025\u0064", len(_fefcg), 255-32+1)
		return nil, _fed.ErrRangeError
	}
	for _fbfc := _edadc; _fbfc <= _bbgeb; _fbfc++ {
		_dbebg._dadc[_fbfc] = _fefcg[_fbfc-_edadc]
	}
	_dbebg.Encoding = _fed.MakeName("\u0057i\u006eA\u006e\u0073\u0069\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067")
	_cffgg := &PdfFontDescriptor{}
	_cffgg.FontName = _fed.MakeName(_aegdc.PostScriptName)
	_cffgg.Ascent = _fed.MakeFloat(_cfecc * float64(_aegdc.TypoAscender))
	_cffgg.Descent = _fed.MakeFloat(_cfecc * float64(_aegdc.TypoDescender))
	_cffgg.CapHeight = _fed.MakeFloat(_cfecc * float64(_aegdc.CapHeight))
	_cffgg.FontBBox = _fed.MakeArrayFromFloats([]float64{_cfecc * float64(_aegdc.Xmin), _cfecc * float64(_aegdc.Ymin), _cfecc * float64(_aegdc.Xmax), _cfecc * float64(_aegdc.Ymax)})
	_cffgg.ItalicAngle = _fed.MakeFloat(_aegdc.ItalicAngle)
	_cffgg.MissingWidth = _fed.MakeFloat(_cfecc * float64(_aegdc.Widths[0]))
	_fgeda, _aafgd := _fed.MakeStream(_ecea, _fed.NewFlateEncoder())
	if _aafgd != nil {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074o\u0020m\u0061\u006b\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076", _aafgd)
		return nil, _aafgd
	}
	_fgeda.PdfObjectDictionary.Set("\u004ce\u006e\u0067\u0074\u0068\u0031", _fed.MakeInteger(int64(len(_ecea))))
	_cffgg.FontFile2 = _fgeda
	if _aegdc.Bold {
		_cffgg.StemV = _fed.MakeInteger(120)
	} else {
		_cffgg.StemV = _fed.MakeInteger(70)
	}
	_bcgfd := _bgaea
	if _aegdc.IsFixedPitch {
		_bcgfd |= _gcaff
	}
	if _aegdc.ItalicAngle != 0 {
		_bcgfd |= _fefa
	}
	_cffgg.Flags = _fed.MakeInteger(int64(_bcgfd))
	_dbebg._bgdgb = _cffgg
	_dcdga := &PdfFont{_gdaa: _dbebg}
	return _dcdga, nil
}

// GetXObjectByName gets XObject by name.
func (_adff *PdfPage) GetXObjectByName(name _fed.PdfObjectName) (_fed.PdfObject, bool) {
	_gfcgb, _decac := _adff.Resources.XObject.(*_fed.PdfObjectDictionary)
	if !_decac {
		return nil, false
	}
	if _abdcg := _gfcgb.Get(name); _abdcg != nil {
		return _abdcg, true
	}
	return nil, false
}

// SetPatternByName sets a pattern resource specified by keyName.
func (_gcdd *PdfPageResources) SetPatternByName(keyName _fed.PdfObjectName, pattern _fed.PdfObject) error {
	if _gcdd.Pattern == nil {
		_gcdd.Pattern = _fed.MakeDict()
	}
	_abed, _fbgd := _gcdd.Pattern.(*_fed.PdfObjectDictionary)
	if !_fbgd {
		return _fed.ErrTypeError
	}
	_abed.Set(keyName, pattern)
	return nil
}

// NewPdfAnnotationWidget returns an initialized annotation widget.
func NewPdfAnnotationWidget() *PdfAnnotationWidget {
	_adcb := NewPdfAnnotation()
	_gbae := &PdfAnnotationWidget{}
	_gbae.PdfAnnotation = _adcb
	_adcb.SetContext(_gbae)
	return _gbae
}

// GetContext returns a reference to the subpattern entry: either PdfTilingPattern or PdfShadingPattern.
func (_agfda *PdfPattern) GetContext() PdfModel      { return _agfda._ggadg }
func (_geacd *pdfFontType0) baseFields() *fontCommon { return &_geacd.fontCommon }

// NewOutlineItem returns a new outline item instance.
func NewOutlineItem(title string, dest OutlineDest) *OutlineItem {
	return &OutlineItem{Title: title, Dest: dest}
}

// GetContainingPdfObject returns the page as a dictionary within an PdfIndirectObject.
func (_ddefb *PdfPage) GetContainingPdfObject() _fed.PdfObject { return _ddefb._efbb }
func _baca(_ggbgf []byte) (_cfcbf, _daca string, _baee error) {
	_fef.Log.Trace("g\u0065\u0074\u0041\u0053CI\u0049S\u0065\u0063\u0074\u0069\u006fn\u0073\u003a\u0020\u0025\u0064\u0020", len(_ggbgf))
	_aeef := _dgdd.FindIndex(_ggbgf)
	if _aeef == nil {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0067\u0065\u0074\u0041\u0053\u0043\u0049\u0049\u0053\u0065\u0063\u0074\u0069o\u006e\u0073\u002e\u0020\u004e\u006f\u0020d\u0069\u0063\u0074\u002e")
		return "", "", _fed.ErrTypeError
	}
	_gcacf := _aeef[1]
	_fffe := _eed.Index(string(_ggbgf[_gcacf:]), _dgece)
	if _fffe < 0 {
		_cfcbf = string(_ggbgf[_gcacf:])
		return _cfcbf, "", nil
	}
	_ebfgc := _gcacf + _fffe
	_cfcbf = string(_ggbgf[_gcacf:_ebfgc])
	_fbga := _ebfgc
	_fffe = _eed.Index(string(_ggbgf[_fbga:]), _ccde)
	if _fffe < 0 {
		_fef.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0067e\u0074\u0041\u0053\u0043\u0049\u0049\u0053e\u0063\u0074\u0069\u006f\u006e\u0073\u002e\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _baee)
		return "", "", _fed.ErrTypeError
	}
	_dgag := _fbga + _fffe
	_daca = string(_ggbgf[_fbga:_dgag])
	return _cfcbf, _daca, nil
}

var (
	ErrRequiredAttributeMissing = _bb.New("\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0061\u0074t\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067")
	ErrInvalidAttribute         = _bb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065")
	ErrTypeCheck                = _bb.New("\u0074\u0079\u0070\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	_fbdeg                      = _bb.New("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072")
	ErrEncrypted                = _bb.New("\u0066\u0069\u006c\u0065\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f\u0020\u0062e\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	ErrNoFont                   = _bb.New("\u0066\u006fn\u0074\u0020\u006eo\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064")
	ErrFontNotSupported         = _dc.Errorf("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u006fn\u0074\u0020\u0028\u0025\u0077\u0029", _fed.ErrNotSupported)
	ErrType1CFontNotSupported   = _dc.Errorf("\u0054y\u0070\u00651\u0043\u0020\u0066o\u006e\u0074\u0073\u0020\u0061\u0072\u0065 \u006e\u006f\u0074\u0020\u0063\u0075r\u0072\u0065\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0028\u0025\u0077\u0029", _fed.ErrNotSupported)
	ErrType3FontNotSupported    = _dc.Errorf("\u0054y\u0070\u00653\u0020\u0066\u006f\u006et\u0073\u0020\u0061r\u0065\u0020\u006e\u006f\u0074\u0020\u0063\u0075\u0072re\u006e\u0074\u006cy\u0020\u0073u\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0028%\u0077\u0029", _fed.ErrNotSupported)
	ErrTTCmapNotSupported       = _dc.Errorf("\u0075\u006es\u0075\u0070\u0070\u006fr\u0074\u0065d\u0020\u0054\u0072\u0075\u0065\u0054\u0079\u0070e\u0020\u0063\u006d\u0061\u0070\u0020\u0066\u006f\u0072\u006d\u0061\u0074 \u0028\u0025\u0077\u0029", _fed.ErrNotSupported)
	ErrSignNotEnoughSpace       = _dc.Errorf("\u0069\u006e\u0073\u0075\u0066\u0066\u0069c\u0069\u0065\u006et\u0020\u0073\u0070a\u0063\u0065 \u0061\u006c\u006c\u006f\u0063\u0061t\u0065d \u0066\u006f\u0072\u0020\u0074\u0068\u0065\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0073")
	ErrSignNoCertificates       = _dc.Errorf("\u0063\u006ful\u0064\u0020\u006eo\u0074\u0020\u0072\u0065tri\u0065ve\u0020\u0063\u0065\u0072\u0074\u0069\u0066ic\u0061\u0074\u0065\u0020\u0063\u0068\u0061i\u006e")
)

func _bcggc(_ebcbb _fed.PdfObject) (*PdfPattern, error) {
	_egde := &PdfPattern{}
	var _adfc *_fed.PdfObjectDictionary
	if _ggffb, _egeef := _fed.GetIndirect(_ebcbb); _egeef {
		_egde._fbefb = _ggffb
		_adebf, _beefg := _ggffb.PdfObject.(*_fed.PdfObjectDictionary)
		if !_beefg {
			_fef.Log.Debug("\u0050\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006fn\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079\u0020\u0028g\u006f\u0074\u0020%\u0054\u0029", _ggffb.PdfObject)
			return nil, _fed.ErrTypeError
		}
		_adfc = _adebf
	} else if _efgcc, _fecgd := _fed.GetStream(_ebcbb); _fecgd {
		_egde._fbefb = _efgcc
		_adfc = _efgcc.PdfObjectDictionary
	} else {
		_fef.Log.Debug("\u0050a\u0074\u0074e\u0072\u006e\u0020\u006eo\u0074\u0020\u0061n\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074 o\u0062\u006a\u0065c\u0074\u0020o\u0072\u0020\u0073\u0074\u0072\u0065a\u006d\u002e \u0025\u0054", _ebcbb)
		return nil, _fed.ErrTypeError
	}
	_bbbfb := _adfc.Get("P\u0061\u0074\u0074\u0065\u0072\u006e\u0054\u0079\u0070\u0065")
	if _bbbfb == nil {
		_fef.Log.Debug("\u0050\u0064\u0066\u0020\u0050\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069n\u0067\u0020\u0050\u0061\u0074t\u0065\u0072n\u0054\u0079\u0070\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_agbde, _bdaf := _bbbfb.(*_fed.PdfObjectInteger)
	if !_bdaf {
		_fef.Log.Debug("\u0050\u0061tt\u0065\u0072\u006e \u0074\u0079\u0070\u0065 no\u0074 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067er\u0020\u0028\u0067\u006f\u0074\u0020\u0025T\u0029", _bbbfb)
		return nil, _fed.ErrTypeError
	}
	if *_agbde != 1 && *_agbde != 2 {
		_fef.Log.Debug("\u0050\u0061\u0074\u0074e\u0072\u006e\u0020\u0074\u0079\u0070\u0065\u0020\u0021\u003d \u0031/\u0032\u0020\u0028\u0067\u006f\u0074\u0020%\u0064\u0029", *_agbde)
		return nil, _fed.ErrRangeError
	}
	_egde.PatternType = int64(*_agbde)
	switch *_agbde {
	case 1:
		_fdca, _bedc := _dggg(_adfc)
		if _bedc != nil {
			return nil, _bedc
		}
		_fdca.PdfPattern = _egde
		_egde._ggadg = _fdca
		return _egde, nil
	case 2:
		_bfeea, _fgdgd := _eecggd(_adfc)
		if _fgdgd != nil {
			return nil, _fgdgd
		}
		_bfeea.PdfPattern = _egde
		_egde._ggadg = _bfeea
		return _egde, nil
	}
	return nil, _bb.New("\u0075n\u006bn\u006f\u0077\u006e\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e")
}

// ToPdfObject returns the PDF representation of the function.
func (_bdef *PdfFunctionType3) ToPdfObject() _fed.PdfObject {
	_ceaf := _fed.MakeDict()
	_ceaf.Set("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065", _fed.MakeInteger(3))
	_cfcd := &_fed.PdfObjectArray{}
	for _, _fcfc := range _bdef.Domain {
		_cfcd.Append(_fed.MakeFloat(_fcfc))
	}
	_ceaf.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _cfcd)
	if _bdef.Range != nil {
		_fffb := &_fed.PdfObjectArray{}
		for _, _cdbe := range _bdef.Range {
			_fffb.Append(_fed.MakeFloat(_cdbe))
		}
		_ceaf.Set("\u0052\u0061\u006eg\u0065", _fffb)
	}
	if _bdef.Functions != nil {
		_gefb := &_fed.PdfObjectArray{}
		for _, _aeee := range _bdef.Functions {
			_gefb.Append(_aeee.ToPdfObject())
		}
		_ceaf.Set("\u0046u\u006e\u0063\u0074\u0069\u006f\u006es", _gefb)
	}
	if _bdef.Bounds != nil {
		_aadfc := &_fed.PdfObjectArray{}
		for _, _dcfd := range _bdef.Bounds {
			_aadfc.Append(_fed.MakeFloat(_dcfd))
		}
		_ceaf.Set("\u0042\u006f\u0075\u006e\u0064\u0073", _aadfc)
	}
	if _bdef.Encode != nil {
		_cdebf := &_fed.PdfObjectArray{}
		for _, _gefeb := range _bdef.Encode {
			_cdebf.Append(_fed.MakeFloat(_gefeb))
		}
		_ceaf.Set("\u0045\u006e\u0063\u006f\u0064\u0065", _cdebf)
	}
	if _bdef._dfeeb != nil {
		_bdef._dfeeb.PdfObject = _ceaf
		return _bdef._dfeeb
	}
	return _ceaf
}

// NewXObjectImageFromImage creates a new XObject Image from an image object
// with default options. If encoder is nil, uses raw encoding (none).
func NewXObjectImageFromImage(img *Image, cs PdfColorspace, encoder _fed.StreamEncoder) (*XObjectImage, error) {
	_egbd := NewXObjectImage()
	return UpdateXObjectImageFromImage(_egbd, img, cs, encoder)
}

// GetContext returns the annotation context which contains the specific type-dependent context.
// The context represents the subannotation.
func (_ede *PdfAnnotation) GetContext() PdfModel {
	if _ede == nil {
		return nil
	}
	return _ede._adc
}
func _cagff(_egad *_fed.PdfObjectDictionary) (*PdfShadingType3, error) {
	_afdga := PdfShadingType3{}
	_bgdagd := _egad.Get("\u0043\u006f\u006f\u0072\u0064\u0073")
	if _bgdagd == nil {
		_fef.Log.Debug("\u0052\u0065\u0071ui\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069b\u0075t\u0065 \u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0043\u006f\u006f\u0072\u0064\u0073")
		return nil, ErrRequiredAttributeMissing
	}
	_febac, _dfagc := _bgdagd.(*_fed.PdfObjectArray)
	if !_dfagc {
		_fef.Log.Debug("\u0043\u006f\u006f\u0072d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _bgdagd)
		return nil, _fed.ErrTypeError
	}
	if _febac.Len() != 6 {
		_fef.Log.Debug("\u0043\u006f\u006f\u0072d\u0073\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074 \u0036\u0020\u0028\u0067\u006f\u0074\u0020%\u0064\u0029", _febac.Len())
		return nil, ErrInvalidAttribute
	}
	_afdga.Coords = _febac
	if _ffcca := _egad.Get("\u0044\u006f\u006d\u0061\u0069\u006e"); _ffcca != nil {
		_ffcca = _fed.TraceToDirectObject(_ffcca)
		_dbdba, _badgc := _ffcca.(*_fed.PdfObjectArray)
		if !_badgc {
			_fef.Log.Debug("\u0044\u006f\u006d\u0061i\u006e\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _ffcca)
			return nil, _fed.ErrTypeError
		}
		_afdga.Domain = _dbdba
	}
	_bgdagd = _egad.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e")
	if _bgdagd == nil {
		_fef.Log.Debug("\u0052\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0020\u0046\u0075\u006ec\u0074\u0069\u006f\u006e")
		return nil, ErrRequiredAttributeMissing
	}
	_afdga.Function = []PdfFunction{}
	if _aagbf, _agbbge := _bgdagd.(*_fed.PdfObjectArray); _agbbge {
		for _, _cbbbg := range _aagbf.Elements() {
			_bdeef, _bbfbg := _bggad(_cbbbg)
			if _bbfbg != nil {
				_fef.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _bbfbg)
				return nil, _bbfbg
			}
			_afdga.Function = append(_afdga.Function, _bdeef)
		}
	} else {
		_bbgdb, _deaac := _bggad(_bgdagd)
		if _deaac != nil {
			_fef.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _deaac)
			return nil, _deaac
		}
		_afdga.Function = append(_afdga.Function, _bbgdb)
	}
	if _cabcd := _egad.Get("\u0045\u0078\u0074\u0065\u006e\u0064"); _cabcd != nil {
		_cabcd = _fed.TraceToDirectObject(_cabcd)
		_aebed, _gefbc := _cabcd.(*_fed.PdfObjectArray)
		if !_gefbc {
			_fef.Log.Debug("\u004d\u0061\u0074\u0072i\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _cabcd)
			return nil, _fed.ErrTypeError
		}
		if _aebed.Len() != 2 {
			_fef.Log.Debug("\u0045\u0078\u0074\u0065n\u0064\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074 \u0032\u0020\u0028\u0067\u006f\u0074\u0020%\u0064\u0029", _aebed.Len())
			return nil, ErrInvalidAttribute
		}
		_afdga.Extend = _aebed
	}
	return &_afdga, nil
}
func (_afdf *PdfReader) newPdfAnnotationProjectionFromDict(_gbbb *_fed.PdfObjectDictionary) (*PdfAnnotationProjection, error) {
	_afcd := &PdfAnnotationProjection{}
	_ffc, _dbef := _afdf.newPdfAnnotationMarkupFromDict(_gbbb)
	if _dbef != nil {
		return nil, _dbef
	}
	_afcd.PdfAnnotationMarkup = _ffc
	return _afcd, nil
}

// PdfFieldText represents a text field where user can enter text.
type PdfFieldText struct {
	*PdfField
	DA     *_fed.PdfObjectString
	Q      *_fed.PdfObjectInteger
	DS     *_fed.PdfObjectString
	RV     _fed.PdfObject
	MaxLen *_fed.PdfObjectInteger
}

// SetFlag sets the flag for the field.
func (_ecaef *PdfField) SetFlag(flag FieldFlag) { _ecaef.Ff = _fed.MakeInteger(int64(flag)) }

// NewPdfAnnotationWatermark returns a new watermark annotation.
func NewPdfAnnotationWatermark() *PdfAnnotationWatermark {
	_bac := NewPdfAnnotation()
	_fagc := &PdfAnnotationWatermark{}
	_fagc.PdfAnnotation = _bac
	_bac.SetContext(_fagc)
	return _fagc
}

// ToPdfObject implements interface PdfModel.
func (_eccg *PdfAnnotationText) ToPdfObject() _fed.PdfObject {
	_eccg.PdfAnnotation.ToPdfObject()
	_bafb := _eccg._ffaab
	_cfce := _bafb.PdfObject.(*_fed.PdfObjectDictionary)
	if _eccg.PdfAnnotationMarkup != nil {
		_eccg.PdfAnnotationMarkup.appendToPdfDictionary(_cfce)
	}
	_cfce.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u0054\u0065\u0078\u0074"))
	_cfce.SetIfNotNil("\u004f\u0070\u0065\u006e", _eccg.Open)
	_cfce.SetIfNotNil("\u004e\u0061\u006d\u0065", _eccg.Name)
	_cfce.SetIfNotNil("\u0053\u0074\u0061t\u0065", _eccg.State)
	_cfce.SetIfNotNil("\u0053\u0074\u0061\u0074\u0065\u004d\u006f\u0064\u0065\u006c", _eccg.StateModel)
	return _bafb
}

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// components. The slice should contain three PdfObjectFloat elements representing
// the L, A and B components of the color.
func (_gbcefe *PdfColorspaceLab) ColorFromPdfObjects(objects []_fed.PdfObject) (PdfColor, error) {
	if len(objects) != 3 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_cgabd, _cecb := _fed.GetNumbersAsFloat(objects)
	if _cecb != nil {
		return nil, _cecb
	}
	return _gbcefe.ColorFromFloats(_cgabd)
}

// SetEncoder sets the encoding for the underlying font.
// TODO(peterwilliams97): Change function signature to SetEncoder(encoder *textencoding.simpleEncoder).
// TODO(gunnsth): Makes sense if SetEncoder is removed from the interface fonts.Font as proposed in PR #260.
func (_bcaef *pdfFontSimple) SetEncoder(encoder _dg.TextEncoder) { _bcaef._ebcbf = encoder }

// ToPdfObject converts the pdfCIDFontType0 to a PDF representation.
func (_cfceb *pdfCIDFontType0) ToPdfObject() _fed.PdfObject { return _fed.MakeNull() }

// PdfColorspaceICCBased format [/ICCBased stream]
//
// The stream shall contain the ICC profile.
// A conforming reader shall support ICC.1:2004:10 as required by PDF 1.7, which will enable it
// to properly render all embedded ICC profiles regardless of the PDF version
//
// In the current implementation, we rely on the alternative colormap provided.
type PdfColorspaceICCBased struct {
	N         int
	Alternate PdfColorspace

	// If omitted ICC not supported: then use DeviceGray,
	// DeviceRGB or DeviceCMYK for N=1,3,4 respectively.
	Range    []float64
	Metadata *_fed.PdfObjectStream
	Data     []byte
	_caga    *_fed.PdfIndirectObject
	_dceb    *_fed.PdfObjectStream
}

// GetOCProperties returns the optional content properties PdfObject.
func (_eabcb *PdfReader) GetOCProperties() (_fed.PdfObject, error) {
	_eadca := _eabcb._bfcdc
	_eaacf := _eadca.Get("\u004f\u0043\u0050r\u006f\u0070\u0065\u0072\u0074\u0069\u0065\u0073")
	_eaacf = _fed.ResolveReference(_eaacf)
	if !_eabcb._bgbff {
		_bfage := _eabcb.traverseObjectData(_eaacf)
		if _bfage != nil {
			return nil, _bfage
		}
	}
	return _eaacf, nil
}

// ColorToRGB converts a ICCBased color to an RGB color.
func (_gfddd *PdfColorspaceICCBased) ColorToRGB(color PdfColor) (PdfColor, error) {
	if _gfddd.Alternate == nil {
		_fef.Log.Debug("I\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061lt\u0065\u0072\u006ea\u0074i\u0076\u0065")
		if _gfddd.N == 1 {
			_fef.Log.Debug("\u0049\u0043\u0043\u0020\u0042a\u0073\u0065\u0064\u0020\u0063o\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061\u006c\u0074\u0065r\u006e\u0061\u0074\u0069\u0076\u0065\u0020\u002d\u0020\u0075\u0073\u0069\u006e\u0067\u0020\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061y\u0020\u0028\u004e\u003d\u0031\u0029")
			_ebegb := NewPdfColorspaceDeviceGray()
			return _ebegb.ColorToRGB(color)
		} else if _gfddd.N == 3 {
			_fef.Log.Debug("\u0049\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070a\u0063\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0061\u006c\u0074\u0065\u0072\u006e\u0061\u0074\u0069\u0076\u0065\u0020\u002d\u0020\u0075\u0073\u0069\u006eg\u0020\u0044\u0065\u0076\u0069\u0063e\u0052\u0047B\u0020\u0028N\u003d3\u0029")
			return color, nil
		} else if _gfddd.N == 4 {
			_fef.Log.Debug("\u0049\u0043\u0043\u0020\u0042a\u0073\u0065\u0064\u0020\u0063o\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061\u006c\u0074\u0065r\u006e\u0061\u0074\u0069\u0076\u0065\u0020\u002d\u0020\u0075\u0073\u0069\u006e\u0067\u0020\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059K\u0020\u0028\u004e\u003d\u0034\u0029")
			_ddbc := NewPdfColorspaceDeviceCMYK()
			return _ddbc.ColorToRGB(color)
		} else {
			return nil, _bb.New("I\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061lt\u0065\u0072\u006ea\u0074i\u0076\u0065")
		}
	}
	_fef.Log.Trace("\u0049\u0043\u0043 \u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u0077\u0069\u0074\u0068\u0020\u0061\u006c\u0074\u0065\u0072\u006e\u0061t\u0069\u0076\u0065\u003a\u0020\u0025\u0023\u0076", _gfddd)
	return _gfddd.Alternate.ColorToRGB(color)
}

// PdfVersion returns version of the PDF file.
func (_bddcf *PdfReader) PdfVersion() _fed.Version { return _bddcf._cdfggf.PdfVersion() }

// ColorToRGB converts a color in Separation colorspace to RGB colorspace.
func (_geeab *PdfColorspaceSpecialSeparation) ColorToRGB(color PdfColor) (PdfColor, error) {
	if _geeab.AlternateSpace == nil {
		return nil, _bb.New("\u0061\u006c\u0074\u0065\u0072\u006e\u0061\u0074\u0065\u0020c\u006f\u006c\u006f\u0072\u0073\u0070\u0061c\u0065\u0020\u0075\u006e\u0064\u0065\u0066\u0069\u006e\u0065\u0064")
	}
	return _geeab.AlternateSpace.ColorToRGB(color)
}

// PdfColorspaceSpecialPattern is a Pattern colorspace.
// Can be defined either as /Pattern or with an underlying colorspace [/Pattern cs].
type PdfColorspaceSpecialPattern struct {
	UnderlyingCS PdfColorspace
	_afff        *_fed.PdfIndirectObject
}

// PdfColorspaceDeviceRGB represents an RGB colorspace.
type PdfColorspaceDeviceRGB struct{}

// PdfShadingPattern is a Shading patterns that provide a smooth transition between colors across an area to be painted,
// i.e. color(x,y) = f(x,y) at each point.
// It is a type 2 pattern (PatternType = 2).
type PdfShadingPattern struct {
	*PdfPattern
	Shading   *PdfShading
	Matrix    *_fed.PdfObjectArray
	ExtGState _fed.PdfObject
}

var (
	_abadca _g.Mutex
	_eebc   = ""
	_facfe  _e.Time
	_cgeda  = ""
	_acge   = ""
	_edeaf  _e.Time
	_dbfc   = ""
	_eeffe  = ""
	_gfcfc  = ""
)

// NewPdfColorspaceDeviceGray returns a new grayscale colorspace.
func NewPdfColorspaceDeviceGray() *PdfColorspaceDeviceGray { return &PdfColorspaceDeviceGray{} }

// Evaluate runs the function on the passed in slice and returns the results.
func (_ceabg *PdfFunctionType0) Evaluate(x []float64) ([]float64, error) {
	if len(x) != _ceabg.NumInputs {
		_fef.Log.Error("\u004eu\u006d\u0062e\u0072\u0020\u006f\u0066 \u0069\u006e\u0070u\u0074\u0073\u0020\u006e\u006f\u0074\u0020\u006d\u0061tc\u0068\u0069\u006eg\u0020\u0077h\u0061\u0074\u0020\u0069\u0073\u0020n\u0065\u0065d\u0065\u0064")
		return nil, _bb.New("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072")
	}
	if _ceabg._adfdc == nil {
		_eega := _ceabg.processSamples()
		if _eega != nil {
			return nil, _eega
		}
	}
	_gdege := _ceabg.Encode
	if _gdege == nil {
		_gdege = []float64{}
		for _acgda := 0; _acgda < len(_ceabg.Size); _acgda++ {
			_gdege = append(_gdege, 0)
			_gdege = append(_gdege, float64(_ceabg.Size[_acgda]-1))
		}
	}
	_faeg := _ceabg.Decode
	if _faeg == nil {
		_faeg = _ceabg.Range
	}
	_gedbe := make([]int, len(x))
	for _eaad := 0; _eaad < len(x); _eaad++ {
		_fdbf := x[_eaad]
		_fdfa := _bg.Min(_bg.Max(_fdbf, _ceabg.Domain[2*_eaad]), _ceabg.Domain[2*_eaad+1])
		_bgaf := _eede.LinearInterpolate(_fdfa, _ceabg.Domain[2*_eaad], _ceabg.Domain[2*_eaad+1], _gdege[2*_eaad], _gdege[2*_eaad+1])
		_ggff := _bg.Min(_bg.Max(_bgaf, 0), float64(_ceabg.Size[_eaad]-1))
		_egdge := int(_bg.Floor(_ggff + 0.5))
		if _egdge < 0 {
			_egdge = 0
		} else if _egdge > _ceabg.Size[_eaad] {
			_egdge = _ceabg.Size[_eaad] - 1
		}
		_gedbe[_eaad] = _egdge
	}
	_abca := _gedbe[0]
	for _eacaf := 1; _eacaf < _ceabg.NumInputs; _eacaf++ {
		_adbebf := _gedbe[_eacaf]
		for _egdcg := 0; _egdcg < _eacaf; _egdcg++ {
			_adbebf *= _ceabg.Size[_egdcg]
		}
		_abca += _adbebf
	}
	_abca *= _ceabg.NumOutputs
	var _badcb []float64
	for _fabe := 0; _fabe < _ceabg.NumOutputs; _fabe++ {
		_gaegd := _abca + _fabe
		if _gaegd >= len(_ceabg._adfdc) {
			_fef.Log.Debug("\u0057\u0041\u0052\u004e\u003a \u006e\u006ft\u0020\u0065\u006eo\u0075\u0067\u0068\u0020\u0069\u006ep\u0075\u0074\u0020sa\u006dp\u006c\u0065\u0073\u0020\u0074\u006f\u0020d\u0065\u0074\u0065\u0072\u006d\u0069\u006e\u0065\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0076\u0061lu\u0065\u0073\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e")
			continue
		}
		_gdag := _ceabg._adfdc[_gaegd]
		_bgabe := _eede.LinearInterpolate(float64(_gdag), 0, _bg.Pow(2, float64(_ceabg.BitsPerSample)), _faeg[2*_fabe], _faeg[2*_fabe+1])
		_bccb := _bg.Min(_bg.Max(_bgabe, _ceabg.Range[2*_fabe]), _ceabg.Range[2*_fabe+1])
		_badcb = append(_badcb, _bccb)
	}
	return _badcb, nil
}
func _ddfcf(_adbac _fed.PdfObject, _dbdc *fontCommon) (*_edf.CMap, error) {
	_fefcf, _babb := _fed.GetStream(_adbac)
	if !_babb {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0074\u006f\u0055\u006e\u0069\u0063\u006f\u0064\u0065\u0054\u006f\u0043m\u0061\u0070\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0028\u0025\u0054\u0029", _adbac)
		return nil, _fed.ErrTypeError
	}
	_baded, _dfccg := _fed.DecodeStream(_fefcf)
	if _dfccg != nil {
		return nil, _dfccg
	}
	_geac, _dfccg := _edf.LoadCmapFromData(_baded, !_dbdc.isCIDFont())
	if _dfccg != nil {
		_fef.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u004e\u0075\u006d\u0062\u0065\u0072\u003d\u0025\u0064\u0020\u0065\u0072r=\u0025\u0076", _fefcf.ObjectNumber, _dfccg)
	}
	return _geac, _dfccg
}
func (_bgae *PdfAppender) replaceObject(_afdc, _gaff _fed.PdfObject) {
	switch _fecc := _afdc.(type) {
	case *_fed.PdfIndirectObject:
		_bgae._aebf[_gaff] = _fecc.ObjectNumber
	case *_fed.PdfObjectStream:
		_bgae._aebf[_gaff] = _fecc.ObjectNumber
	}
}

// PdfPageResourcesColorspaces contains the colorspace in the PdfPageResources.
// Needs to have matching name and colorspace map entry. The Names define the order.
type PdfPageResourcesColorspaces struct {
	Names       []string
	Colorspaces map[string]PdfColorspace
	_bdbfa      *_fed.PdfIndirectObject
}

// FontDescriptor returns font's PdfFontDescriptor. This may be a builtin descriptor for standard 14
// fonts but must be an explicit descriptor for other fonts.
func (_gabfa *PdfFont) FontDescriptor() *PdfFontDescriptor {
	if _gabfa.baseFields()._bgdgb != nil {
		return _gabfa.baseFields()._bgdgb
	}
	if _cecf := _gabfa._gdaa.getFontDescriptor(); _cecf != nil {
		return _cecf
	}
	_fef.Log.Error("\u0041\u006cl \u0066\u006f\u006et\u0073\u0020\u0068\u0061ve \u0061 D\u0065\u0073\u0063\u0072\u0069\u0070\u0074or\u002e\u0020\u0066\u006f\u006e\u0074\u003d%\u0073", _gabfa)
	return nil
}

// HasExtGState checks whether a font is defined by the specified keyName.
func (_acfc *PdfPageResources) HasExtGState(keyName _fed.PdfObjectName) bool {
	_, _ffebd := _acfc.GetFontByName(keyName)
	return _ffebd
}

// NewXObjectImage returns a new XObjectImage.
func NewXObjectImage() *XObjectImage {
	_gbcc := &XObjectImage{}
	_defaf := &_fed.PdfObjectStream{}
	_defaf.PdfObjectDictionary = _fed.MakeDict()
	_gbcc._agffg = _defaf
	return _gbcc
}
func (_fbbfc *PdfReader) lookupPageByObject(_gbagb _fed.PdfObject) (*PdfPage, error) {
	return nil, _bb.New("\u0070\u0061\u0067\u0065\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064")
}

// NewPdfActionURI returns a new "Uri" action.
func NewPdfActionURI() *PdfActionURI {
	_fefc := NewPdfAction()
	_ded := &PdfActionURI{}
	_ded.PdfAction = _fefc
	_fefc.SetContext(_ded)
	return _ded
}

// GetSubFilter returns SubFilter value or empty string.
func (_eeggb *pdfSignDictionary) GetSubFilter() string {
	_gaaca := _eeggb.Get("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r")
	if _gaaca == nil {
		return ""
	}
	if _abgdg, _cgfdc := _fed.GetNameVal(_gaaca); _cgfdc {
		return _abgdg
	}
	return ""
}

// ToPdfObject implements interface PdfModel.
func (_adbd *PdfAnnotationRichMedia) ToPdfObject() _fed.PdfObject {
	_adbd.PdfAnnotation.ToPdfObject()
	_abad := _adbd._ffaab
	_gfed := _abad.PdfObject.(*_fed.PdfObjectDictionary)
	_gfed.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u0052i\u0063\u0068\u004d\u0065\u0064\u0069a"))
	_gfed.SetIfNotNil("\u0052\u0069\u0063\u0068\u004d\u0065\u0064\u0069\u0061\u0053\u0065\u0074t\u0069\u006e\u0067\u0073", _adbd.RichMediaSettings)
	_gfed.SetIfNotNil("\u0052\u0069c\u0068\u004d\u0065d\u0069\u0061\u0043\u006f\u006e\u0074\u0065\u006e\u0074", _adbd.RichMediaContent)
	return _abad
}
func (_faagb *PdfWriter) writeBytes(_egbcg []byte) {
	if _faagb._deee != nil {
		return
	}
	_adeccd, _gaecg := _faagb._adge.Write(_egbcg)
	_faagb._cgdb += int64(_adeccd)
	_faagb._deee = _gaecg
}

// AddExtGState add External Graphics State (GState). The gsDict can be specified
// either directly as a dictionary or an indirect object containing a dictionary.
func (_fecfg *PdfPageResources) AddExtGState(gsName _fed.PdfObjectName, gsDict _fed.PdfObject) error {
	if _fecfg.ExtGState == nil {
		_fecfg.ExtGState = _fed.MakeDict()
	}
	_gegbbg := _fecfg.ExtGState
	_eeeec, _bcce := _fed.TraceToDirectObject(_gegbbg).(*_fed.PdfObjectDictionary)
	if !_bcce {
		_fef.Log.Debug("\u0045\u0078\u0074\u0047\u0053\u0074\u0061\u0074\u0065\u0020\u0074\u0079\u0070\u0065\u0020e\u0072r\u006f\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u002f\u0025\u0054\u0029", _gegbbg, _fed.TraceToDirectObject(_gegbbg))
		return _fed.ErrTypeError
	}
	_eeeec.Set(gsName, gsDict)
	return nil
}

// PdfActionSubmitForm represents a submitForm action.
type PdfActionSubmitForm struct {
	*PdfAction
	F      *PdfFilespec
	Fields _fed.PdfObject
	Flags  _fed.PdfObject
}

// GetNumComponents returns the number of color components of the colorspace device.
// Returns 3 for a CalRGB device.
func (_dbab *PdfColorspaceCalRGB) GetNumComponents() int { return 3 }

// ToPdfObject returns the PDF representation of the colorspace.
func (_bdfg *PdfColorspaceDeviceCMYK) ToPdfObject() _fed.PdfObject {
	return _fed.MakeName("\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b")
}

var _ pdfFont = (*pdfCIDFontType0)(nil)

// ToPdfObject converts the PdfPage to a dictionary within an indirect object container.
func (_becb *PdfPage) ToPdfObject() _fed.PdfObject {
	_geae := _becb._efbb
	_becb.GetPageDict()
	return _geae
}

// Flags returns the field flags for the field accounting for any inherited flags.
func (_aaeff *PdfField) Flags() FieldFlag {
	var _ebbbc FieldFlag
	_ebgc, _ceead := _aaeff.inherit(func(_ccdag *PdfField) bool {
		if _ccdag.Ff != nil {
			_ebbbc = FieldFlag(*_ccdag.Ff)
			return true
		}
		return false
	})
	if _ceead != nil {
		_fef.Log.Debug("\u0045\u0072\u0072o\u0072\u0020\u0065\u0076\u0061\u006c\u0075\u0061\u0074\u0069\u006e\u0067\u0020\u0066\u006c\u0061\u0067\u0073\u0020\u0076\u0069\u0061\u0020\u0069\u006e\u0068\u0065\u0072\u0069t\u0061\u006e\u0063\u0065\u003a\u0020\u0025\u0076", _ceead)
	}
	if !_ebgc {
		_fef.Log.Trace("N\u006f\u0020\u0066\u0069\u0065\u006cd\u0020\u0066\u006c\u0061\u0067\u0073 \u0066\u006f\u0075\u006e\u0064\u0020\u002d \u0061\u0073\u0073\u0075\u006d\u0065\u0020\u0063\u006c\u0065a\u0072")
	}
	return _ebbbc
}

// ToPdfObject implements interface PdfModel.
func (_gfad *PdfAnnotationWidget) ToPdfObject() _fed.PdfObject {
	_gfad.PdfAnnotation.ToPdfObject()
	_gefe := _gfad._ffaab
	_ecg := _gefe.PdfObject.(*_fed.PdfObjectDictionary)
	if _gfad._dff {
		return _gefe
	}
	_gfad._dff = true
	_ecg.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u0057\u0069\u0064\u0067\u0065\u0074"))
	_ecg.SetIfNotNil("\u0048", _gfad.H)
	_ecg.SetIfNotNil("\u004d\u004b", _gfad.MK)
	_ecg.SetIfNotNil("\u0041", _gfad.A)
	_ecg.SetIfNotNil("\u0041\u0041", _gfad.AA)
	_ecg.SetIfNotNil("\u0042\u0053", _gfad.BS)
	_gecdb := _gfad.Parent
	if _gfad._eagb != nil {
		if _gfad._eagb._cbaae == _gfad._ffaab {
			_gfad._eagb.ToPdfObject()
		}
		_gecdb = _gfad._eagb.GetContainingPdfObject()
	}
	if _gecdb != _gefe {
		_ecg.SetIfNotNil("\u0050\u0061\u0072\u0065\u006e\u0074", _gecdb)
	}
	_gfad._dff = false
	return _gefe
}

// PdfPage represents a page in a PDF document. (7.7.3.3 - Table 30).
type PdfPage struct {
	Parent               _fed.PdfObject
	LastModified         *PdfDate
	Resources            *PdfPageResources
	CropBox              *PdfRectangle
	MediaBox             *PdfRectangle
	BleedBox             *PdfRectangle
	TrimBox              *PdfRectangle
	ArtBox               *PdfRectangle
	BoxColorInfo         _fed.PdfObject
	Contents             _fed.PdfObject
	Rotate               *int64
	Group                _fed.PdfObject
	Thumb                _fed.PdfObject
	B                    _fed.PdfObject
	Dur                  _fed.PdfObject
	Trans                _fed.PdfObject
	AA                   _fed.PdfObject
	Metadata             _fed.PdfObject
	PieceInfo            _fed.PdfObject
	StructParents        _fed.PdfObject
	ID                   _fed.PdfObject
	PZ                   _fed.PdfObject
	SeparationInfo       _fed.PdfObject
	Tabs                 _fed.PdfObject
	TemplateInstantiated _fed.PdfObject
	PresSteps            _fed.PdfObject
	UserUnit             _fed.PdfObject
	VP                   _fed.PdfObject
	Annots               _fed.PdfObject
	_abcb                []*PdfAnnotation
	_bdgge               *_fed.PdfObjectDictionary
	_efbb                *_fed.PdfIndirectObject
	_fdcd                *PdfReader
}

// GetPageDict converts the Page to a PDF object dictionary.
func (_gdfae *PdfPage) GetPageDict() *_fed.PdfObjectDictionary {
	_gadeb := _gdfae._bdgge
	_gadeb.Clear()
	_gadeb.Set("\u0054\u0079\u0070\u0065", _fed.MakeName("\u0050\u0061\u0067\u0065"))
	_gadeb.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _gdfae.Parent)
	if _gdfae.LastModified != nil {
		_gadeb.Set("\u004c\u0061\u0073t\u004d\u006f\u0064\u0069\u0066\u0069\u0065\u0064", _gdfae.LastModified.ToPdfObject())
	}
	if _gdfae.Resources != nil {
		_gadeb.Set("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s", _gdfae.Resources.ToPdfObject())
	}
	if _gdfae.CropBox != nil {
		_gadeb.Set("\u0043r\u006f\u0070\u0042\u006f\u0078", _gdfae.CropBox.ToPdfObject())
	}
	if _gdfae.MediaBox != nil {
		_gadeb.Set("\u004d\u0065\u0064\u0069\u0061\u0042\u006f\u0078", _gdfae.MediaBox.ToPdfObject())
	}
	if _gdfae.BleedBox != nil {
		_gadeb.Set("\u0042\u006c\u0065\u0065\u0064\u0042\u006f\u0078", _gdfae.BleedBox.ToPdfObject())
	}
	if _gdfae.TrimBox != nil {
		_gadeb.Set("\u0054r\u0069\u006d\u0042\u006f\u0078", _gdfae.TrimBox.ToPdfObject())
	}
	if _gdfae.ArtBox != nil {
		_gadeb.Set("\u0041\u0072\u0074\u0042\u006f\u0078", _gdfae.ArtBox.ToPdfObject())
	}
	_gadeb.SetIfNotNil("\u0042\u006f\u0078C\u006f\u006c\u006f\u0072\u0049\u006e\u0066\u006f", _gdfae.BoxColorInfo)
	_gadeb.SetIfNotNil("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073", _gdfae.Contents)
	if _gdfae.Rotate != nil {
		_gadeb.Set("\u0052\u006f\u0074\u0061\u0074\u0065", _fed.MakeInteger(*_gdfae.Rotate))
	}
	_gadeb.SetIfNotNil("\u0047\u0072\u006fu\u0070", _gdfae.Group)
	_gadeb.SetIfNotNil("\u0054\u0068\u0075m\u0062", _gdfae.Thumb)
	_gadeb.SetIfNotNil("\u0042", _gdfae.B)
	_gadeb.SetIfNotNil("\u0044\u0075\u0072", _gdfae.Dur)
	_gadeb.SetIfNotNil("\u0054\u0072\u0061n\u0073", _gdfae.Trans)
	_gadeb.SetIfNotNil("\u0041\u0041", _gdfae.AA)
	_gadeb.SetIfNotNil("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061", _gdfae.Metadata)
	_gadeb.SetIfNotNil("\u0050i\u0065\u0063\u0065\u0049\u006e\u0066o", _gdfae.PieceInfo)
	_gadeb.SetIfNotNil("\u0053\u0074\u0072\u0075\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074\u0073", _gdfae.StructParents)
	_gadeb.SetIfNotNil("\u0049\u0044", _gdfae.ID)
	_gadeb.SetIfNotNil("\u0050\u005a", _gdfae.PZ)
	_gadeb.SetIfNotNil("\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006fn\u0049\u006e\u0066\u006f", _gdfae.SeparationInfo)
	_gadeb.SetIfNotNil("\u0054\u0061\u0062\u0073", _gdfae.Tabs)
	_gadeb.SetIfNotNil("T\u0065m\u0070\u006c\u0061\u0074\u0065\u0049\u006e\u0073t\u0061\u006e\u0074\u0069at\u0065\u0064", _gdfae.TemplateInstantiated)
	_gadeb.SetIfNotNil("\u0050r\u0065\u0073\u0053\u0074\u0065\u0070s", _gdfae.PresSteps)
	_gadeb.SetIfNotNil("\u0055\u0073\u0065\u0072\u0055\u006e\u0069\u0074", _gdfae.UserUnit)
	_gadeb.SetIfNotNil("\u0056\u0050", _gdfae.VP)
	if _gdfae._abcb != nil {
		_efeaf := _fed.MakeArray()
		for _, _bedag := range _gdfae._abcb {
			if _aebbe := _bedag.GetContext(); _aebbe != nil {
				_efeaf.Append(_aebbe.ToPdfObject())
			} else {
				_efeaf.Append(_bedag.ToPdfObject())
			}
		}
		if _efeaf.Len() > 0 {
			_gadeb.Set("\u0041\u006e\u006e\u006f\u0074\u0073", _efeaf)
		}
	} else if _gdfae.Annots != nil {
		_gadeb.SetIfNotNil("\u0041\u006e\u006e\u006f\u0074\u0073", _gdfae.Annots)
	}
	return _gadeb
}

// PdfActionThread represents a thread action.
type PdfActionThread struct {
	*PdfAction
	F *PdfFilespec
	D _fed.PdfObject
	B _fed.PdfObject
}

// GetObjectNums returns the object numbers of the PDF objects in the file
// Numbered objects are either indirect objects or stream objects.
// e.g. objNums := pdfReader.GetObjectNums()
// The underlying objects can then be accessed with
// pdfReader.GetIndirectObjectByNumber(objNums[0]) for the first available object.
func (_ecbccc *PdfReader) GetObjectNums() []int { return _ecbccc._cdfggf.GetObjectNums() }
func (_eadee *PdfAcroForm) signatureFields() []*PdfFieldSignature {
	var _dcebbcd []*PdfFieldSignature
	for _, _ccga := range _eadee.AllFields() {
		switch _bgbf := _ccga.GetContext().(type) {
		case *PdfFieldSignature:
			_aceg := _bgbf
			_dcebbcd = append(_dcebbcd, _aceg)
		}
	}
	return _dcebbcd
}
func (_fdbg *PdfColorspaceCalRGB) String() string { return "\u0043\u0061\u006c\u0052\u0047\u0042" }

// PdfAnnotationWatermark represents Watermark annotations.
// (Section 12.5.6.22).
type PdfAnnotationWatermark struct {
	*PdfAnnotation
	FixedPrint _fed.PdfObject
}

// PdfAnnotationScreen represents Screen annotations.
// (Section 12.5.6.18).
type PdfAnnotationScreen struct {
	*PdfAnnotation
	T  _fed.PdfObject
	MK _fed.PdfObject
	A  _fed.PdfObject
	AA _fed.PdfObject
}

func _gegad(_bggfd *_fed.PdfObjectDictionary) (*PdfShadingType5, error) {
	_dcbbe := PdfShadingType5{}
	_ccebf := _bggfd.Get("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065")
	if _ccebf == nil {
		_fef.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064 \u0061\u0074\u0074\u0072\u0069\u0062\u0075t\u0065\u0020\u006d\u0069\u0073\u0073i\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072C\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_gffgg, _gfcbc := _ccebf.(*_fed.PdfObjectInteger)
	if !_gfcbc {
		_fef.Log.Debug("\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _ccebf)
		return nil, _fed.ErrTypeError
	}
	_dcbbe.BitsPerCoordinate = _gffgg
	_ccebf = _bggfd.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074")
	if _ccebf == nil {
		_fef.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064\u0020a\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073\u0073in\u0067\u003a\u0020B\u0069\u0074s\u0050\u0065\u0072\u0043\u006f\u006dp\u006f\u006ee\u006e\u0074")
		return nil, ErrRequiredAttributeMissing
	}
	_gffgg, _gfcbc = _ccebf.(*_fed.PdfObjectInteger)
	if !_gfcbc {
		_fef.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065r \u0028\u0067\u006ft\u0020%\u0054\u0029", _ccebf)
		return nil, _fed.ErrTypeError
	}
	_dcbbe.BitsPerComponent = _gffgg
	_ccebf = _bggfd.Get("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073\u0050e\u0072\u0052\u006f\u0077")
	if _ccebf == nil {
		_fef.Log.Debug("\u0052\u0065\u0071u\u0069\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0056\u0065\u0072\u0074\u0069c\u0065\u0073\u0050\u0065\u0072\u0052\u006f\u0077")
		return nil, ErrRequiredAttributeMissing
	}
	_gffgg, _gfcbc = _ccebf.(*_fed.PdfObjectInteger)
	if !_gfcbc {
		_fef.Log.Debug("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073\u0050\u0065\u0072\u0052\u006f\u0077\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006et\u0065\u0067\u0065\u0072\u0020(\u0067\u006ft\u0020\u0025\u0054\u0029", _ccebf)
		return nil, _fed.ErrTypeError
	}
	_dcbbe.VerticesPerRow = _gffgg
	_ccebf = _bggfd.Get("\u0044\u0065\u0063\u006f\u0064\u0065")
	if _ccebf == nil {
		_fef.Log.Debug("\u0052\u0065\u0071ui\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069b\u0075t\u0065 \u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_babaef, _gfcbc := _ccebf.(*_fed.PdfObjectArray)
	if !_gfcbc {
		_fef.Log.Debug("\u0044\u0065\u0063\u006fd\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _ccebf)
		return nil, _fed.ErrTypeError
	}
	_dcbbe.Decode = _babaef
	if _acbef := _bggfd.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e"); _acbef != nil {
		_dcbbe.Function = []PdfFunction{}
		if _baedf, _aaffa := _acbef.(*_fed.PdfObjectArray); _aaffa {
			for _, _gdfdf := range _baedf.Elements() {
				_gbacc, _gdffa := _bggad(_gdfdf)
				if _gdffa != nil {
					_fef.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _gdffa)
					return nil, _gdffa
				}
				_dcbbe.Function = append(_dcbbe.Function, _gbacc)
			}
		} else {
			_cfaeb, _gaeff := _bggad(_acbef)
			if _gaeff != nil {
				_fef.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _gaeff)
				return nil, _gaeff
			}
			_dcbbe.Function = append(_dcbbe.Function, _cfaeb)
		}
	}
	return &_dcbbe, nil
}
func _fcegc(_bcda *[]*PdfField, _aebad FieldFilterFunc, _dcee bool) []*PdfField {
	if _bcda == nil {
		return nil
	}
	_aabf := *_bcda
	if len(*_bcda) == 0 {
		return nil
	}
	_fgeg := _aabf[:0]
	if _aebad == nil {
		_aebad = func(*PdfField) bool { return true }
	}
	var _gffa []*PdfField
	for _, _fadac := range _aabf {
		_cgded := _aebad(_fadac)
		if _cgded {
			_gffa = append(_gffa, _fadac)
			if len(_fadac.Kids) > 0 {
				_gffa = append(_gffa, _fcegc(&_fadac.Kids, _aebad, _dcee)...)
			}
		}
		if !_dcee || !_cgded || len(_fadac.Kids) > 0 {
			_fgeg = append(_fgeg, _fadac)
		}
	}
	*_bcda = _fgeg
	return _gffa
}
func _eaeac(_bdce *_fed.PdfObjectDictionary) (*PdfFieldChoice, error) {
	_abbf := &PdfFieldChoice{}
	_abbf.Opt, _ = _fed.GetArray(_bdce.Get("\u004f\u0070\u0074"))
	_abbf.TI, _ = _fed.GetInt(_bdce.Get("\u0054\u0049"))
	_abbf.I, _ = _fed.GetArray(_bdce.Get("\u0049"))
	return _abbf, nil
}

// SignatureValidationResult defines the response from the signature validation handler.
type SignatureValidationResult struct {

	// List of errors when validating the signature.
	Errors      []string
	IsSigned    bool
	IsVerified  bool
	IsTrusted   bool
	Fields      []*PdfField
	Name        string
	Date        PdfDate
	Reason      string
	Location    string
	ContactInfo string

	// GeneralizedTime is the time at which the time-stamp token has been created by the TSA (RFC 3161).
	GeneralizedTime _e.Time
}

func (_ddce *PdfReader) newPdfAnnotationPolygonFromDict(_dddf *_fed.PdfObjectDictionary) (*PdfAnnotationPolygon, error) {
	_afgg := PdfAnnotationPolygon{}
	_cfeg, _afcf := _ddce.newPdfAnnotationMarkupFromDict(_dddf)
	if _afcf != nil {
		return nil, _afcf
	}
	_afgg.PdfAnnotationMarkup = _cfeg
	_afgg.Vertices = _dddf.Get("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073")
	_afgg.LE = _dddf.Get("\u004c\u0045")
	_afgg.BS = _dddf.Get("\u0042\u0053")
	_afgg.IC = _dddf.Get("\u0049\u0043")
	_afgg.BE = _dddf.Get("\u0042\u0045")
	_afgg.IT = _dddf.Get("\u0049\u0054")
	_afgg.Measure = _dddf.Get("\u004de\u0061\u0073\u0075\u0072\u0065")
	return &_afgg, nil
}
func (_gbgg *DSS) generateHashMaps() error {
	_gegbb, _adcgf := _gbgg.generateHashMap(_gbgg.Certs)
	if _adcgf != nil {
		return _adcgf
	}
	_bcae, _adcgf := _gbgg.generateHashMap(_gbgg.OCSPs)
	if _adcgf != nil {
		return _adcgf
	}
	_abece, _adcgf := _gbgg.generateHashMap(_gbgg.CRLs)
	if _adcgf != nil {
		return _adcgf
	}
	_gbgg._ffga = _gegbb
	_gbgg._bece = _bcae
	_gbgg._eeag = _abece
	return nil
}

// CharcodesToStrings returns the unicode strings corresponding to `charcodes`.
// The int returns are the number of strings and the number of unconvereted codes.
// NOTE: The number of strings returned is equal to the number of charcodes
func (_fafb *PdfFont) CharcodesToStrings(charcodes []_dg.CharCode) ([]string, int, int) {
	_abge := _fafb.baseFields()
	_dfaea := make([]string, 0, len(charcodes))
	_fdbgd := 0
	_efede := _fafb.Encoder()
	if _efede != nil {
		switch _abbff := _efede.(type) {
		case _dg.SimpleEncoder:
			_fade := _abbff.BaseName()
			if _, _gcag := _edfa[_fade]; _gcag {
				for _, _gdff := range charcodes {
					if _cegd, _dgcc := _efede.CharcodeToRune(_gdff); _dgcc {
						_dfaea = append(_dfaea, string(_cegd))
					} else {
						_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004e\u006f\u0020\u0072u\u006e\u0065\u002e\u0020\u0063\u006f\u0064\u0065=\u0030x\u0025\u0030\u0034\u0078\u0020\u0063\u0068\u0061\u0072\u0063\u006f\u0064\u0065\u0073\u003d\u005b\u0025\u00200\u0034\u0078\u005d\u0020\u0043\u0049\u0044\u003d\u0025\u0074\u000a"+"\t\u0066\u006f\u006e\u0074=%\u0073\n\u0009\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003d\u0025\u0073", _gdff, charcodes, _abge.isCIDFont(), _fafb, _efede)
						_fdbgd++
						_dfaea = append(_dfaea, _edf.MissingCodeString)
					}
				}
				return _dfaea, len(_dfaea), _fdbgd
			}
		}
	}
	for _, _fbbd := range charcodes {
		if _abge._ecfd != nil {
			if _dade, _agaa := _abge._ecfd.CharcodeToUnicode(_edf.CharCode(_fbbd)); _agaa {
				_dfaea = append(_dfaea, _dade)
				continue
			}
		}
		if _efede != nil {
			if _efae, _edfe := _efede.CharcodeToRune(_fbbd); _edfe {
				_dfaea = append(_dfaea, string(_efae))
				continue
			}
		}
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004e\u006f\u0020\u0072u\u006e\u0065\u002e\u0020\u0063\u006f\u0064\u0065=\u0030x\u0025\u0030\u0034\u0078\u0020\u0063\u0068\u0061\u0072\u0063\u006f\u0064\u0065\u0073\u003d\u005b\u0025\u00200\u0034\u0078\u005d\u0020\u0043\u0049\u0044\u003d\u0025\u0074\u000a"+"\t\u0066\u006f\u006e\u0074=%\u0073\n\u0009\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003d\u0025\u0073", _fbbd, charcodes, _abge.isCIDFont(), _fafb, _efede)
		_fdbgd++
		_dfaea = append(_dfaea, _edf.MissingCodeString)
	}
	if _fdbgd != 0 {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0043\u006f\u0075\u006c\u0064\u006e\u0027\u0074\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0074\u006f\u0020u\u006e\u0069\u0063\u006f\u0064\u0065\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020i\u006ep\u0075\u0074\u002e\u000a"+"\u0009\u006e\u0075\u006d\u0043\u0068\u0061\u0072\u0073\u003d\u0025d\u0020\u006e\u0075\u006d\u004d\u0069\u0073\u0073\u0065\u0073=\u0025\u0064\u000a"+"\u0009\u0066\u006f\u006e\u0074\u003d\u0025\u0073", len(charcodes), _fdbgd, _fafb)
	}
	return _dfaea, len(_dfaea), _fdbgd
}
func (_gbdg *PdfFont) baseFields() *fontCommon {
	if _gbdg._gdaa == nil {
		_fef.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0062\u0061\u0073\u0065\u0046\u0069\u0065l\u0064s\u002e \u0063o\u006e\u0074\u0065\u0078\u0074\u0020\u0069\u0073\u0020\u006e\u0069\u006c\u002e")
		return nil
	}
	return _gbdg._gdaa.baseFields()
}

// GetCapHeight returns the CapHeight of the font `descriptor`.
func (_gbed *PdfFontDescriptor) GetCapHeight() (float64, error) {
	return _fed.GetNumberAsFloat(_gbed.CapHeight)
}

// PdfAnnotationRedact represents Redact annotations.
// (Section 12.5.6.23).
type PdfAnnotationRedact struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	QuadPoints  _fed.PdfObject
	IC          _fed.PdfObject
	RO          _fed.PdfObject
	OverlayText _fed.PdfObject
	Repeat      _fed.PdfObject
	DA          _fed.PdfObject
	Q           _fed.PdfObject
}

// NewPdfFilespecFromObj creates and returns a new PdfFilespec object.
func NewPdfFilespecFromObj(obj _fed.PdfObject) (*PdfFilespec, error) {
	_gggg := &PdfFilespec{}
	var _cdaf *_fed.PdfObjectDictionary
	if _cgaad, _dccgd := _fed.GetIndirect(obj); _dccgd {
		_gggg._dfeff = _cgaad
		_gged, _abgbc := _fed.GetDict(_cgaad.PdfObject)
		if !_abgbc {
			_fef.Log.Debug("\u004f\u0062\u006a\u0065c\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069c\u0074i\u006f\u006e\u0061\u0072\u0079\u0020\u0074y\u0070\u0065")
			return nil, _fed.ErrTypeError
		}
		_cdaf = _gged
	} else if _dec, _ebgd := _fed.GetDict(obj); _ebgd {
		_gggg._dfeff = _dec
		_cdaf = _dec
	} else {
		_fef.Log.Debug("O\u0062\u006a\u0065\u0063\u0074\u0020t\u0079\u0070\u0065\u0020\u0075\u006e\u0065\u0078\u0070e\u0063\u0074\u0065d\u0020(\u0025\u0054\u0029", obj)
		return nil, _fed.ErrTypeError
	}
	if _cdaf == nil {
		_fef.Log.Debug("\u0044i\u0063t\u0069\u006f\u006e\u0061\u0072y\u0020\u006di\u0073\u0073\u0069\u006e\u0067")
		return nil, _bb.New("\u0064\u0069\u0063t\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
	}
	if _fbdae := _cdaf.Get("\u0054\u0079\u0070\u0065"); _fbdae != nil {
		_gceb, _dafb := _fbdae.(*_fed.PdfObjectName)
		if !_dafb {
			_fef.Log.Trace("\u0049\u006e\u0063\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069\u0074\u0079\u0021\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0054\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064 \u0062\u0065\u0020\u004e\u0061m\u0065", _fbdae)
		} else {
			if *_gceb != "\u0046\u0069\u006c\u0065\u0073\u0070\u0065\u0063" {
				_fef.Log.Trace("\u0055\u006e\u0073\u0075\u0073\u0070e\u0063\u0074\u0065\u0064\u0020\u0054\u0079\u0070\u0065\u0020\u0021\u003d\u0020F\u0069\u006c\u0065\u0073\u0070\u0065\u0063 \u0028\u0025\u0073\u0029", *_gceb)
			}
		}
	}
	if _acedc := _cdaf.Get("\u0046\u0053"); _acedc != nil {
		_gggg.FS = _acedc
	}
	if _gecf := _cdaf.Get("\u0046"); _gecf != nil {
		_gggg.F = _gecf
	}
	if _adadg := _cdaf.Get("\u0055\u0046"); _adadg != nil {
		_gggg.UF = _adadg
	}
	if _bege := _cdaf.Get("\u0044\u004f\u0053"); _bege != nil {
		_gggg.DOS = _bege
	}
	if _acdd := _cdaf.Get("\u004d\u0061\u0063"); _acdd != nil {
		_gggg.Mac = _acdd
	}
	if _ddcef := _cdaf.Get("\u0055\u006e\u0069\u0078"); _ddcef != nil {
		_gggg.Unix = _ddcef
	}
	if _fbbb := _cdaf.Get("\u0049\u0044"); _fbbb != nil {
		_gggg.ID = _fbbb
	}
	if _fcdc := _cdaf.Get("\u0056"); _fcdc != nil {
		_gggg.V = _fcdc
	}
	if _dcfa := _cdaf.Get("\u0045\u0046"); _dcfa != nil {
		_gggg.EF = _dcfa
	}
	if _fbfd := _cdaf.Get("\u0052\u0046"); _fbfd != nil {
		_gggg.RF = _fbfd
	}
	if _eaeb := _cdaf.Get("\u0044\u0065\u0073\u0063"); _eaeb != nil {
		_gggg.Desc = _eaeb
	}
	if _egaf := _cdaf.Get("\u0043\u0049"); _egaf != nil {
		_gggg.CI = _egaf
	}
	return _gggg, nil
}

// SubsetRegistered subsets the font to only the glyphs that have been registered by the encoder.
// NOTE: This only works on fonts that support subsetting. For unsupported fonts this is a no-op, although a debug
//   message is emitted.  Currently supported fonts are embedded Truetype CID fonts (type 0).
// NOTE: Make sure to call this soon before writing (once all needed runes have been registered).
// If using package creator, use its EnableFontSubsetting method instead.
func (_dfaef *PdfFont) SubsetRegistered() error {
	switch _aegab := _dfaef._gdaa.(type) {
	case *pdfFontType0:
		_daeeg := _aegab.subsetRegistered()
		if _daeeg != nil {
			_fef.Log.Debug("\u0053\u0075b\u0073\u0065\u0074 \u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076", _daeeg)
			return _daeeg
		}
		if _aegab._deadb != nil {
			if _aegab._eeabd != nil {
				_aegab._eeabd.ToPdfObject()
			}
			_aegab.ToPdfObject()
		}
	default:
		_fef.Log.Debug("F\u006f\u006e\u0074\u0020\u0025\u0054 \u0064\u006f\u0065\u0073\u0020\u006eo\u0074\u0020\u0073\u0075\u0070\u0070\u006fr\u0074\u0020\u0073\u0075\u0062\u0073\u0065\u0074\u0074\u0069n\u0067", _aegab)
	}
	return nil
}

// NewPdfActionMovie returns a new "movie" action.
func NewPdfActionMovie() *PdfActionMovie {
	_eeda := NewPdfAction()
	_fcb := &PdfActionMovie{}
	_fcb.PdfAction = _eeda
	_eeda.SetContext(_fcb)
	return _fcb
}
func (_bec *PdfAppender) updateObjectsDeep(_ecb _fed.PdfObject, _cffg map[_fed.PdfObject]struct{}) {
	if _cffg == nil {
		_cffg = map[_fed.PdfObject]struct{}{}
	}
	if _, _bddb := _cffg[_ecb]; _bddb || _ecb == nil {
		return
	}
	_cffg[_ecb] = struct{}{}
	_ccgff := _fed.ResolveReferencesDeep(_ecb, _bec._aded)
	if _ccgff != nil {
		_fef.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _ccgff)
	}
	switch _daa := _ecb.(type) {
	case *_fed.PdfIndirectObject:
		switch {
		case _daa.GetParser() == _bec._ccc._cdfggf:
			return
		case _daa.GetParser() == _bec.Reader._cdfggf:
			_eegb, _ := _bec._ccc.GetIndirectObjectByNumber(int(_daa.ObjectNumber))
			_gdc, _fbdc := _eegb.(*_fed.PdfIndirectObject)
			if _fbdc && _gdc != nil {
				if _gdc.PdfObject != _daa.PdfObject && _gdc.PdfObject.WriteString() != _daa.PdfObject.WriteString() {
					_bec.addNewObject(_ecb)
					_bec._aebf[_ecb] = _daa.ObjectNumber
				}
			}
		default:
			_bec.addNewObject(_ecb)
		}
		_bec.updateObjectsDeep(_daa.PdfObject, _cffg)
	case *_fed.PdfObjectArray:
		for _, _acga := range _daa.Elements() {
			_bec.updateObjectsDeep(_acga, _cffg)
		}
	case *_fed.PdfObjectDictionary:
		for _, _daga := range _daa.Keys() {
			_bec.updateObjectsDeep(_daa.Get(_daga), _cffg)
		}
	case *_fed.PdfObjectStreams:
		if _daa.GetParser() != _bec._ccc._cdfggf {
			for _, _bgbce := range _daa.Elements() {
				_bec.updateObjectsDeep(_bgbce, _cffg)
			}
		}
	case *_fed.PdfObjectStream:
		switch {
		case _daa.GetParser() == _bec._ccc._cdfggf:
			return
		case _daa.GetParser() == _bec.Reader._cdfggf:
			if _aage, _agad := _bec._ccc._cdfggf.LookupByReference(_daa.PdfObjectReference); _agad == nil {
				var _dbbc bool
				if _eaaf, _acfb := _fed.GetStream(_aage); _acfb && _eb.Equal(_eaaf.Stream, _daa.Stream) {
					_dbbc = true
				}
				if _ddbb, _caaa := _fed.GetDict(_aage); _dbbc && _caaa {
					_dbbc = _ddbb.WriteString() == _daa.PdfObjectDictionary.WriteString()
				}
				if _dbbc {
					return
				}
			}
			if _daa.ObjectNumber != 0 {
				_bec._aebf[_ecb] = _daa.ObjectNumber
			}
		default:
			if _, _gbcb := _bec._bcgf[_ecb]; !_gbcb {
				_bec.addNewObject(_ecb)
			}
		}
		_bec.updateObjectsDeep(_daa.PdfObjectDictionary, _cffg)
	}
}
func (_deba *pdfFontSimple) getFontEncoding() (_adbaf string, _cafd map[_dg.CharCode]_dg.GlyphName, _egegc error) {
	_adbaf = "\u0053\u0074a\u006e\u0064\u0061r\u0064\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067"
	if _geeg, _fedag := _dbafd[_deba._daac]; _fedag {
		_adbaf = _geeg
	} else if _deba.fontFlags()&_dcad != 0 {
		for _agefg, _afbff := range _dbafd {
			if _eed.Contains(_deba._daac, _agefg) {
				_adbaf = _afbff
				break
			}
		}
	}
	if _deba.Encoding == nil {
		return _adbaf, nil, nil
	}
	switch _gbdc := _deba.Encoding.(type) {
	case *_fed.PdfObjectName:
		return string(*_gbdc), nil, nil
	case *_fed.PdfObjectDictionary:
		_cgca, _cdbaa := _fed.GetName(_gbdc.Get("\u0042\u0061\u0073e\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067"))
		if _cdbaa {
			_adbaf = _cgca.String()
		}
		if _decg := _gbdc.Get("D\u0069\u0066\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0073"); _decg != nil {
			_dgebf, _gabc := _fed.GetArray(_decg)
			if !_gabc {
				_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0042a\u0064\u0020\u0066on\u0074\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u003d\u0025\u002b\u0076\u0020\u0044\u0069f\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0073=\u0025\u0054", _gbdc, _gbdc.Get("D\u0069\u0066\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0073"))
				return "", nil, _fed.ErrTypeError
			}
			_cafd, _egegc = _dg.FromFontDifferences(_dgebf)
		}
		return _adbaf, _cafd, _egegc
	default:
		_fef.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0061\u006d\u0065\u0020\u006f\u0072\u0020\u0064\u0069\u0063t\u0020\u0028\u0025\u0054\u0029\u0020\u0025\u0073", _deba.Encoding, _deba.Encoding)
		return "", nil, _fed.ErrTypeError
	}
}

// XObjectForm (Table 95 in 8.10.2).
type XObjectForm struct {
	Filter        _fed.StreamEncoder
	FormType      _fed.PdfObject
	BBox          _fed.PdfObject
	Matrix        _fed.PdfObject
	Resources     *PdfPageResources
	Group         _fed.PdfObject
	Ref           _fed.PdfObject
	MetaData      _fed.PdfObject
	PieceInfo     _fed.PdfObject
	LastModified  _fed.PdfObject
	StructParent  _fed.PdfObject
	StructParents _fed.PdfObject
	OPI           _fed.PdfObject
	OC            _fed.PdfObject
	Name          _fed.PdfObject

	// Stream data.
	Stream []byte
	_cedfc *_fed.PdfObjectStream
}

// SetForms sets the Acroform for a PDF file.
func (_fceag *PdfWriter) SetForms(form *PdfAcroForm) error { _fceag._cccab = form; return nil }

// NewPdfAnnotationTrapNet returns a new trapnet annotation.
func NewPdfAnnotationTrapNet() *PdfAnnotationTrapNet {
	_dgea := NewPdfAnnotation()
	_ddb := &PdfAnnotationTrapNet{}
	_ddb.PdfAnnotation = _dgea
	_dgea.SetContext(_ddb)
	return _ddb
}
func (_dedc *PdfReader) newPdfAnnotationCircleFromDict(_eece *_fed.PdfObjectDictionary) (*PdfAnnotationCircle, error) {
	_fbda := PdfAnnotationCircle{}
	_gfa, _cdba := _dedc.newPdfAnnotationMarkupFromDict(_eece)
	if _cdba != nil {
		return nil, _cdba
	}
	_fbda.PdfAnnotationMarkup = _gfa
	_fbda.BS = _eece.Get("\u0042\u0053")
	_fbda.IC = _eece.Get("\u0049\u0043")
	_fbda.BE = _eece.Get("\u0042\u0045")
	_fbda.RD = _eece.Get("\u0052\u0044")
	return &_fbda, nil
}

// ToPdfObject implements interface PdfModel.
func (_aabg *PdfAnnotationPopup) ToPdfObject() _fed.PdfObject {
	_aabg.PdfAnnotation.ToPdfObject()
	_dcd := _aabg._ffaab
	_cfee := _dcd.PdfObject.(*_fed.PdfObjectDictionary)
	_cfee.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u0050\u006f\u0070u\u0070"))
	_cfee.SetIfNotNil("\u0050\u0061\u0072\u0065\u006e\u0074", _aabg.Parent)
	_cfee.SetIfNotNil("\u004f\u0070\u0065\u006e", _aabg.Open)
	return _dcd
}

// NewPdfAnnotationCaret returns a new caret annotation.
func NewPdfAnnotationCaret() *PdfAnnotationCaret {
	_fge := NewPdfAnnotation()
	_ffaabg := &PdfAnnotationCaret{}
	_ffaabg.PdfAnnotation = _fge
	_ffaabg.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_fge.SetContext(_ffaabg)
	return _ffaabg
}

// EnableByName LTV enables the signature dictionary of the PDF AcroForm
// field identified the specified name. The signing certificate chain is
// extracted from the signature dictionary. Optionally, additional certificates
// can be specified through the `extraCerts` parameter. The LTV client attempts
// to build the certificate chain up to a trusted root by downloading any
// missing certificates.
func (_fcgc *LTV) EnableByName(name string, extraCerts []*_fe.Certificate) error {
	_faaae := _fcgc._cgbeg._ccc.AcroForm
	for _, _bfgd := range _faaae.AllFields() {
		_fdfgc, _ := _bfgd.GetContext().(*PdfFieldSignature)
		if _fdfgc == nil {
			continue
		}
		if _abddf := _fdfgc.PartialName(); _abddf != name {
			continue
		}
		return _fcgc.Enable(_fdfgc.V, extraCerts)
	}
	return nil
}

// GetContentStream returns the pattern cell's content stream
func (_bddec *PdfTilingPattern) GetContentStream() ([]byte, error) {
	_agbc, _, _adfag := _bddec.GetContentStreamWithEncoder()
	return _agbc, _adfag
}
func _ccegb(_badcf *_fed.PdfObjectArray) (float64, error) {
	_cabcb, _cdefc := _badcf.ToFloat64Array()
	if _cdefc != nil {
		_fef.Log.Debug("\u0042\u0061\u0064\u0020\u004d\u0061\u0074\u0074\u0065\u0020\u0061\u0072\u0072\u0061\u0079:\u0020m\u0061\u0074\u0074\u0065\u003d\u0025\u0073\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _badcf, _cdefc)
	}
	switch len(_cabcb) {
	case 1:
		return _cabcb[0], nil
	case 3:
		_cgdbc := PdfColorspaceDeviceRGB{}
		_cbdcf, _cagfc := _cgdbc.ColorFromFloats(_cabcb)
		if _cagfc != nil {
			return 0.0, _cagfc
		}
		return _cbdcf.(*PdfColorDeviceRGB).ToGray().Val(), nil
	case 4:
		_aafda := PdfColorspaceDeviceCMYK{}
		_dcgacc, _dgbab := _aafda.ColorFromFloats(_cabcb)
		if _dgbab != nil {
			return 0.0, _dgbab
		}
		_facd, _dgbab := _aafda.ColorToRGB(_dcgacc.(*PdfColorDeviceCMYK))
		if _dgbab != nil {
			return 0.0, _dgbab
		}
		return _facd.(*PdfColorDeviceRGB).ToGray().Val(), nil
	}
	_cdefc = _bb.New("\u0062a\u0064 \u004d\u0061\u0074\u0074\u0065\u0020\u0063\u006f\u006c\u006f\u0072")
	_fef.Log.Error("\u0074\u006f\u0047ra\u0079\u003a\u0020\u006d\u0061\u0074\u0074\u0065\u003d\u0025\u0073\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _badcf, _cdefc)
	return 0.0, _cdefc
}

// GetNameDictionary returns the Names entry in the PDF catalog.
// See section 7.7.4 "Name Dictionary" (p. 80 PDF32000_2008).
func (_ccabc *PdfReader) GetNameDictionary() (_fed.PdfObject, error) {
	_ggaeg := _fed.ResolveReference(_ccabc._bfcdc.Get("\u004e\u0061\u006de\u0073"))
	if _ggaeg == nil {
		return nil, nil
	}
	if !_ccabc._bgbff {
		_ffeac := _ccabc.traverseObjectData(_ggaeg)
		if _ffeac != nil {
			return nil, _ffeac
		}
	}
	return _ggaeg, nil
}

// NewCompositePdfFontFromTTFFile loads a composite font from a TTF font file. Composite fonts can
// be used to represent unicode fonts which can have multi-byte character codes, representing a wide
// range of values. They are often used for symbolic languages, including Chinese, Japanese and Korean.
// It is represented by a Type0 Font with an underlying CIDFontType2 and an Identity-H encoding map.
// TODO: May be extended in the future to support a larger variety of CMaps and vertical fonts.
// NOTE: For simple fonts, use NewPdfFontFromTTFFile.
func NewCompositePdfFontFromTTFFile(filePath string) (*PdfFont, error) {
	_bfebf, _baaeb := _da.Open(filePath)
	if _baaeb != nil {
		_fef.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u006f\u0070\u0065\u006e\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0076", _baaeb)
		return nil, _baaeb
	}
	defer _bfebf.Close()
	return NewCompositePdfFontFromTTF(_bfebf)
}
func (_cedgc *PdfReader) flattenFieldsWithOpts(_abggf bool, _fcffd FieldAppearanceGenerator, _aeada *FieldFlattenOpts) error {
	if _aeada == nil {
		_aeada = &FieldFlattenOpts{}
	}
	var _dbba bool
	_dbeg := map[*PdfAnnotation]bool{}
	{
		var _bdff []*PdfField
		_adbef := _cedgc.AcroForm
		if _adbef != nil {
			if _aeada.FilterFunc != nil {
				_bdff = _adbef.filteredFields(_aeada.FilterFunc, true)
				_dbba = _adbef.Fields != nil && len(*_adbef.Fields) > 0
			} else {
				_bdff = _adbef.AllFields()
			}
		}
		for _, _eecd := range _bdff {
			for _, _acgab := range _eecd.Annotations {
				_dbeg[_acgab.PdfAnnotation] = _eecd.V != nil
				if _fcffd != nil {
					_cgaaa, _cfde := _fcffd.GenerateAppearanceDict(_adbef, _eecd, _acgab)
					if _cfde != nil {
						return _cfde
					}
					_acgab.AP = _cgaaa
				}
			}
		}
	}
	if _abggf {
		for _, _agge := range _cedgc.PageList {
			_aadc, _gdfbg := _agge.GetAnnotations()
			if _gdfbg != nil {
				return _gdfbg
			}
			for _, _afggf := range _aadc {
				_dbeg[_afggf] = true
			}
		}
	}
	for _, _bgea := range _cedgc.PageList {
		var _ebbf []*PdfAnnotation
		if _fcffd != nil {
			if _fadaf := _fcffd.WrapContentStream(_bgea); _fadaf != nil {
				return _fadaf
			}
		}
		_ecbd, _eggf := _bgea.GetAnnotations()
		if _eggf != nil {
			return _eggf
		}
		for _, _dgad := range _ecbd {
			_gdgea, _ebac := _dbeg[_dgad]
			if !_ebac && _aeada.AnnotFilterFunc != nil {
				if _, _ebdag := _dgad.GetContext().(*PdfAnnotationWidget); !_ebdag {
					_ebac = _aeada.AnnotFilterFunc(_dgad)
				}
			}
			if !_ebac {
				_ebbf = append(_ebbf, _dgad)
				continue
			}
			switch _dgad.GetContext().(type) {
			case *PdfAnnotationPopup:
				continue
			case *PdfAnnotationLink:
				continue
			case *PdfAnnotationProjection:
				continue
			}
			_daeba, _eebe, _cbde := _bbed(_dgad)
			if _cbde != nil {
				if !_gdgea {
					_fef.Log.Trace("\u0046\u0069\u0065\u006c\u0064\u0020\u0077\u0069\u0074h\u006f\u0075\u0074\u0020\u0056\u0020\u002d\u003e\u0020\u0061\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0077\u0069\u0074h\u006f\u0075t\u0020\u0061p\u0070\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0020\u0073\u0074\u0072\u0065am\u0020\u002d\u0020\u0073\u006b\u0069\u0070\u0070\u0069n\u0067\u0020\u006f\u0076\u0065\u0072")
					continue
				}
				_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u0020\u0041\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0077\u0069\u0074h\u006f\u0075\u0074\u0020\u0061\u0070\u0070\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d,\u0020\u0065\u0072\u0072\u0020\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0073\u006bi\u0070\u0070\u0069n\u0067\u0020\u006f\u0076\u0065\u0072", _cbde)
				continue
			}
			if _daeba == nil {
				continue
			}
			_effee := _bgea.Resources.GenerateXObjectName()
			_bgea.Resources.SetXObjectFormByName(_effee, _daeba)
			_eecgg := _bg.Min(_eebe.Llx, _eebe.Urx)
			_bced := _bg.Min(_eebe.Lly, _eebe.Ury)
			var _ggadd []string
			_ggadd = append(_ggadd, "\u0071")
			_ggadd = append(_ggadd, _d.Sprintf("\u0025\u002e\u0036\u0066\u0020\u0025\u002e\u0036\u0066\u0020\u0025\u002e\u0036\u0066\u0020%\u002e6\u0066\u0020\u0025\u002e\u0036\u0066\u0020\u0025\u002e\u0036\u0066\u0020\u0063\u006d", 1.0, 0.0, 0.0, 1.0, _eecgg, _bced))
			_ggadd = append(_ggadd, _d.Sprintf("\u002f\u0025\u0073\u0020\u0044\u006f", _effee.String()))
			_ggadd = append(_ggadd, "\u0051")
			_gadcg := _eed.Join(_ggadd, "\u000a")
			_cbde = _bgea.AppendContentStream(_gadcg)
			if _cbde != nil {
				return _cbde
			}
			if _daeba.Resources != nil {
				_bdfe, _ccea := _fed.GetDict(_daeba.Resources.Font)
				if _ccea {
					for _, _dgce := range _bdfe.Keys() {
						if !_bgea.Resources.HasFontByName(_dgce) {
							_bgea.Resources.SetFontByName(_dgce, _bdfe.Get(_dgce))
						}
					}
				}
			}
		}
		if len(_ebbf) > 0 {
			_bgea._abcb = _ebbf
		} else {
			_bgea._abcb = []*PdfAnnotation{}
		}
	}
	if !_dbba {
		_cedgc.AcroForm = nil
	}
	return nil
}

// GetNumComponents returns the number of color components of the colorspace device.
// Returns 1 for a CalGray device.
func (_dddfa *PdfColorspaceCalGray) GetNumComponents() int { return 1 }

// ConvertToBinary converts current image into binary (bi-level) format.
// Binary images are composed of single bits per pixel (only black or white).
// If provided image has more color components, then it would be converted into binary image using
// histogram auto threshold function.
func (_ffaaa *Image) ConvertToBinary() error {
	if _ffaaa.ColorComponents == 1 && _ffaaa.BitsPerComponent == 1 {
		return nil
	}
	_gffcbc, _gbgad := _ffaaa.ToGoImage()
	if _gbgad != nil {
		return _gbgad
	}
	_accac, _gbgad := _eede.MonochromeConverter.Convert(_gffcbc)
	if _gbgad != nil {
		return _gbgad
	}
	_ffaaa.Data = _accac.Base().Data
	_ffaaa._caeaf, _gbgad = _eede.ScaleAlphaToMonochrome(_ffaaa._caeaf, int(_ffaaa.Width), int(_ffaaa.Height))
	if _gbgad != nil {
		return _gbgad
	}
	_ffaaa.BitsPerComponent = 1
	_ffaaa.ColorComponents = 1
	_ffaaa._ccdge = nil
	return nil
}

// GetNumComponents returns the number of color components of the underlying
// colorspace device.
func (_gdfd *PdfColorspaceSpecialPattern) GetNumComponents() int {
	return _gdfd.UnderlyingCS.GetNumComponents()
}

// NewPdfAnnotationMovie returns a new movie annotation.
func NewPdfAnnotationMovie() *PdfAnnotationMovie {
	_dba := NewPdfAnnotation()
	_bcg := &PdfAnnotationMovie{}
	_bcg.PdfAnnotation = _dba
	_dba.SetContext(_bcg)
	return _bcg
}

// NewPdfColorspaceSpecialIndexed returns a new Indexed color.
func NewPdfColorspaceSpecialIndexed() *PdfColorspaceSpecialIndexed {
	return &PdfColorspaceSpecialIndexed{HiVal: 255}
}

// GetSamples converts the raw byte slice into samples which are stored in a uint32 bit array.
// Each sample is represented by BitsPerComponent consecutive bits in the raw data.
// NOTE: The method resamples the image byte data before returning the result and
// this could lead to high memory usage, especially on large images. It should
// be avoided, when possible. It is recommended to access the Data field of the
// image directly or use the ColorAt method to extract individual pixels.
func (_agcfe *Image) GetSamples() []uint32 {
	_fcfd := _bba.ResampleBytes(_agcfe.Data, int(_agcfe.BitsPerComponent))
	if _agcfe.BitsPerComponent < 8 {
		_fcfd = _agcfe.samplesTrimPadding(_fcfd)
	}
	_dddgg := int(_agcfe.Width) * int(_agcfe.Height) * _agcfe.ColorComponents
	if len(_fcfd) < _dddgg {
		_fef.Log.Debug("\u0045r\u0072\u006fr\u003a\u0020\u0054o\u006f\u0020\u0066\u0065\u0077\u0020\u0073a\u006d\u0070\u006c\u0065\u0073\u0020(\u0067\u006f\u0074\u0020\u0025\u0064\u002c\u0020\u0065\u0078\u0070e\u0063\u0074\u0069\u006e\u0067\u0020\u0025\u0064\u0029", len(_fcfd), _dddgg)
		return _fcfd
	} else if len(_fcfd) > _dddgg {
		_fef.Log.Debug("\u0045r\u0072\u006fr\u003a\u0020\u0054o\u006f\u0020\u006d\u0061\u006e\u0079\u0020s\u0061\u006d\u0070\u006c\u0065\u0073 \u0028\u0067\u006f\u0074\u0020\u0025\u0064\u002c\u0020\u0065\u0078p\u0065\u0063\u0074\u0069\u006e\u0067\u0020\u0025\u0064", len(_fcfd), _dddgg)
		_fcfd = _fcfd[:_dddgg]
	}
	return _fcfd
}
func _gccda() _e.Time { _abadca.Lock(); defer _abadca.Unlock(); return _facfe }

// String returns the name of the colorspace (DeviceN).
func (_fbgc *PdfColorspaceDeviceN) String() string { return "\u0044e\u0076\u0069\u0063\u0065\u004e" }

// ToPdfObject returns colorspace in a PDF object format [name dictionary]
func (_cdbb *PdfColorspaceLab) ToPdfObject() _fed.PdfObject {
	_beg := _fed.MakeArray()
	_beg.Append(_fed.MakeName("\u004c\u0061\u0062"))
	_geef := _fed.MakeDict()
	if _cdbb.WhitePoint != nil {
		_geceb := _fed.MakeArray(_fed.MakeFloat(_cdbb.WhitePoint[0]), _fed.MakeFloat(_cdbb.WhitePoint[1]), _fed.MakeFloat(_cdbb.WhitePoint[2]))
		_geef.Set("\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074", _geceb)
	} else {
		_fef.Log.Error("\u004c\u0061\u0062: \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0057h\u0069t\u0065P\u006fi\u006e\u0074\u0020\u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029")
	}
	if _cdbb.BlackPoint != nil {
		_bgbca := _fed.MakeArray(_fed.MakeFloat(_cdbb.BlackPoint[0]), _fed.MakeFloat(_cdbb.BlackPoint[1]), _fed.MakeFloat(_cdbb.BlackPoint[2]))
		_geef.Set("\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074", _bgbca)
	}
	if _cdbb.Range != nil {
		_fdff := _fed.MakeArray(_fed.MakeFloat(_cdbb.Range[0]), _fed.MakeFloat(_cdbb.Range[1]), _fed.MakeFloat(_cdbb.Range[2]), _fed.MakeFloat(_cdbb.Range[3]))
		_geef.Set("\u0052\u0061\u006eg\u0065", _fdff)
	}
	_beg.Append(_geef)
	if _cdbb._dfbd != nil {
		_cdbb._dfbd.PdfObject = _beg
		return _cdbb._dfbd
	}
	return _beg
}

var _ pdfFont = (*pdfFontType0)(nil)

// PdfAnnotationStrikeOut represents StrikeOut annotations.
// (Section 12.5.6.10).
type PdfAnnotationStrikeOut struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	QuadPoints _fed.PdfObject
}

// NewPdfColorspaceSpecialPattern returns a new pattern color.
func NewPdfColorspaceSpecialPattern() *PdfColorspaceSpecialPattern {
	return &PdfColorspaceSpecialPattern{}
}

// SetDate sets the `M` field of the signature.
func (_bgbbe *PdfSignature) SetDate(date _e.Time, format string) {
	if format == "" {
		format = "\u0044\u003a\u003200\u0036\u0030\u0031\u0030\u0032\u0031\u0035\u0030\u0034\u0030\u0035\u002d\u0030\u0037\u0027\u0030\u0030\u0027"
	}
	_bgbbe.M = _fed.MakeString(date.Format(format))
}

// Fill populates `form` with values provided by `provider`.
func (_effddc *PdfAcroForm) Fill(provider FieldValueProvider) error {
	return _effddc.fill(provider, nil)
}
func (_dafe *PdfReader) newPdfActionThreadFromDict(_bfd *_fed.PdfObjectDictionary) (*PdfActionThread, error) {
	_dfb, _cgd := _eec(_bfd.Get("\u0046"))
	if _cgd != nil {
		return nil, _cgd
	}
	return &PdfActionThread{D: _bfd.Get("\u0044"), B: _bfd.Get("\u0042"), F: _dfb}, nil
}

// AppendContentStream adds content stream by string.  Appends to the last
// contentstream instance if many.
func (_ceaad *PdfPage) AppendContentStream(contentStr string) error {
	_acgaf, _dbbgg := _ceaad.GetContentStreams()
	if _dbbgg != nil {
		return _dbbgg
	}
	if len(_acgaf) == 0 {
		_acgaf = []string{contentStr}
		return _ceaad.SetContentStreams(_acgaf, _fed.NewFlateEncoder())
	}
	var _fgfad _eb.Buffer
	_fgfad.WriteString(_acgaf[len(_acgaf)-1])
	_fgfad.WriteString("\u000a")
	_fgfad.WriteString(contentStr)
	_acgaf[len(_acgaf)-1] = _fgfad.String()
	return _ceaad.SetContentStreams(_acgaf, _fed.NewFlateEncoder())
}
func (_eaea *DSS) addCRLs(_cfca [][]byte) ([]*_fed.PdfObjectStream, error) {
	return _eaea.add(&_eaea.CRLs, _eaea._eeag, _cfca)
}

// PdfFieldButton represents a button field which includes push buttons, checkboxes, and radio buttons.
type PdfFieldButton struct {
	*PdfField
	Opt *_fed.PdfObjectArray
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_bbgcc *PdfShadingType5) ToPdfObject() _fed.PdfObject {
	_bbgcc.PdfShading.ToPdfObject()
	_afad, _ccbbe := _bbgcc.getShadingDict()
	if _ccbbe != nil {
		_fef.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _bbgcc.BitsPerCoordinate != nil {
		_afad.Set("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065", _bbgcc.BitsPerCoordinate)
	}
	if _bbgcc.BitsPerComponent != nil {
		_afad.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _bbgcc.BitsPerComponent)
	}
	if _bbgcc.VerticesPerRow != nil {
		_afad.Set("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073\u0050e\u0072\u0052\u006f\u0077", _bbgcc.VerticesPerRow)
	}
	if _bbgcc.Decode != nil {
		_afad.Set("\u0044\u0065\u0063\u006f\u0064\u0065", _bbgcc.Decode)
	}
	if _bbgcc.Function != nil {
		if len(_bbgcc.Function) == 1 {
			_afad.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _bbgcc.Function[0].ToPdfObject())
		} else {
			_caeec := _fed.MakeArray()
			for _, _egebb := range _bbgcc.Function {
				_caeec.Append(_egebb.ToPdfObject())
			}
			_afad.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _caeec)
		}
	}
	return _bbgcc._cdcge
}

// PdfAnnotationPolyLine represents PolyLine annotations.
// (Section 12.5.6.9).
type PdfAnnotationPolyLine struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	Vertices _fed.PdfObject
	LE       _fed.PdfObject
	BS       _fed.PdfObject
	IC       _fed.PdfObject
	BE       _fed.PdfObject
	IT       _fed.PdfObject
	Measure  _fed.PdfObject
}

// GetPdfInfo returns the PDF info dictionary.
func (_fdce *PdfReader) GetPdfInfo() (*PdfInfo, error) {
	_defgf := PdfInfo{}
	_bcfaf, _egcd := _fdce.GetTrailer()
	if _egcd != nil {
		return nil, _egcd
	}
	var _fecae *_fed.PdfObjectDictionary
	_gbdcc := _bcfaf.Get("\u0049\u006e\u0066\u006f")
	switch _bfbbc := _gbdcc.(type) {
	case *_fed.PdfObjectReference:
		_egeda := _bfbbc
		_gbdcc, _egcd = _fdce.GetIndirectObjectByNumber(int(_egeda.ObjectNumber))
		_gbdcc = _fed.TraceToDirectObject(_gbdcc)
		if _egcd != nil {
			return nil, _egcd
		}
		_fecae, _ = _gbdcc.(*_fed.PdfObjectDictionary)
	case *_fed.PdfObjectDictionary:
		_fecae = _bfbbc
	}
	if _fecae == nil {
		return nil, _bb.New("I\u006e\u0066\u006f\u0020\u0064\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006eo\u0074\u0020\u0070r\u0065s\u0065\u006e\u0074")
	}
	for _, _bacfa := range _fecae.Keys() {
		switch _bacfa {
		case "\u0054\u0069\u0074l\u0065":
			_defgf.Title, _ = _fed.GetString(_fecae.Get("\u0054\u0069\u0074l\u0065"))
		case "\u0041\u0075\u0074\u0068\u006f\u0072":
			_defgf.Author, _ = _fed.GetString(_fecae.Get("\u0041\u0075\u0074\u0068\u006f\u0072"))
		case "\u0053u\u0062\u006a\u0065\u0063\u0074":
			_defgf.Subject, _ = _fed.GetString(_fecae.Get("\u0053u\u0062\u006a\u0065\u0063\u0074"))
		case "\u004b\u0065\u0079\u0077\u006f\u0072\u0064\u0073":
			_defgf.Keywords, _ = _fed.GetString(_fecae.Get("\u004b\u0065\u0079\u0077\u006f\u0072\u0064\u0073"))
		case "\u0043r\u0065\u0061\u0074\u006f\u0072":
			_defgf.Creator, _ = _fed.GetString(_fecae.Get("\u0043r\u0065\u0061\u0074\u006f\u0072"))
		case "\u0050\u0072\u006f\u0064\u0075\u0063\u0065\u0072":
			_defgf.Producer, _ = _fed.GetString(_fecae.Get("\u0050\u0072\u006f\u0064\u0075\u0063\u0065\u0072"))
		case "\u0054r\u0061\u0070\u0070\u0065\u0064":
			_defgf.Trapped, _ = _fed.GetName(_fecae.Get("\u0054r\u0061\u0070\u0070\u0065\u0064"))
		case "\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065":
			if _gbgef, _cecbd := _fed.GetString(_fecae.Get("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065")); _cecbd && _gbgef.String() != "" {
				_gddeg, _baag := NewPdfDate(_gbgef.String())
				if _baag != nil {
					return nil, _baag
				}
				_defgf.CreationDate = &_gddeg
			}
		case "\u004do\u0064\u0044\u0061\u0074\u0065":
			if _gfgad, _efcdb := _fed.GetString(_fecae.Get("\u004do\u0064\u0044\u0061\u0074\u0065")); _efcdb && _gfgad.String() != "" {
				_bdbe, _badeg := NewPdfDate(_gfgad.String())
				if _badeg != nil {
					return nil, _badeg
				}
				_defgf.ModifiedDate = &_bdbe
			}
		default:
			_dacdf, _ := _fed.GetString(_fecae.Get(_bacfa))
			if _defgf._debc == nil {
				_defgf._debc = _fed.MakeDict()
			}
			_defgf._debc.Set(_bacfa, _dacdf)
		}
	}
	return &_defgf, nil
}

// BaseFont returns the font's "BaseFont" field.
func (_cbgce *PdfFont) BaseFont() string { return _cbgce.baseFields()._daac }

type pdfFont interface {
	_geg.Font

	// ToPdfObject returns a PDF representation of the font and implements interface Model.
	ToPdfObject() _fed.PdfObject
	getFontDescriptor() *PdfFontDescriptor
	baseFields() *fontCommon
}

func (_abe *PdfReader) newPdfAnnotationFileAttachmentFromDict(_fbea *_fed.PdfObjectDictionary) (*PdfAnnotationFileAttachment, error) {
	_dbb := PdfAnnotationFileAttachment{}
	_bfbe, _dede := _abe.newPdfAnnotationMarkupFromDict(_fbea)
	if _dede != nil {
		return nil, _dede
	}
	_dbb.PdfAnnotationMarkup = _bfbe
	_dbb.FS = _fbea.Get("\u0046\u0053")
	_dbb.Name = _fbea.Get("\u004e\u0061\u006d\u0065")
	return &_dbb, nil
}

// SetColorspaceByName adds the provided colorspace to the page resources.
func (_dadgg *PdfPageResources) SetColorspaceByName(keyName _fed.PdfObjectName, cs PdfColorspace) error {
	_bcded, _dbfg := _dadgg.GetColorspaces()
	if _dbfg != nil {
		_fef.Log.Debug("\u0045\u0052R\u004f\u0052\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0072\u0061\u0063\u0065: \u0025\u0076", _dbfg)
		return _dbfg
	}
	if _bcded == nil {
		_bcded = NewPdfPageResourcesColorspaces()
		_dadgg.SetColorSpace(_bcded)
	}
	_bcded.Set(keyName, cs)
	return nil
}

// PdfActionGoTo3DView represents a GoTo3DView action.
type PdfActionGoTo3DView struct {
	*PdfAction
	TA _fed.PdfObject
	V  _fed.PdfObject
}

func (_bef *PdfReader) newPdfAnnotationHighlightFromDict(_age *_fed.PdfObjectDictionary) (*PdfAnnotationHighlight, error) {
	_cffc := PdfAnnotationHighlight{}
	_bcc, _ecfa := _bef.newPdfAnnotationMarkupFromDict(_age)
	if _ecfa != nil {
		return nil, _ecfa
	}
	_cffc.PdfAnnotationMarkup = _bcc
	_cffc.QuadPoints = _age.Get("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073")
	return &_cffc, nil
}

// ColorToRGB converts a Lab color to an RGB color.
func (_gead *PdfColorspaceLab) ColorToRGB(color PdfColor) (PdfColor, error) {
	_cagc := func(_ecffa float64) float64 {
		if _ecffa >= 6.0/29 {
			return _ecffa * _ecffa * _ecffa
		}
		return 108.0 / 841 * (_ecffa - 4/29)
	}
	_baae, _bgcb := color.(*PdfColorLab)
	if !_bgcb {
		_fef.Log.Debug("\u0069\u006e\u0070\u0075t \u0063\u006f\u006c\u006f\u0072\u0020\u006e\u006f\u0074\u0020\u006c\u0061\u0062")
		return nil, _bb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	LStar := _baae.L()
	AStar := _baae.A()
	BStar := _baae.B()
	L := (LStar+16)/116 + AStar/500
	M := (LStar + 16) / 116
	N := (LStar+16)/116 - BStar/200
	X := _gead.WhitePoint[0] * _cagc(L)
	Y := _gead.WhitePoint[1] * _cagc(M)
	Z := _gead.WhitePoint[2] * _cagc(N)
	_bbeee := 3.240479*X + -1.537150*Y + -0.498535*Z
	_gcbg := -0.969256*X + 1.875992*Y + 0.041556*Z
	_feeab := 0.055648*X + -0.204043*Y + 1.057311*Z
	_bbeee = _bg.Min(_bg.Max(_bbeee, 0), 1.0)
	_gcbg = _bg.Min(_bg.Max(_gcbg, 0), 1.0)
	_feeab = _bg.Min(_bg.Max(_feeab, 0), 1.0)
	return NewPdfColorDeviceRGB(_bbeee, _gcbg, _feeab), nil
}

const (
	ActionTypeGoTo        PdfActionType = "\u0047\u006f\u0054\u006f"
	ActionTypeGoTo3DView  PdfActionType = "\u0047\u006f\u0054\u006f\u0033\u0044\u0056\u0069\u0065\u0077"
	ActionTypeGoToE       PdfActionType = "\u0047\u006f\u0054o\u0045"
	ActionTypeGoToR       PdfActionType = "\u0047\u006f\u0054o\u0052"
	ActionTypeHide        PdfActionType = "\u0048\u0069\u0064\u0065"
	ActionTypeImportData  PdfActionType = "\u0049\u006d\u0070\u006f\u0072\u0074\u0044\u0061\u0074\u0061"
	ActionTypeJavaScript  PdfActionType = "\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"
	ActionTypeLaunch      PdfActionType = "\u004c\u0061\u0075\u006e\u0063\u0068"
	ActionTypeMovie       PdfActionType = "\u004d\u006f\u0076i\u0065"
	ActionTypeNamed       PdfActionType = "\u004e\u0061\u006de\u0064"
	ActionTypeRendition   PdfActionType = "\u0052e\u006e\u0064\u0069\u0074\u0069\u006fn"
	ActionTypeResetForm   PdfActionType = "\u0052e\u0073\u0065\u0074\u0046\u006f\u0072m"
	ActionTypeSetOCGState PdfActionType = "S\u0065\u0074\u004f\u0043\u0047\u0053\u0074\u0061\u0074\u0065"
	ActionTypeSound       PdfActionType = "\u0053\u006f\u0075n\u0064"
	ActionTypeSubmitForm  PdfActionType = "\u0053\u0075\u0062\u006d\u0069\u0074\u0046\u006f\u0072\u006d"
	ActionTypeThread      PdfActionType = "\u0054\u0068\u0072\u0065\u0061\u0064"
	ActionTypeTrans       PdfActionType = "\u0054\u0072\u0061n\u0073"
	ActionTypeURI         PdfActionType = "\u0055\u0052\u0049"
)

// PdfColorspaceDeviceGray represents a grayscale colorspace.
type PdfColorspaceDeviceGray struct{}

// GetOutlinesFlattened returns a flattened list of tree nodes and titles.
// NOTE: for most use cases, it is recommended to use the high-level GetOutlines
// method instead, which also provides information regarding the destination
// of the outline items.
func (_cgfdf *PdfReader) GetOutlinesFlattened() ([]*PdfOutlineTreeNode, []string, error) {
	var _bgbcg []*PdfOutlineTreeNode
	var _cgcf []string
	var _bbedc func(*PdfOutlineTreeNode, *[]*PdfOutlineTreeNode, *[]string, int)
	_bbedc = func(_fggdf *PdfOutlineTreeNode, _bbcfc *[]*PdfOutlineTreeNode, _bgdc *[]string, _adde int) {
		if _fggdf == nil {
			return
		}
		if _fggdf._ffgd == nil {
			_fef.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020M\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006e\u006fd\u0065\u002e\u0063o\u006et\u0065\u0078\u0074")
			return
		}
		_fbcbg, _ebfbc := _fggdf._ffgd.(*PdfOutlineItem)
		if _ebfbc {
			*_bbcfc = append(*_bbcfc, &_fbcbg.PdfOutlineTreeNode)
			_cbebb := _eed.Repeat("\u0020", _adde*2) + _fbcbg.Title.Decoded()
			*_bgdc = append(*_bgdc, _cbebb)
		}
		if _fggdf.First != nil {
			_febaf := _eed.Repeat("\u0020", _adde*2) + "\u002b"
			*_bgdc = append(*_bgdc, _febaf)
			_bbedc(_fggdf.First, _bbcfc, _bgdc, _adde+1)
		}
		if _ebfbc && _fbcbg.Next != nil {
			_bbedc(_fbcbg.Next, _bbcfc, _bgdc, _adde)
		}
	}
	_bbedc(_cgfdf._fgcc, &_bgbcg, &_cgcf, 0)
	return _bgbcg, _cgcf, nil
}

// ToPdfObject returns the PDF representation of the VRI dictionary.
func (_edag *VRI) ToPdfObject() *_fed.PdfObjectDictionary {
	_ggaae := _fed.MakeDict()
	_ggaae.SetIfNotNil(_fed.PdfObjectName("\u0043\u0065\u0072\u0074"), _ggfga(_edag.Cert))
	_ggaae.SetIfNotNil(_fed.PdfObjectName("\u004f\u0043\u0053\u0050"), _ggfga(_edag.OCSP))
	_ggaae.SetIfNotNil(_fed.PdfObjectName("\u0043\u0052\u004c"), _ggfga(_edag.CRL))
	_ggaae.SetIfNotNil("\u0054\u0055", _edag.TU)
	_ggaae.SetIfNotNil("\u0054\u0053", _edag.TS)
	return _ggaae
}

// ImageToRGB convert 1-component grayscale data to 3-component RGB.
func (_gdce *PdfColorspaceDeviceGray) ImageToRGB(img Image) (Image, error) {
	if img.ColorComponents != 1 {
		return img, _bb.New("\u0074\u0068e \u0070\u0072\u006fv\u0069\u0064\u0065\u0064 im\u0061ge\u0020\u0069\u0073\u0020\u006e\u006f\u0074 g\u0072\u0061\u0079\u0020\u0073\u0063\u0061l\u0065")
	}
	_bggf, _bcdc := _eede.NewImage(int(img.Width), int(img.Height), int(img.BitsPerComponent), img.ColorComponents, img.Data, img._caeaf, img._ccdge)
	if _bcdc != nil {
		return img, _bcdc
	}
	_eced, _bcdc := _eede.NRGBAConverter.Convert(_bggf)
	if _bcdc != nil {
		return img, _bcdc
	}
	_bcgb := _ddbab(_eced.Base())
	_fef.Log.Trace("\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079\u0020\u002d>\u0020\u0052\u0047\u0042")
	_fef.Log.Trace("s\u0061\u006d\u0070\u006c\u0065\u0073\u003a\u0020\u0025\u0076", img.Data)
	_fef.Log.Trace("\u0052G\u0042 \u0073\u0061\u006d\u0070\u006c\u0065\u0073\u003a\u0020\u0025\u0076", _bcgb.Data)
	_fef.Log.Trace("\u0025\u0076\u0020\u002d\u003e\u0020\u0025\u0076", img, _bcgb)
	return _bcgb, nil
}

type fontFile struct {
	_gaag  string
	_egeeg string
	_dddff _dg.SimpleEncoder
}

// HasXObjectByName checks if has XObject resource by name.
func (_fddfa *PdfPage) HasXObjectByName(name _fed.PdfObjectName) bool {
	_bdeca, _dbgc := _fddfa.Resources.XObject.(*_fed.PdfObjectDictionary)
	if !_dbgc {
		return false
	}
	if _gbegc := _bdeca.Get(name); _gbegc != nil {
		return true
	}
	return false
}

// ToPdfObject implements interface PdfModel.
func (_ddgd *PdfAnnotationPolygon) ToPdfObject() _fed.PdfObject {
	_ddgd.PdfAnnotation.ToPdfObject()
	_edeg := _ddgd._ffaab
	_gegb := _edeg.PdfObject.(*_fed.PdfObjectDictionary)
	_ddgd.PdfAnnotationMarkup.appendToPdfDictionary(_gegb)
	_gegb.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u0050o\u006c\u0079\u0067\u006f\u006e"))
	_gegb.SetIfNotNil("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073", _ddgd.Vertices)
	_gegb.SetIfNotNil("\u004c\u0045", _ddgd.LE)
	_gegb.SetIfNotNil("\u0042\u0053", _ddgd.BS)
	_gegb.SetIfNotNil("\u0049\u0043", _ddgd.IC)
	_gegb.SetIfNotNil("\u0042\u0045", _ddgd.BE)
	_gegb.SetIfNotNil("\u0049\u0054", _ddgd.IT)
	_gegb.SetIfNotNil("\u004de\u0061\u0073\u0075\u0072\u0065", _ddgd.Measure)
	return _edeg
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain a single element.
func (_gaef *PdfColorspaceSpecialIndexed) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 1 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	N := _gaef.Base.GetNumComponents()
	_gfcg := int(vals[0]) * N
	if _gfcg < 0 || (_gfcg+N-1) >= len(_gaef._defd) {
		return nil, _bb.New("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0072\u0061\u006e\u0067\u0065")
	}
	_bdecd := _gaef._defd[_gfcg : _gfcg+N]
	var _cabe []float64
	for _, _adgb := range _bdecd {
		_cabe = append(_cabe, float64(_adgb)/255.0)
	}
	_gffc, _bcga := _gaef.Base.ColorFromFloats(_cabe)
	if _bcga != nil {
		return nil, _bcga
	}
	return _gffc, nil
}

const (
	TrappedUnknown PdfInfoTrapped = "\u0055n\u006b\u006e\u006f\u0077\u006e"
	TrappedTrue    PdfInfoTrapped = "\u0054\u0072\u0075\u0065"
	TrappedFalse   PdfInfoTrapped = "\u0046\u0061\u006cs\u0065"
)

// ToPdfObject implements interface PdfModel.
func (_bggb *PdfAnnotationFileAttachment) ToPdfObject() _fed.PdfObject {
	_bggb.PdfAnnotation.ToPdfObject()
	_bbfe := _bggb._ffaab
	_dbgd := _bbfe.PdfObject.(*_fed.PdfObjectDictionary)
	_bggb.PdfAnnotationMarkup.appendToPdfDictionary(_dbgd)
	_dbgd.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u0046\u0069\u006c\u0065\u0041\u0074\u0074\u0061\u0063h\u006d\u0065\u006e\u0074"))
	_dbgd.SetIfNotNil("\u0046\u0053", _bggb.FS)
	_dbgd.SetIfNotNil("\u004e\u0061\u006d\u0065", _bggb.Name)
	return _bbfe
}

// SetVersion sets the PDF version of the output file.
func (_gcdagg *PdfWriter) SetVersion(majorVersion, minorVersion int) {
	_gcdagg._gbgag = majorVersion
	_gcdagg._cccf = minorVersion
}

// PdfReader represents a PDF file reader. It is a frontend to the lower level parsing mechanism and provides
// a higher level access to work with PDF structure and information, such as the page structure etc.
type PdfReader struct {
	_cdfggf  *_fed.PdfParser
	_dfcaf   _fed.PdfObject
	_fadda   *_fed.PdfIndirectObject
	_cbabc   *_fed.PdfObjectDictionary
	_gdac    []*_fed.PdfIndirectObject
	PageList []*PdfPage
	_efcga   int
	_bfcdc   *_fed.PdfObjectDictionary
	_fgcc    *PdfOutlineTreeNode
	AcroForm *PdfAcroForm
	DSS      *DSS
	Rotate   *int64
	_dcfcd   *modelManager
	_bgbff   bool
	_aaebc   map[_fed.PdfObject]struct{}
	_faefaf  _ge.ReadSeeker
	_cfage   string
}

// NewPdfAnnotationSquiggly returns a new text squiggly annotation.
func NewPdfAnnotationSquiggly() *PdfAnnotationSquiggly {
	_adfd := NewPdfAnnotation()
	_fdbc := &PdfAnnotationSquiggly{}
	_fdbc.PdfAnnotation = _adfd
	_fdbc.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_adfd.SetContext(_fdbc)
	return _fdbc
}

// ToPdfObject converts the pdfFontSimple to its PDF representation for outputting.
func (_dagd *pdfFontSimple) ToPdfObject() _fed.PdfObject {
	if _dagd._gedd == nil {
		_dagd._gedd = &_fed.PdfIndirectObject{}
	}
	_cfceec := _dagd.baseFields().asPdfObjectDictionary("")
	_dagd._gedd.PdfObject = _cfceec
	if _dagd.FirstChar != nil {
		_cfceec.Set("\u0046i\u0072\u0073\u0074\u0043\u0068\u0061r", _dagd.FirstChar)
	}
	if _dagd.LastChar != nil {
		_cfceec.Set("\u004c\u0061\u0073\u0074\u0043\u0068\u0061\u0072", _dagd.LastChar)
	}
	if _dagd.Widths != nil {
		_cfceec.Set("\u0057\u0069\u0064\u0074\u0068\u0073", _dagd.Widths)
	}
	if _dagd.Encoding != nil {
		_cfceec.Set("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", _dagd.Encoding)
	} else if _dagd._ebcbf != nil {
		_cedbe := _dagd._ebcbf.ToPdfObject()
		if _cedbe != nil {
			_cfceec.Set("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", _cedbe)
		}
	}
	return _dagd._gedd
}

// GetDescent returns the Descent of the font `descriptor`.
func (_ccdgd *PdfFontDescriptor) GetDescent() (float64, error) {
	return _fed.GetNumberAsFloat(_ccdgd.Descent)
}

// NewPdfAnnotationText returns a new text annotation.
func NewPdfAnnotationText() *PdfAnnotationText {
	_egfc := NewPdfAnnotation()
	_bcef := &PdfAnnotationText{}
	_bcef.PdfAnnotation = _egfc
	_bcef.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_egfc.SetContext(_bcef)
	return _bcef
}

// String returns a string describing the font descriptor.
func (_dggc *PdfFontDescriptor) String() string {
	var _aabdd []string
	if _dggc.FontName != nil {
		_aabdd = append(_aabdd, _dggc.FontName.String())
	}
	if _dggc.FontFamily != nil {
		_aabdd = append(_aabdd, _dggc.FontFamily.String())
	}
	if _dggc.fontFile != nil {
		_aabdd = append(_aabdd, _dggc.fontFile.String())
	}
	if _dggc._afef != nil {
		_aabdd = append(_aabdd, _dggc._afef.String())
	}
	_aabdd = append(_aabdd, _d.Sprintf("\u0046\u006f\u006et\u0046\u0069\u006c\u0065\u0033\u003d\u0025\u0074", _dggc.FontFile3 != nil))
	return _d.Sprintf("\u0046\u004f\u004e\u0054_D\u0045\u0053\u0043\u0052\u0049\u0050\u0054\u004f\u0052\u007b\u0025\u0073\u007d", _eed.Join(_aabdd, "\u002c\u0020"))
}
func (_cegc *PdfAppender) addNewObject(_fdcg _fed.PdfObject) {
	if _, _cadc := _cegc._bcgf[_fdcg]; !_cadc {
		_cegc._gdba = append(_cegc._gdba, _fdcg)
		_cegc._bcgf[_fdcg] = struct{}{}
	}
}

// WriteToFile writes the Appender output to file specified by path.
func (_aeaa *PdfAppender) WriteToFile(outputPath string) error {
	_geea, _baff := _da.Create(outputPath)
	if _baff != nil {
		return _baff
	}
	defer _geea.Close()
	return _aeaa.Write(_geea)
}

// GetIndirectObjectByNumber retrieves and returns a specific PdfObject by object number.
func (_afefea *PdfReader) GetIndirectObjectByNumber(number int) (_fed.PdfObject, error) {
	_cdfc, _bgege := _afefea._cdfggf.LookupByNumber(number)
	return _cdfc, _bgege
}

// B returns the value of the B component of the color.
func (_bgbdf *PdfColorLab) B() float64 { return _bgbdf[2] }
func (_gedf *XObjectImage) getParamsDict() *_fed.PdfObjectDictionary {
	_fefcgd := _fed.MakeDict()
	_fefcgd.Set("\u0057\u0069\u0064t\u0068", _fed.MakeInteger(*_gedf.Width))
	_fefcgd.Set("\u0048\u0065\u0069\u0067\u0068\u0074", _fed.MakeInteger(*_gedf.Height))
	_fefcgd.Set("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073", _fed.MakeInteger(int64(_gedf.ColorSpace.GetNumComponents())))
	_fefcgd.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _fed.MakeInteger(*_gedf.BitsPerComponent))
	return _fefcgd
}

// FieldAppearanceGenerator generates appearance stream for a given field.
type FieldAppearanceGenerator interface {
	ContentStreamWrapper
	GenerateAppearanceDict(_fdbea *PdfAcroForm, _gcega *PdfField, _cfgb *PdfAnnotationWidget) (*_fed.PdfObjectDictionary, error)
}

// PdfShadingType4 is a Free-form Gouraud-shaded triangle mesh.
type PdfShadingType4 struct {
	*PdfShading
	BitsPerCoordinate *_fed.PdfObjectInteger
	BitsPerComponent  *_fed.PdfObjectInteger
	BitsPerFlag       *_fed.PdfObjectInteger
	Decode            *_fed.PdfObjectArray
	Function          []PdfFunction
}

// DecodeArray returns the range of color component values in DeviceRGB colorspace.
func (_bfg *PdfColorspaceDeviceRGB) DecodeArray() []float64 {
	return []float64{0.0, 1.0, 0.0, 1.0, 0.0, 1.0}
}

type pdfCIDFontType2 struct {
	fontCommon
	_fdec  *_fed.PdfIndirectObject
	_gggce _dg.TextEncoder

	// Table 117 – Entries in a CIDFont dictionary (page 269)
	// Dictionary that defines the character collection of the CIDFont (required).
	// See Table 116.
	CIDSystemInfo *_fed.PdfObjectDictionary

	// Glyph metrics fields (optional).
	DW  _fed.PdfObject
	W   _fed.PdfObject
	DW2 _fed.PdfObject
	W2  _fed.PdfObject

	// CIDs to glyph indices mapping (optional).
	CIDToGIDMap _fed.PdfObject
	_faabg      map[_dg.CharCode]float64
	_bcedd      float64
	_bbff       map[rune]int
}

// NewPdfAnnotationCircle returns a new circle annotation.
func NewPdfAnnotationCircle() *PdfAnnotationCircle {
	_fecb := NewPdfAnnotation()
	_cbcg := &PdfAnnotationCircle{}
	_cbcg.PdfAnnotation = _fecb
	_cbcg.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_fecb.SetContext(_cbcg)
	return _cbcg
}

// GetNumComponents returns the number of color components (1 for grayscale).
func (_fbgfd *PdfColorDeviceGray) GetNumComponents() int { return 1 }

// ToPdfObject converts the font to a PDF representation.
func (_bgcge *pdfFontType3) ToPdfObject() _fed.PdfObject {
	if _bgcge._fdaf == nil {
		_bgcge._fdaf = &_fed.PdfIndirectObject{}
	}
	_ffece := _bgcge.baseFields().asPdfObjectDictionary("\u0054\u0079\u0070e\u0033")
	_bgcge._fdaf.PdfObject = _ffece
	if _bgcge.FirstChar != nil {
		_ffece.Set("\u0046i\u0072\u0073\u0074\u0043\u0068\u0061r", _bgcge.FirstChar)
	}
	if _bgcge.LastChar != nil {
		_ffece.Set("\u004c\u0061\u0073\u0074\u0043\u0068\u0061\u0072", _bgcge.LastChar)
	}
	if _bgcge.Widths != nil {
		_ffece.Set("\u0057\u0069\u0064\u0074\u0068\u0073", _bgcge.Widths)
	}
	if _bgcge.Encoding != nil {
		_ffece.Set("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", _bgcge.Encoding)
	} else if _bgcge._gefc != nil {
		_gdfcb := _bgcge._gefc.ToPdfObject()
		if _gdfcb != nil {
			_ffece.Set("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", _gdfcb)
		}
	}
	if _bgcge.FontBBox != nil {
		_ffece.Set("\u0046\u006f\u006e\u0074\u0042\u0042\u006f\u0078", _bgcge.FontBBox)
	}
	if _bgcge.FontMatrix != nil {
		_ffece.Set("\u0046\u006f\u006e\u0074\u004d\u0061\u0074\u0069\u0072\u0078", _bgcge.FontMatrix)
	}
	if _bgcge.CharProcs != nil {
		_ffece.Set("\u0043h\u0061\u0072\u0050\u0072\u006f\u0063s", _bgcge.CharProcs)
	}
	if _bgcge.Resources != nil {
		_ffece.Set("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s", _bgcge.Resources)
	}
	return _bgcge._fdaf
}

// NewPdfColorLab returns a new Lab color.
func NewPdfColorLab(l, a, b float64) *PdfColorLab { _gadcb := PdfColorLab{l, a, b}; return &_gadcb }

// PdfActionGoTo represents a GoTo action.
type PdfActionGoTo struct {
	*PdfAction
	D _fed.PdfObject
}

func _ggfg(_bgdb *fontCommon) *pdfFontType3 { return &pdfFontType3{fontCommon: *_bgdb} }
func (_ffab *PdfReader) newPdfActionGotoRFromDict(_ccf *_fed.PdfObjectDictionary) (*PdfActionGoToR, error) {
	_gae, _dag := _eec(_ccf.Get("\u0046"))
	if _dag != nil {
		return nil, _dag
	}
	return &PdfActionGoToR{D: _ccf.Get("\u0044"), NewWindow: _ccf.Get("\u004ee\u0077\u0057\u0069\u006e\u0064\u006fw"), F: _gae}, nil
}

// IsEncrypted returns true if the PDF file is encrypted.
func (_cdbec *PdfReader) IsEncrypted() (bool, error) { return _cdbec._cdfggf.IsEncrypted() }
func (_acaf fontCommon) fontFlags() int {
	if _acaf._bgdgb == nil {
		return 0
	}
	return _acaf._bgdgb._ffda
}

// NewPdfActionGoToE returns a new "go to embedded" action.
func NewPdfActionGoToE() *PdfActionGoToE {
	_ca := NewPdfAction()
	_gd := &PdfActionGoToE{}
	_gd.PdfAction = _ca
	_ca.SetContext(_gd)
	return _gd
}

// PdfAnnotationStamp represents Stamp annotations.
// (Section 12.5.6.12).
type PdfAnnotationStamp struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	Name _fed.PdfObject
}

// ToPdfObject returns the PDF representation of the function.
func (_abbd *PdfFunctionType2) ToPdfObject() _fed.PdfObject {
	_abdc := _fed.MakeDict()
	_abdc.Set("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065", _fed.MakeInteger(2))
	_deade := &_fed.PdfObjectArray{}
	for _, _gdefc := range _abbd.Domain {
		_deade.Append(_fed.MakeFloat(_gdefc))
	}
	_abdc.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _deade)
	if _abbd.Range != nil {
		_ecbeg := &_fed.PdfObjectArray{}
		for _, _dged := range _abbd.Range {
			_ecbeg.Append(_fed.MakeFloat(_dged))
		}
		_abdc.Set("\u0052\u0061\u006eg\u0065", _ecbeg)
	}
	if _abbd.C0 != nil {
		_fceaa := &_fed.PdfObjectArray{}
		for _, _egeea := range _abbd.C0 {
			_fceaa.Append(_fed.MakeFloat(_egeea))
		}
		_abdc.Set("\u0043\u0030", _fceaa)
	}
	if _abbd.C1 != nil {
		_cgeb := &_fed.PdfObjectArray{}
		for _, _fcffb := range _abbd.C1 {
			_cgeb.Append(_fed.MakeFloat(_fcffb))
		}
		_abdc.Set("\u0043\u0031", _cgeb)
	}
	_abdc.Set("\u004e", _fed.MakeFloat(_abbd.N))
	if _abbd._fbebb != nil {
		_abbd._fbebb.PdfObject = _abdc
		return _abbd._fbebb
	}
	return _abdc
}
func (_ddgee *LTV) getCRLs(_dgee []*_fe.Certificate) ([][]byte, error) {
	_agbf := make([][]byte, 0, len(_dgee))
	for _, _gedda := range _dgee {
		for _, _caebb := range _gedda.CRLDistributionPoints {
			if _ddgee.CertClient.IsCA(_gedda) {
				continue
			}
			_fgegd, _acgcf := _ddgee.CRLClient.MakeRequest(_caebb, _gedda)
			if _acgcf != nil {
				_fef.Log.Debug("W\u0041\u0052\u004e\u003a\u0020\u0043R\u004c\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074 \u0065\u0072\u0072o\u0072:\u0020\u0025\u0076", _acgcf)
				continue
			}
			_agbf = append(_agbf, _fgegd)
		}
	}
	return _agbf, nil
}
func (_ddaa *PdfReader) newPdfAnnotationRichMediaFromDict(_cedc *_fed.PdfObjectDictionary) (*PdfAnnotationRichMedia, error) {
	_dgeac := &PdfAnnotationRichMedia{}
	_dgeac.RichMediaSettings = _cedc.Get("\u0052\u0069\u0063\u0068\u004d\u0065\u0064\u0069\u0061\u0053\u0065\u0074t\u0069\u006e\u0067\u0073")
	_dgeac.RichMediaContent = _cedc.Get("\u0052\u0069c\u0068\u004d\u0065d\u0069\u0061\u0043\u006f\u006e\u0074\u0065\u006e\u0074")
	return _dgeac, nil
}

// PdfAnnotationSquiggly represents Squiggly annotations.
// (Section 12.5.6.10).
type PdfAnnotationSquiggly struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	QuadPoints _fed.PdfObject
}

// GetTrailer returns the PDF's trailer dictionary.
func (_adfb *PdfReader) GetTrailer() (*_fed.PdfObjectDictionary, error) {
	_gbad := _adfb._cdfggf.GetTrailer()
	if _gbad == nil {
		return nil, _bb.New("\u0074r\u0061i\u006c\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
	}
	return _gbad, nil
}

// NewPdfAnnotationStamp returns a new stamp annotation.
func NewPdfAnnotationStamp() *PdfAnnotationStamp {
	_bdde := NewPdfAnnotation()
	_gaad := &PdfAnnotationStamp{}
	_gaad.PdfAnnotation = _bdde
	_gaad.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_bdde.SetContext(_gaad)
	return _gaad
}

// ColorFromPdfObjects gets the color from a series of pdf objects (4 for cmyk).
func (_afec *PdfColorspaceDeviceCMYK) ColorFromPdfObjects(objects []_fed.PdfObject) (PdfColor, error) {
	if len(objects) != 4 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_gdccc, _dddb := _fed.GetNumbersAsFloat(objects)
	if _dddb != nil {
		return nil, _dddb
	}
	return _afec.ColorFromFloats(_gdccc)
}

// ToPdfObject implements interface PdfModel.
func (_dcg *PdfActionURI) ToPdfObject() _fed.PdfObject {
	_dcg.PdfAction.ToPdfObject()
	_df := _dcg._fa
	_adf := _df.PdfObject.(*_fed.PdfObjectDictionary)
	_adf.SetIfNotNil("\u0053", _fed.MakeName(string(ActionTypeURI)))
	_adf.SetIfNotNil("\u0055\u0052\u0049", _dcg.URI)
	_adf.SetIfNotNil("\u0049\u0073\u004da\u0070", _dcg.IsMap)
	return _df
}

// PdfActionSetOCGState represents a SetOCGState action.
type PdfActionSetOCGState struct {
	*PdfAction
	State      _fed.PdfObject
	PreserveRB _fed.PdfObject
}

// B returns the value of the B component of the color.
func (_ffca *PdfColorCalRGB) B() float64 { return _ffca[1] }

// PdfColorspaceCalGray represents CalGray color space.
type PdfColorspaceCalGray struct {
	WhitePoint []float64
	BlackPoint []float64
	Gamma      float64
	_cdab      *_fed.PdfIndirectObject
}

// NewXObjectFormFromStream builds the Form XObject from a stream object.
// TODO: Should this be exposed? Consider different access points.
func NewXObjectFormFromStream(stream *_fed.PdfObjectStream) (*XObjectForm, error) {
	_egafd := &XObjectForm{}
	_egafd._cedfc = stream
	_bcfge := *(stream.PdfObjectDictionary)
	_abeec, _eafeee := _fed.NewEncoderFromStream(stream)
	if _eafeee != nil {
		return nil, _eafeee
	}
	_egafd.Filter = _abeec
	if _abgge := _bcfge.Get("\u0053u\u0062\u0074\u0079\u0070\u0065"); _abgge != nil {
		_eaee, _dbdfb := _abgge.(*_fed.PdfObjectName)
		if !_dbdfb {
			return nil, _bb.New("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		if *_eaee != "\u0046\u006f\u0072\u006d" {
			_fef.Log.Debug("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072m\u0020\u0073\u0075\u0062ty\u0070\u0065")
			return nil, _bb.New("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072m\u0020\u0073\u0075\u0062ty\u0070\u0065")
		}
	}
	if _abcead := _bcfge.Get("\u0046\u006f\u0072\u006d\u0054\u0079\u0070\u0065"); _abcead != nil {
		_egafd.FormType = _abcead
	}
	if _bdfbe := _bcfge.Get("\u0042\u0042\u006f\u0078"); _bdfbe != nil {
		_egafd.BBox = _bdfbe
	}
	if _cbdfc := _bcfge.Get("\u004d\u0061\u0074\u0072\u0069\u0078"); _cbdfc != nil {
		_egafd.Matrix = _cbdfc
	}
	if _faddg := _bcfge.Get("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s"); _faddg != nil {
		_faddg = _fed.TraceToDirectObject(_faddg)
		_abcde, _abfdg := _faddg.(*_fed.PdfObjectDictionary)
		if !_abfdg {
			_fef.Log.Debug("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0058\u004f\u0062j\u0065c\u0074\u0020\u0046\u006f\u0072\u006d\u0020\u0052\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0073\u0020\u006f\u0062j\u0065\u0063\u0074\u002c\u0020\u0070\u006f\u0069\u006e\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079")
			return nil, _fed.ErrTypeError
		}
		_ffbfa, _eebcg := NewPdfPageResourcesFromDict(_abcde)
		if _eebcg != nil {
			_fef.Log.Debug("\u0046\u0061i\u006c\u0065\u0064\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u006d\u0020\u0072\u0065\u0073\u006f\u0075rc\u0065\u0073")
			return nil, _eebcg
		}
		_egafd.Resources = _ffbfa
		_fef.Log.Trace("\u0046\u006f\u0072\u006d r\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0073\u003a\u0020\u0025\u0023\u0076", _egafd.Resources)
	}
	_egafd.Group = _bcfge.Get("\u0047\u0072\u006fu\u0070")
	_egafd.Ref = _bcfge.Get("\u0052\u0065\u0066")
	_egafd.MetaData = _bcfge.Get("\u004d\u0065\u0074\u0061\u0044\u0061\u0074\u0061")
	_egafd.PieceInfo = _bcfge.Get("\u0050i\u0065\u0063\u0065\u0049\u006e\u0066o")
	_egafd.LastModified = _bcfge.Get("\u004c\u0061\u0073t\u004d\u006f\u0064\u0069\u0066\u0069\u0065\u0064")
	_egafd.StructParent = _bcfge.Get("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074")
	_egafd.StructParents = _bcfge.Get("\u0053\u0074\u0072\u0075\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074\u0073")
	_egafd.OPI = _bcfge.Get("\u004f\u0050\u0049")
	_egafd.OC = _bcfge.Get("\u004f\u0043")
	_egafd.Name = _bcfge.Get("\u004e\u0061\u006d\u0065")
	_egafd.Stream = stream.Stream
	return _egafd, nil
}

// DecodeArray returns an empty slice as there are no components associated with pattern colorspace.
func (_eaed *PdfColorspaceSpecialPattern) DecodeArray() []float64 { return []float64{} }

// AddWatermarkImage adds a watermark to the page.
func (_feaf *PdfPage) AddWatermarkImage(ximg *XObjectImage, opt WatermarkImageOptions) error {
	_aadaf, _fbbcg := _feaf.GetMediaBox()
	if _fbbcg != nil {
		return _fbbcg
	}
	_gbege := _aadaf.Urx - _aadaf.Llx
	_adcc := _aadaf.Ury - _aadaf.Lly
	_dddeadb := float64(*ximg.Width)
	_aafgb := (_gbege - _dddeadb) / 2
	if opt.FitToWidth {
		_dddeadb = _gbege
		_aafgb = 0
	}
	_eebb := _adcc
	_cdcgb := float64(0)
	if opt.PreserveAspectRatio {
		_eebb = _dddeadb * float64(*ximg.Height) / float64(*ximg.Width)
		_cdcgb = (_adcc - _eebb) / 2
	}
	if _feaf.Resources == nil {
		_feaf.Resources = NewPdfPageResources()
	}
	_adeca := 0
	_cccgb := _fed.PdfObjectName(_d.Sprintf("\u0049\u006d\u0077%\u0064", _adeca))
	for _feaf.Resources.HasXObjectByName(_cccgb) {
		_adeca++
		_cccgb = _fed.PdfObjectName(_d.Sprintf("\u0049\u006d\u0077%\u0064", _adeca))
	}
	_fbbcg = _feaf.AddImageResource(_cccgb, ximg)
	if _fbbcg != nil {
		return _fbbcg
	}
	_adeca = 0
	_ebgdb := _fed.PdfObjectName(_d.Sprintf("\u0047\u0053\u0025\u0064", _adeca))
	for _feaf.HasExtGState(_ebgdb) {
		_adeca++
		_ebgdb = _fed.PdfObjectName(_d.Sprintf("\u0047\u0053\u0025\u0064", _adeca))
	}
	_ddagg := _fed.MakeDict()
	_ddagg.Set("\u0042\u004d", _fed.MakeName("\u004e\u006f\u0072\u006d\u0061\u006c"))
	_ddagg.Set("\u0043\u0041", _fed.MakeFloat(opt.Alpha))
	_ddagg.Set("\u0063\u0061", _fed.MakeFloat(opt.Alpha))
	_fbbcg = _feaf.AddExtGState(_ebgdb, _ddagg)
	if _fbbcg != nil {
		return _fbbcg
	}
	_fegab := _d.Sprintf("\u0071\u000a"+"\u002f%\u0073\u0020\u0067\u0073\u000a"+"%\u002e\u0030\u0066\u0020\u0030\u00200\u0020\u0025\u002e\u0030\u0066\u0020\u0025\u002e\u0034f\u0020\u0025\u002e4\u0066 \u0063\u006d\u000a"+"\u002f%\u0073\u0020\u0044\u006f\u000a"+"\u0051", _ebgdb, _dddeadb, _eebb, _aafgb, _cdcgb, _cccgb)
	_feaf.AddContentStreamByString(_fegab)
	return nil
}

// M returns the value of the magenta component of the color.
func (_fbbf *PdfColorDeviceCMYK) M() float64 { return _fbbf[1] }

// GetCustomInfo returns a custom info value for the specified name.
func (_eafgg *PdfInfo) GetCustomInfo(name string) *_fed.PdfObjectString {
	var _efga *_fed.PdfObjectString
	if _eafgg._debc == nil {
		return _efga
	}
	if _cccc, _ffcd := _eafgg._debc.Get(*_fed.MakeName(name)).(*_fed.PdfObjectString); _ffcd {
		_efga = _cccc
	}
	return _efga
}

// ToPdfObject implements interface PdfModel.
func (_eggg *PdfAnnotationHighlight) ToPdfObject() _fed.PdfObject {
	_eggg.PdfAnnotation.ToPdfObject()
	_abfd := _eggg._ffaab
	_cbdd := _abfd.PdfObject.(*_fed.PdfObjectDictionary)
	_eggg.PdfAnnotationMarkup.appendToPdfDictionary(_cbdd)
	_cbdd.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u0048i\u0067\u0068\u006c\u0069\u0067\u0068t"))
	_cbdd.SetIfNotNil("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073", _eggg.QuadPoints)
	return _abfd
}
func (_dcdfaf fontCommon) isCIDFont() bool {
	if _dcdfaf._afge == "" {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0069\u0073\u0043\u0049\u0044\u0046\u006f\u006e\u0074\u002e\u0020\u0063o\u006e\u0074\u0065\u0078\u0074\u0020\u0069\u0073\u0020\u006e\u0069\u006c\u002e\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _dcdfaf)
	}
	_agbbg := false
	switch _dcdfaf._afge {
	case "\u0054\u0079\u0070e\u0030", "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0030", "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0032":
		_agbbg = true
	}
	_fef.Log.Trace("i\u0073\u0043\u0049\u0044\u0046\u006fn\u0074\u003a\u0020\u0069\u0073\u0043\u0049\u0044\u003d%\u0074\u0020\u0066o\u006et\u003d\u0025\u0073", _agbbg, _dcdfaf)
	return _agbbg
}

// AllFields returns a flattened list of all fields in the form.
func (_aebd *PdfAcroForm) AllFields() []*PdfField {
	if _aebd == nil {
		return nil
	}
	var _eeegg []*PdfField
	if _aebd.Fields != nil {
		for _, _adfa := range *_aebd.Fields {
			_eeegg = append(_eeegg, _eacf(_adfa)...)
		}
	}
	return _eeegg
}

// ToPdfObject implements interface PdfModel.
func (_egg *PdfActionSound) ToPdfObject() _fed.PdfObject {
	_egg.PdfAction.ToPdfObject()
	_ccb := _egg._fa
	_gaa := _ccb.PdfObject.(*_fed.PdfObjectDictionary)
	_gaa.SetIfNotNil("\u0053", _fed.MakeName(string(ActionTypeSound)))
	_gaa.SetIfNotNil("\u0053\u006f\u0075n\u0064", _egg.Sound)
	_gaa.SetIfNotNil("\u0056\u006f\u006c\u0075\u006d\u0065", _egg.Volume)
	_gaa.SetIfNotNil("S\u0079\u006e\u0063\u0068\u0072\u006f\u006e\u006f\u0075\u0073", _egg.Synchronous)
	_gaa.SetIfNotNil("\u0052\u0065\u0070\u0065\u0061\u0074", _egg.Repeat)
	_gaa.SetIfNotNil("\u004d\u0069\u0078", _egg.Mix)
	return _ccb
}

// PdfColorspaceDeviceNAttributes contains additional information about the components of colour space that
// conforming readers may use. Conforming readers need not use the alternateSpace and tintTransform parameters,
// and may instead use a custom blending algorithms, along with other information provided in the attributes
// dictionary if present.
type PdfColorspaceDeviceNAttributes struct {
	Subtype     *_fed.PdfObjectName
	Colorants   _fed.PdfObject
	Process     _fed.PdfObject
	MixingHints _fed.PdfObject
	_cfbb       *_fed.PdfIndirectObject
}

// PdfAnnotationFreeText represents FreeText annotations.
// (Section 12.5.6.6).
type PdfAnnotationFreeText struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	DA _fed.PdfObject
	Q  _fed.PdfObject
	RC _fed.PdfObject
	DS _fed.PdfObject
	CL _fed.PdfObject
	IT _fed.PdfObject
	BE _fed.PdfObject
	RD _fed.PdfObject
	BS _fed.PdfObject
	LE _fed.PdfObject
}

// ToPdfObject converts PdfAcroForm to a PdfObject, i.e. an indirect object containing the
// AcroForm dictionary.
func (_bddbc *PdfAcroForm) ToPdfObject() _fed.PdfObject {
	_ccad := _bddbc._ceed
	_bcfga := _ccad.PdfObject.(*_fed.PdfObjectDictionary)
	if _bddbc.Fields != nil {
		_eadfaa := _fed.PdfObjectArray{}
		for _, _gebc := range *_bddbc.Fields {
			_facb := _gebc.GetContext()
			if _facb != nil {
				_eadfaa.Append(_facb.ToPdfObject())
			} else {
				_eadfaa.Append(_gebc.ToPdfObject())
			}
		}
		_bcfga.Set("\u0046\u0069\u0065\u006c\u0064\u0073", &_eadfaa)
	}
	if _bddbc.NeedAppearances != nil {
		_bcfga.Set("\u004ee\u0065d\u0041\u0070\u0070\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0073", _bddbc.NeedAppearances)
	}
	if _bddbc.SigFlags != nil {
		_bcfga.Set("\u0053\u0069\u0067\u0046\u006c\u0061\u0067\u0073", _bddbc.SigFlags)
	}
	if _bddbc.CO != nil {
		_bcfga.Set("\u0043\u004f", _bddbc.CO)
	}
	if _bddbc.DR != nil {
		_bcfga.Set("\u0044\u0052", _bddbc.DR.ToPdfObject())
	}
	if _bddbc.DA != nil {
		_bcfga.Set("\u0044\u0041", _bddbc.DA)
	}
	if _bddbc.Q != nil {
		_bcfga.Set("\u0051", _bddbc.Q)
	}
	if _bddbc.XFA != nil {
		_bcfga.Set("\u0058\u0046\u0041", _bddbc.XFA)
	}
	return _ccad
}

// NewPdfActionSetOCGState returns a new "named" action.
func NewPdfActionSetOCGState() *PdfActionSetOCGState {
	_egf := NewPdfAction()
	_ebf := &PdfActionSetOCGState{}
	_ebf.PdfAction = _egf
	_egf.SetContext(_ebf)
	return _ebf
}

// DecodeArray returns the range of color component values in DeviceCMYK colorspace.
func (_gebd *PdfColorspaceDeviceCMYK) DecodeArray() []float64 {
	return []float64{0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0}
}

// NewPdfOutlineItem returns an initialized PdfOutlineItem.
func NewPdfOutlineItem() *PdfOutlineItem {
	_bededc := &PdfOutlineItem{_gafcc: _fed.MakeIndirectObject(_fed.MakeDict())}
	_bededc._ffgd = _bededc
	return _bededc
}

// ToPdfObject implements interface PdfModel.
func (_cefdd *PdfAnnotationCircle) ToPdfObject() _fed.PdfObject {
	_cefdd.PdfAnnotation.ToPdfObject()
	_gebe := _cefdd._ffaab
	_efc := _gebe.PdfObject.(*_fed.PdfObjectDictionary)
	_cefdd.PdfAnnotationMarkup.appendToPdfDictionary(_efc)
	_efc.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u0043\u0069\u0072\u0063\u006c\u0065"))
	_efc.SetIfNotNil("\u0042\u0053", _cefdd.BS)
	_efc.SetIfNotNil("\u0049\u0043", _cefdd.IC)
	_efc.SetIfNotNil("\u0042\u0045", _cefdd.BE)
	_efc.SetIfNotNil("\u0052\u0044", _cefdd.RD)
	return _gebe
}

// GetNamedDestinations returns the Dests entry in the PDF catalog.
// See section 12.3.2.3 "Named Destinations" (p. 367 PDF32000_2008).
func (_ceeff *PdfReader) GetNamedDestinations() (_fed.PdfObject, error) {
	_abdcc := _fed.ResolveReference(_ceeff._bfcdc.Get("\u0044\u0065\u0073t\u0073"))
	if _abdcc == nil {
		return nil, nil
	}
	if !_ceeff._bgbff {
		_bggba := _ceeff.traverseObjectData(_abdcc)
		if _bggba != nil {
			return nil, _bggba
		}
	}
	return _abdcc, nil
}

// NewPdfAnnotationSquare returns a new square annotation.
func NewPdfAnnotationSquare() *PdfAnnotationSquare {
	_gbab := NewPdfAnnotation()
	_bdbc := &PdfAnnotationSquare{}
	_bdbc.PdfAnnotation = _gbab
	_bdbc.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_gbab.SetContext(_bdbc)
	return _bdbc
}

// GetContainingPdfObject returns the containing object for the PdfField, i.e. an indirect object
// containing the field dictionary.
func (_agac *PdfField) GetContainingPdfObject() _fed.PdfObject { return _agac._cbaae }

// SetContentStreams sets the content streams based on a string array. Will make
// 1 object stream for each string and reference from the page Contents.
// Each stream will be encoded using the encoding specified by the StreamEncoder,
// if empty, will use identity encoding (raw data).
func (_bfcc *PdfPage) SetContentStreams(cStreams []string, encoder _fed.StreamEncoder) error {
	if len(cStreams) == 0 {
		_bfcc.Contents = nil
		return nil
	}
	if encoder == nil {
		encoder = _fed.NewRawEncoder()
	}
	var _bded []*_fed.PdfObjectStream
	for _, _gbbgc := range cStreams {
		_faedf := &_fed.PdfObjectStream{}
		_gccfc := encoder.MakeStreamDict()
		_edaed, _aeag := encoder.EncodeBytes([]byte(_gbbgc))
		if _aeag != nil {
			return _aeag
		}
		_gccfc.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _fed.MakeInteger(int64(len(_edaed))))
		_faedf.PdfObjectDictionary = _gccfc
		_faedf.Stream = _edaed
		_bded = append(_bded, _faedf)
	}
	if len(_bded) == 1 {
		_bfcc.Contents = _bded[0]
	} else {
		_dbcaf := _fed.MakeArray()
		for _, _abgbca := range _bded {
			_dbcaf.Append(_abgbca)
		}
		_bfcc.Contents = _dbcaf
	}
	return nil
}

var _ pdfFont = (*pdfFontType3)(nil)

func (_defba *pdfFontSimple) updateStandard14Font() {
	_agbbb, _ebcae := _defba.Encoder().(_dg.SimpleEncoder)
	if !_ebcae {
		_fef.Log.Error("\u0057\u0072\u006f\u006e\u0067\u0020\u0065\u006e\u0063\u006f\u0064\u0065\u0072\u0020\u0074y\u0070e\u003a\u0020\u0025\u0054\u002e\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073\u002e", _defba.Encoder(), _defba)
		return
	}
	_adbefd := _agbbb.Charcodes()
	_defba._dadc = make(map[_dg.CharCode]float64, len(_adbefd))
	for _, _egbbb := range _adbefd {
		_faeba, _ := _agbbb.CharcodeToRune(_egbbb)
		_acaa, _ := _defba._abef.Read(_faeba)
		_defba._dadc[_egbbb] = _acaa.Wx
	}
}
func _badef(_egade *_fed.PdfObjectDictionary) (*PdfShadingType6, error) {
	_cccde := PdfShadingType6{}
	_gecab := _egade.Get("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065")
	if _gecab == nil {
		_fef.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064 \u0061\u0074\u0074\u0072\u0069\u0062\u0075t\u0065\u0020\u006d\u0069\u0073\u0073i\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072C\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_ggfcc, _gdcbgd := _gecab.(*_fed.PdfObjectInteger)
	if !_gdcbgd {
		_fef.Log.Debug("\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _gecab)
		return nil, _fed.ErrTypeError
	}
	_cccde.BitsPerCoordinate = _ggfcc
	_gecab = _egade.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074")
	if _gecab == nil {
		_fef.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064\u0020a\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073\u0073in\u0067\u003a\u0020B\u0069\u0074s\u0050\u0065\u0072\u0043\u006f\u006dp\u006f\u006ee\u006e\u0074")
		return nil, ErrRequiredAttributeMissing
	}
	_ggfcc, _gdcbgd = _gecab.(*_fed.PdfObjectInteger)
	if !_gdcbgd {
		_fef.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065r \u0028\u0067\u006ft\u0020%\u0054\u0029", _gecab)
		return nil, _fed.ErrTypeError
	}
	_cccde.BitsPerComponent = _ggfcc
	_gecab = _egade.Get("B\u0069\u0074\u0073\u0050\u0065\u0072\u0046\u006c\u0061\u0067")
	if _gecab == nil {
		_fef.Log.Debug("\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065r\u0046\u006c\u0061\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_ggfcc, _gdcbgd = _gecab.(*_fed.PdfObjectInteger)
	if !_gdcbgd {
		_fef.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072F\u006c\u0061\u0067\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025T\u0029", _gecab)
		return nil, _fed.ErrTypeError
	}
	_cccde.BitsPerComponent = _ggfcc
	_gecab = _egade.Get("\u0044\u0065\u0063\u006f\u0064\u0065")
	if _gecab == nil {
		_fef.Log.Debug("\u0052\u0065\u0071ui\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069b\u0075t\u0065 \u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_gdfcc, _gdcbgd := _gecab.(*_fed.PdfObjectArray)
	if !_gdcbgd {
		_fef.Log.Debug("\u0044\u0065\u0063\u006fd\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _gecab)
		return nil, _fed.ErrTypeError
	}
	_cccde.Decode = _gdfcc
	if _cddab := _egade.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e"); _cddab != nil {
		_cccde.Function = []PdfFunction{}
		if _efaege, _gbgfa := _cddab.(*_fed.PdfObjectArray); _gbgfa {
			for _, _fbdec := range _efaege.Elements() {
				_dfeb, _bdege := _bggad(_fbdec)
				if _bdege != nil {
					_fef.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _bdege)
					return nil, _bdege
				}
				_cccde.Function = append(_cccde.Function, _dfeb)
			}
		} else {
			_cdgb, _aagac := _bggad(_cddab)
			if _aagac != nil {
				_fef.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _aagac)
				return nil, _aagac
			}
			_cccde.Function = append(_cccde.Function, _cdgb)
		}
	}
	return &_cccde, nil
}

// PdfColorspaceDeviceN represents a DeviceN color space. DeviceN color spaces are similar to Separation color
// spaces, except they can contain an arbitrary number of color components.
//
// Format: [/DeviceN names alternateSpace tintTransform]
//     or: [/DeviceN names alternateSpace tintTransform attributes]
type PdfColorspaceDeviceN struct {
	ColorantNames  *_fed.PdfObjectArray
	AlternateSpace PdfColorspace
	TintTransform  PdfFunction
	Attributes     *PdfColorspaceDeviceNAttributes
	_dfgaa         *_fed.PdfIndirectObject
}

// ToPdfObject implements interface PdfModel.
func (_eeca *PdfAnnotationWatermark) ToPdfObject() _fed.PdfObject {
	_eeca.PdfAnnotation.ToPdfObject()
	_dfcg := _eeca._ffaab
	_eadea := _dfcg.PdfObject.(*_fed.PdfObjectDictionary)
	_eadea.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u0057a\u0074\u0065\u0072\u006d\u0061\u0072k"))
	_eadea.SetIfNotNil("\u0046\u0069\u0078\u0065\u0064\u0050\u0072\u0069\u006e\u0074", _eeca.FixedPrint)
	return _dfcg
}
func (_bgda *PdfReader) newPdfAnnotationInkFromDict(_fbbe *_fed.PdfObjectDictionary) (*PdfAnnotationInk, error) {
	_cef := PdfAnnotationInk{}
	_cgg, _ccfcb := _bgda.newPdfAnnotationMarkupFromDict(_fbbe)
	if _ccfcb != nil {
		return nil, _ccfcb
	}
	_cef.PdfAnnotationMarkup = _cgg
	_cef.InkList = _fbbe.Get("\u0049n\u006b\u004c\u0069\u0073\u0074")
	_cef.BS = _fbbe.Get("\u0042\u0053")
	return &_cef, nil
}

// PdfFunctionType4 is a Postscript calculator functions.
type PdfFunctionType4 struct {
	Domain  []float64
	Range   []float64
	Program *_ed.PSProgram
	_dcga   *_ed.PSExecutor
	_gcdfd  []byte
	_ebcf   *_fed.PdfObjectStream
}

// PdfModel is a higher level PDF construct which can be collapsed into a PdfObject.
// Each PdfModel has an underlying PdfObject and vice versa (one-to-one).
// Under normal circumstances there should only be one copy of each.
// Copies can be made, but care must be taken to do it properly.
type PdfModel interface {
	ToPdfObject() _fed.PdfObject
	GetContainingPdfObject() _fed.PdfObject
}

// ToPdfObject recursively builds the Outline tree PDF object.
func (_ccdcb *PdfOutline) ToPdfObject() _fed.PdfObject {
	_cgef := _ccdcb._cbad
	_abaaa := _cgef.PdfObject.(*_fed.PdfObjectDictionary)
	_abaaa.Set("\u0054\u0079\u0070\u0065", _fed.MakeName("\u004f\u0075\u0074\u006c\u0069\u006e\u0065\u0073"))
	if _ccdcb.First != nil {
		_abaaa.Set("\u0046\u0069\u0072s\u0074", _ccdcb.First.ToPdfObject())
	}
	if _ccdcb.Last != nil {
		_abaaa.Set("\u004c\u0061\u0073\u0074", _ccdcb.Last.GetContext().GetContainingPdfObject())
	}
	if _ccdcb.Parent != nil {
		_abaaa.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _ccdcb.Parent.GetContext().GetContainingPdfObject())
	}
	if _ccdcb.Count != nil {
		_abaaa.Set("\u0043\u006f\u0075n\u0074", _fed.MakeInteger(*_ccdcb.Count))
	}
	return _cgef
}

// ColorToRGB only converts color used with uncolored patterns (defined in underlying colorspace).  Does not go into the
// pattern objects and convert those.  If that is desired, needs to be done separately.  See for example
// grayscale conversion example in unidoc-examples repo.
func (_cgaa *PdfColorspaceSpecialPattern) ColorToRGB(color PdfColor) (PdfColor, error) {
	_adadc, _bcgg := color.(*PdfColorPattern)
	if !_bcgg {
		_fef.Log.Debug("\u0043\u006f\u006c\u006f\u0072\u0020\u006e\u006f\u0074\u0020\u0070a\u0074\u0074\u0065\u0072\u006e\u0020\u0028\u0067\u006f\u0074 \u0025\u0054\u0029", color)
		return nil, ErrTypeCheck
	}
	if _adadc.Color == nil {
		return color, nil
	}
	if _cgaa.UnderlyingCS == nil {
		return nil, _bb.New("\u0075n\u0064\u0065\u0072\u006cy\u0069\u006e\u0067\u0020\u0043S\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d")
	}
	return _cgaa.UnderlyingCS.ColorToRGB(_adadc.Color)
}
func _bcdb(_fbgcbd []byte) bool {
	if len(_fbgcbd) < 4 {
		return true
	}
	for _egace := range _fbgcbd[:4] {
		_bcgbg := rune(_egace)
		if !_ad.Is(_ad.ASCII_Hex_Digit, _bcgbg) && !_ad.IsSpace(_bcgbg) {
			return true
		}
	}
	return false
}

// UpdateXObjectImageFromImage creates a new XObject Image from an
// Image object `img` and default masks from xobjIn.
// The default masks are overridden if img.hasAlpha
// If `encoder` is nil, uses raw encoding (none).
func UpdateXObjectImageFromImage(xobjIn *XObjectImage, img *Image, cs PdfColorspace, encoder _fed.StreamEncoder) (*XObjectImage, error) {
	if encoder == nil {
		encoder = _fed.NewRawEncoder()
	}
	encoder.UpdateParams(img.GetParamsDict())
	_gbgdg, _abcae := encoder.EncodeBytes(img.Data)
	if _abcae != nil {
		_fef.Log.Debug("\u0045\u0072\u0072or\u0020\u0077\u0069\u0074\u0068\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0076", _abcae)
		return nil, _abcae
	}
	_cbgbd := NewXObjectImage()
	_gadcgb := img.Width
	_adcff := img.Height
	_cbgbd.Width = &_gadcgb
	_cbgbd.Height = &_adcff
	_dfaaae := img.BitsPerComponent
	_cbgbd.BitsPerComponent = &_dfaaae
	_cbgbd.Filter = encoder
	_cbgbd.Stream = _gbgdg
	if cs == nil {
		if img.ColorComponents == 1 {
			_cbgbd.ColorSpace = NewPdfColorspaceDeviceGray()
		} else if img.ColorComponents == 3 {
			_cbgbd.ColorSpace = NewPdfColorspaceDeviceRGB()
		} else if img.ColorComponents == 4 {
			_cbgbd.ColorSpace = NewPdfColorspaceDeviceCMYK()
		} else {
			return nil, _bb.New("c\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020u\u006e\u0064\u0065\u0066in\u0065\u0064")
		}
	} else {
		_cbgbd.ColorSpace = cs
	}
	if len(img._caeaf) != 0 {
		_bffgd := NewXObjectImage()
		_bffgd.Filter = encoder
		_egge, _gcdc := encoder.EncodeBytes(img._caeaf)
		if _gcdc != nil {
			_fef.Log.Debug("\u0045\u0072\u0072or\u0020\u0077\u0069\u0074\u0068\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0076", _gcdc)
			return nil, _gcdc
		}
		_bffgd.Stream = _egge
		_bffgd.BitsPerComponent = _cbgbd.BitsPerComponent
		_bffgd.Width = &img.Width
		_bffgd.Height = &img.Height
		_bffgd.ColorSpace = NewPdfColorspaceDeviceGray()
		_cbgbd.SMask = _bffgd.ToPdfObject()
	} else {
		_cbgbd.SMask = xobjIn.SMask
		_cbgbd.ImageMask = xobjIn.ImageMask
		if _cbgbd.ColorSpace.GetNumComponents() == 1 {
			_cbgab(_cbgbd)
		}
	}
	return _cbgbd, nil
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain three elements representing the
// A, B and C components of the color. The values of the elements should be
// between 0 and 1.
func (_acad *PdfColorspaceCalRGB) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 3 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_ccffg := vals[0]
	if _ccffg < 0.0 || _ccffg > 1.0 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_cbca := vals[1]
	if _cbca < 0.0 || _cbca > 1.0 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_ffed := vals[2]
	if _ffed < 0.0 || _ffed > 1.0 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_abeg := NewPdfColorCalRGB(_ccffg, _cbca, _ffed)
	return _abeg, nil
}

// GetNumComponents returns the number of color components (3 for CalRGB).
func (_dgafc *PdfColorCalRGB) GetNumComponents() int { return 3 }

var (
	CourierName              = _geg.CourierName
	CourierBoldName          = _geg.CourierBoldName
	CourierObliqueName       = _geg.CourierObliqueName
	CourierBoldObliqueName   = _geg.CourierBoldObliqueName
	HelveticaName            = _geg.HelveticaName
	HelveticaBoldName        = _geg.HelveticaBoldName
	HelveticaObliqueName     = _geg.HelveticaObliqueName
	HelveticaBoldObliqueName = _geg.HelveticaBoldObliqueName
	SymbolName               = _geg.SymbolName
	ZapfDingbatsName         = _geg.ZapfDingbatsName
	TimesRomanName           = _geg.TimesRomanName
	TimesBoldName            = _geg.TimesBoldName
	TimesItalicName          = _geg.TimesItalicName
	TimesBoldItalicName      = _geg.TimesBoldItalicName
)

// ContentStreamWrapper wraps the Page's contentstream into q ... Q blocks.
type ContentStreamWrapper interface{ WrapContentStream(_edde *PdfPage) error }

func _dcca(_bedee _fed.PdfObject) (*PdfShading, error) {
	_afdac := &PdfShading{}
	var _fgfae *_fed.PdfObjectDictionary
	if _ddabd, _acbca := _fed.GetIndirect(_bedee); _acbca {
		_afdac._cdcge = _ddabd
		_dcacf, _bcag := _ddabd.PdfObject.(*_fed.PdfObjectDictionary)
		if !_bcag {
			_fef.Log.Debug("\u004f\u0062\u006a\u0065c\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069c\u0074i\u006f\u006e\u0061\u0072\u0079\u0020\u0074y\u0070\u0065")
			return nil, _fed.ErrTypeError
		}
		_fgfae = _dcacf
	} else if _gface, _ecdfc := _fed.GetStream(_bedee); _ecdfc {
		_afdac._cdcge = _gface
		_fgfae = _gface.PdfObjectDictionary
	} else if _ggcfb, _ffaed := _fed.GetDict(_bedee); _ffaed {
		_afdac._cdcge = _ggcfb
		_fgfae = _ggcfb
	} else {
		_fef.Log.Debug("O\u0062\u006a\u0065\u0063\u0074\u0020t\u0079\u0070\u0065\u0020\u0075\u006e\u0065\u0078\u0070e\u0063\u0074\u0065d\u0020(\u0025\u0054\u0029", _bedee)
		return nil, _fed.ErrTypeError
	}
	if _fgfae == nil {
		_fef.Log.Debug("\u0044i\u0063t\u0069\u006f\u006e\u0061\u0072y\u0020\u006di\u0073\u0073\u0069\u006e\u0067")
		return nil, _bb.New("\u0064\u0069\u0063t\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
	}
	_bedee = _fgfae.Get("S\u0068\u0061\u0064\u0069\u006e\u0067\u0054\u0079\u0070\u0065")
	if _bedee == nil {
		_fef.Log.Debug("\u0052\u0065q\u0075\u0069\u0072\u0065\u0064\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0079\u0070\u0065\u0020\u006d\u0069\u0073si\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_bedee = _fed.TraceToDirectObject(_bedee)
	_effff, _daff := _bedee.(*_fed.PdfObjectInteger)
	if !_daff {
		_fef.Log.Debug("\u0049\u006e\u0076al\u0069\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0066o\u0072 \u0073h\u0061d\u0069\u006e\u0067\u0020\u0074\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029", _bedee)
		return nil, _fed.ErrTypeError
	}
	if *_effff < 1 || *_effff > 7 {
		_fef.Log.Debug("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0079\u0070\u0065\u002c\u0020\u006e\u006ft\u0020\u0031\u002d\u0037\u0020(\u0067\u006ft\u0020\u0025\u0064\u0029", *_effff)
		return nil, _fed.ErrTypeError
	}
	_afdac.ShadingType = _effff
	_bedee = _fgfae.Get("\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065")
	if _bedee == nil {
		_fef.Log.Debug("\u0052\u0065\u0071\u0075\u0069\u0072e\u0064\u0020\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065\u0020e\u006e\u0074\u0072\u0079\u0020\u006d\u0069s\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_gccfa, _fadc := NewPdfColorspaceFromPdfObject(_bedee)
	if _fadc != nil {
		_fef.Log.Debug("\u0046\u0061i\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065: \u0025\u0076", _fadc)
		return nil, _fadc
	}
	_afdac.ColorSpace = _gccfa
	_bedee = _fgfae.Get("\u0042\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064")
	if _bedee != nil {
		_bedee = _fed.TraceToDirectObject(_bedee)
		_cagg, _bagf := _bedee.(*_fed.PdfObjectArray)
		if !_bagf {
			_fef.Log.Debug("\u0042\u0061\u0063\u006b\u0067r\u006f\u0075\u006e\u0064\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062e\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u0020\u0062\u0079\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054)", _bedee)
			return nil, _fed.ErrTypeError
		}
		_afdac.Background = _cagg
	}
	_bedee = _fgfae.Get("\u0042\u0042\u006f\u0078")
	if _bedee != nil {
		_bedee = _fed.TraceToDirectObject(_bedee)
		_afaec, _aabga := _bedee.(*_fed.PdfObjectArray)
		if !_aabga {
			_fef.Log.Debug("\u0042\u0061\u0063\u006b\u0067r\u006f\u0075\u006e\u0064\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062e\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u0020\u0062\u0079\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054)", _bedee)
			return nil, _fed.ErrTypeError
		}
		_gafcf, _bcefc := NewPdfRectangle(*_afaec)
		if _bcefc != nil {
			_fef.Log.Debug("\u0042\u0042\u006f\u0078\u0020\u0065\u0072\u0072\u006fr\u003a\u0020\u0025\u0076", _bcefc)
			return nil, _bcefc
		}
		_afdac.BBox = _gafcf
	}
	_bedee = _fgfae.Get("\u0041n\u0074\u0069\u0041\u006c\u0069\u0061s")
	if _bedee != nil {
		_bedee = _fed.TraceToDirectObject(_bedee)
		_fgab, _affbd := _bedee.(*_fed.PdfObjectBool)
		if !_affbd {
			_fef.Log.Debug("A\u006e\u0074\u0069\u0041\u006c\u0069\u0061\u0073\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020ty\u0070\u0065\u002c\u0020s\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020bo\u006f\u006c \u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _bedee)
			return nil, _fed.ErrTypeError
		}
		_afdac.AntiAlias = _fgab
	}
	switch *_effff {
	case 1:
		_efgdf, _cedba := _fagef(_fgfae)
		if _cedba != nil {
			return nil, _cedba
		}
		_efgdf.PdfShading = _afdac
		_afdac._cebded = _efgdf
		return _afdac, nil
	case 2:
		_cbegf, _cgedg := _gbcga(_fgfae)
		if _cgedg != nil {
			return nil, _cgedg
		}
		_cbegf.PdfShading = _afdac
		_afdac._cebded = _cbegf
		return _afdac, nil
	case 3:
		_egce, _ecdfce := _cagff(_fgfae)
		if _ecdfce != nil {
			return nil, _ecdfce
		}
		_egce.PdfShading = _afdac
		_afdac._cebded = _egce
		return _afdac, nil
	case 4:
		_cfcac, _ccebe := _cgafc(_fgfae)
		if _ccebe != nil {
			return nil, _ccebe
		}
		_cfcac.PdfShading = _afdac
		_afdac._cebded = _cfcac
		return _afdac, nil
	case 5:
		_gggbe, _caage := _gegad(_fgfae)
		if _caage != nil {
			return nil, _caage
		}
		_gggbe.PdfShading = _afdac
		_afdac._cebded = _gggbe
		return _afdac, nil
	case 6:
		_bged, _ebfab := _badef(_fgfae)
		if _ebfab != nil {
			return nil, _ebfab
		}
		_bged.PdfShading = _afdac
		_afdac._cebded = _bged
		return _afdac, nil
	case 7:
		_fgfc, _ebgb := _bgcca(_fgfae)
		if _ebgb != nil {
			return nil, _ebgb
		}
		_fgfc.PdfShading = _afdac
		_afdac._cebded = _fgfc
		return _afdac, nil
	}
	return nil, _bb.New("u\u006ek\u006e\u006f\u0077\u006e\u0020\u0073\u0068\u0061d\u0069\u006e\u0067\u0020ty\u0070\u0065")
}

// Width returns the width of `rect`.
func (_bdebg *PdfRectangle) Width() float64 { return _bg.Abs(_bdebg.Urx - _bdebg.Llx) }

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// component PDF objects.
func (_cdedb *PdfColorspaceICCBased) ColorFromPdfObjects(objects []_fed.PdfObject) (PdfColor, error) {
	if _cdedb.Alternate == nil {
		if _cdedb.N == 1 {
			_eba := NewPdfColorspaceDeviceGray()
			return _eba.ColorFromPdfObjects(objects)
		} else if _cdedb.N == 3 {
			_fda := NewPdfColorspaceDeviceRGB()
			return _fda.ColorFromPdfObjects(objects)
		} else if _cdedb.N == 4 {
			_efcf := NewPdfColorspaceDeviceCMYK()
			return _efcf.ColorFromPdfObjects(objects)
		} else {
			return nil, _bb.New("I\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061lt\u0065\u0072\u006ea\u0074i\u0076\u0065")
		}
	}
	return _cdedb.Alternate.ColorFromPdfObjects(objects)
}

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_ccfge *PdfWriter) SetOptimizer(optimizer Optimizer) { _ccfge._ggfgb = optimizer }
func (_fbgge *PdfReader) newPdfAcroFormFromDict(_cage *_fed.PdfIndirectObject, _eacdf *_fed.PdfObjectDictionary) (*PdfAcroForm, error) {
	_feedf := NewPdfAcroForm()
	if _cage != nil {
		_feedf._ceed = _cage
		_cage.PdfObject = _fed.MakeDict()
	}
	if _gdgfd := _eacdf.Get("\u0046\u0069\u0065\u006c\u0064\u0073"); _gdgfd != nil {
		_gfaaf, _dedeb := _fed.GetArray(_gdgfd)
		if !_dedeb {
			return nil, _d.Errorf("\u0066i\u0065\u006c\u0064\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u006e \u0061\u0072\u0072\u0061\u0079\u0020\u0028\u0025\u0054\u0029", _gdgfd)
		}
		var _aegb []*PdfField
		for _, _ccbag := range _gfaaf.Elements() {
			_bbfc, _cbefff := _fed.GetIndirect(_ccbag)
			if !_cbefff {
				if _, _dgccg := _ccbag.(*_fed.PdfObjectNull); _dgccg {
					_fef.Log.Trace("\u0053k\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u006f\u0076\u0065\u0072 \u006e\u0075\u006c\u006c\u0020\u0066\u0069\u0065\u006c\u0064")
					continue
				}
				_fef.Log.Debug("\u0046\u0069\u0065\u006c\u0064 \u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0064 \u0069\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0025\u0054", _ccbag)
				return nil, _d.Errorf("\u0066\u0069\u0065l\u0064\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u006e\u0020i\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
			}
			_bgdag, _gcafa := _fbgge.newPdfFieldFromIndirectObject(_bbfc, nil)
			if _gcafa != nil {
				return nil, _gcafa
			}
			_fef.Log.Trace("\u0041\u0063\u0072\u006fFo\u0072\u006d\u0020\u0046\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u002b\u0076", *_bgdag)
			_aegb = append(_aegb, _bgdag)
		}
		_feedf.Fields = &_aegb
	}
	if _cddd := _eacdf.Get("\u004ee\u0065d\u0041\u0070\u0070\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0073"); _cddd != nil {
		_gdecd, _agedd := _fed.GetBool(_cddd)
		if _agedd {
			_feedf.NeedAppearances = _gdecd
		} else {
			_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004e\u0065\u0065\u0064\u0041\u0070p\u0065\u0061\u0072\u0061\u006e\u0063e\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0067\u006ft\u0020\u0025\u0054\u0029", _cddd)
		}
	}
	if _cbcdd := _eacdf.Get("\u0053\u0069\u0067\u0046\u006c\u0061\u0067\u0073"); _cbcdd != nil {
		_fagee, _ffgcf := _fed.GetInt(_cbcdd)
		if _ffgcf {
			_feedf.SigFlags = _fagee
		} else {
			_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0053\u0069\u0067\u0046\u006c\u0061\u0067\u0073 \u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _cbcdd)
		}
	}
	if _gdcd := _eacdf.Get("\u0043\u004f"); _gdcd != nil {
		_bffg, _affa := _fed.GetArray(_gdcd)
		if _affa {
			_feedf.CO = _bffg
		} else {
			_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u004f\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0067\u006f\u0074 \u0025\u0054\u0029", _gdcd)
		}
	}
	if _bcaaa := _eacdf.Get("\u0044\u0052"); _bcaaa != nil {
		if _ffeggb, _bbgec := _fed.GetDict(_bcaaa); _bbgec {
			_agddc, _adaae := NewPdfPageResourcesFromDict(_ffeggb)
			if _adaae != nil {
				_fef.Log.Error("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0044R\u003a\u0020\u0025\u0076", _adaae)
				return nil, _adaae
			}
			_feedf.DR = _agddc
		} else {
			_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0044\u0052\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0067\u006f\u0074 \u0025\u0054\u0029", _bcaaa)
		}
	}
	if _cedbd := _eacdf.Get("\u0044\u0041"); _cedbd != nil {
		_adbb, _ggcba := _fed.GetString(_cedbd)
		if _ggcba {
			_feedf.DA = _adbb
		} else {
			_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0044\u0041\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0067\u006f\u0074 \u0025\u0054\u0029", _cedbd)
		}
	}
	if _bddg := _eacdf.Get("\u0051"); _bddg != nil {
		_gdgeac, _gbcaa := _fed.GetInt(_bddg)
		if _gbcaa {
			_feedf.Q = _gdgeac
		} else {
			_fef.Log.Debug("\u0045R\u0052\u004f\u0052\u003a \u0051\u0020\u0069\u006e\u0076a\u006ci\u0064 \u0028\u0067\u006f\u0074\u0020\u0025\u0054)", _bddg)
		}
	}
	if _becdg := _eacdf.Get("\u0058\u0046\u0041"); _becdg != nil {
		_feedf.XFA = _becdg
	}
	_feedf.ToPdfObject()
	return _feedf, nil
}

// GetContainingPdfObject implements interface PdfModel.
func (_cfdcc *PdfSignature) GetContainingPdfObject() _fed.PdfObject { return _cfdcc._gccdf }
func _aabcd() string                                                { return _fef.Version }
func _addb(_eafc _fed.PdfObject) (*PdfColorspaceICCBased, error) {
	_dgfb := &PdfColorspaceICCBased{}
	if _bfbda, _efce := _eafc.(*_fed.PdfIndirectObject); _efce {
		_dgfb._caga = _bfbda
	}
	_eafc = _fed.TraceToDirectObject(_eafc)
	_bbad, _aace := _eafc.(*_fed.PdfObjectArray)
	if !_aace {
		return nil, _d.Errorf("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _bbad.Len() != 2 {
		return nil, _d.Errorf("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064\u0020c\u006f\u006c\u006fr\u0073p\u0061\u0063\u0065")
	}
	_eafc = _fed.TraceToDirectObject(_bbad.Get(0))
	_gfcba, _aace := _eafc.(*_fed.PdfObjectName)
	if !_aace {
		return nil, _d.Errorf("\u0049\u0043\u0043B\u0061\u0073\u0065\u0064 \u006e\u0061\u006d\u0065\u0020\u006e\u006ft\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
	}
	if *_gfcba != "\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064" {
		return nil, _d.Errorf("\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0049\u0043\u0043\u0042a\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073p\u0061\u0063\u0065")
	}
	_eafc = _bbad.Get(1)
	_eegg, _aace := _fed.GetStream(_eafc)
	if !_aace {
		_fef.Log.Error("I\u0043\u0043\u0042\u0061\u0073\u0065d\u0020\u006e\u006f\u0074\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067\u0020t\u006f\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020%\u0054", _eafc)
		return nil, _d.Errorf("\u0049\u0043\u0043Ba\u0073\u0065\u0064\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064")
	}
	_fffg := _eegg.PdfObjectDictionary
	_aegg, _aace := _fffg.Get("\u004e").(*_fed.PdfObjectInteger)
	if !_aace {
		return nil, _d.Errorf("I\u0043\u0043\u0042\u0061\u0073\u0065d\u0020\u006d\u0069\u0073\u0073\u0069n\u0067\u0020\u004e\u0020\u0066\u0072\u006fm\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074")
	}
	if *_aegg != 1 && *_aegg != 3 && *_aegg != 4 {
		return nil, _d.Errorf("\u0049\u0043\u0043\u0042\u0061s\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065 \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020\u0028\u006e\u006f\u0074\u0020\u0031\u002c\u0033\u002c\u0034\u0029")
	}
	_dgfb.N = int(*_aegg)
	if _ffea := _fffg.Get("\u0041l\u0074\u0065\u0072\u006e\u0061\u0074e"); _ffea != nil {
		_adad, _gbfa := NewPdfColorspaceFromPdfObject(_ffea)
		if _gbfa != nil {
			return nil, _gbfa
		}
		_dgfb.Alternate = _adad
	}
	if _geag := _fffg.Get("\u0052\u0061\u006eg\u0065"); _geag != nil {
		_geag = _fed.TraceToDirectObject(_geag)
		_cgbdf, _abcfc := _geag.(*_fed.PdfObjectArray)
		if !_abcfc {
			return nil, _d.Errorf("I\u0043\u0043\u0042\u0061\u0073\u0065d\u0020\u0052\u0061\u006e\u0067\u0065\u0020\u006e\u006ft\u0020\u0061\u006e \u0061r\u0072\u0061\u0079")
		}
		if _cgbdf.Len() != 2*_dgfb.N {
			return nil, _d.Errorf("\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064\u0020\u0052\u0061\u006e\u0067e\u0020\u0077\u0072\u006f\u006e\u0067 \u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0065\u006c\u0065m\u0065\u006e\u0074\u0073")
		}
		_bcaa, _dcaf := _cgbdf.GetAsFloat64Slice()
		if _dcaf != nil {
			return nil, _dcaf
		}
		_dgfb.Range = _bcaa
	} else {
		_dgfb.Range = make([]float64, 2*_dgfb.N)
		for _gagec := 0; _gagec < _dgfb.N; _gagec++ {
			_dgfb.Range[2*_gagec] = 0.0
			_dgfb.Range[2*_gagec+1] = 1.0
		}
	}
	if _bbcb := _fffg.Get("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061"); _bbcb != nil {
		_acbcb, _cgda := _bbcb.(*_fed.PdfObjectStream)
		if !_cgda {
			return nil, _d.Errorf("\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064\u0020\u004de\u0074\u0061\u0064\u0061\u0074\u0061\u0020n\u006f\u0074\u0020\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d")
		}
		_dgfb.Metadata = _acbcb
	}
	_egcaa, _gaed := _fed.DecodeStream(_eegg)
	if _gaed != nil {
		return nil, _gaed
	}
	_dgfb.Data = _egcaa
	_dgfb._dceb = _eegg
	return _dgfb, nil
}

// Register registers (caches) a model to primitive object relationship.
func (_dfefc *modelManager) Register(primitive _fed.PdfObject, model PdfModel) {
	_dfefc._efad[model] = primitive
	_dfefc._dded[primitive] = model
}

// PdfAnnotation represents an annotation in PDF (section 12.5 p. 389).
type PdfAnnotation struct {
	_adc         PdfModel
	Rect         _fed.PdfObject
	Contents     _fed.PdfObject
	P            _fed.PdfObject
	NM           _fed.PdfObject
	M            _fed.PdfObject
	F            _fed.PdfObject
	AP           _fed.PdfObject
	AS           _fed.PdfObject
	Border       _fed.PdfObject
	C            _fed.PdfObject
	StructParent _fed.PdfObject
	OC           _fed.PdfObject
	_ffaab       *_fed.PdfIndirectObject
}

// PdfFunction interface represents the common methods of a function in PDF.
type PdfFunction interface {
	Evaluate([]float64) ([]float64, error)
	ToPdfObject() _fed.PdfObject
}

// PdfOutlineTreeNode contains common fields used by the outline and outline
// item objects.
type PdfOutlineTreeNode struct {
	_ffgd interface{}
	First *PdfOutlineTreeNode
	Last  *PdfOutlineTreeNode
}

// GetContainingPdfObject returns the container of the resources object (indirect object).
func (_gdae *PdfPageResources) GetContainingPdfObject() _fed.PdfObject { return _gdae._fcdee }
func _gccb(_gbac, _bbgd string) string {
	if _eed.Contains(_gbac, "\u002b") {
		_dgge := _eed.Split(_gbac, "\u002b")
		if len(_dgge) == 2 {
			_gbac = _dgge[1]
		}
	}
	return _bbgd + "\u002b" + _gbac
}

// ToPdfObject implements interface PdfModel.
func (_aac *PdfActionRendition) ToPdfObject() _fed.PdfObject {
	_aac.PdfAction.ToPdfObject()
	_dac := _aac._fa
	_cdec := _dac.PdfObject.(*_fed.PdfObjectDictionary)
	_cdec.SetIfNotNil("\u0053", _fed.MakeName(string(ActionTypeRendition)))
	_cdec.SetIfNotNil("\u0052", _aac.R)
	_cdec.SetIfNotNil("\u0041\u004e", _aac.AN)
	_cdec.SetIfNotNil("\u004f\u0050", _aac.OP)
	_cdec.SetIfNotNil("\u004a\u0053", _aac.JS)
	return _dac
}

// Encoder returns the font's text encoder.
func (_gega pdfCIDFontType2) Encoder() _dg.TextEncoder { return _gega._gggce }

// GetRuneMetrics returns the character metrics for the specified rune.
// A bool flag is returned to indicate whether or not the entry was found.
func (_eefb pdfCIDFontType2) GetRuneMetrics(r rune) (_geg.CharMetrics, bool) {
	_cggcc, _gcbc := _eefb._bbff[r]
	if !_gcbc {
		_dddead, _facg := _fed.GetInt(_eefb.DW)
		if !_facg {
			return _geg.CharMetrics{}, false
		}
		_cggcc = int(*_dddead)
	}
	return _geg.CharMetrics{Wx: float64(_cggcc)}, true
}

// NewPdfActionTrans returns a new "trans" action.
func NewPdfActionTrans() *PdfActionTrans {
	_adb := NewPdfAction()
	_dgg := &PdfActionTrans{}
	_dgg.PdfAction = _adb
	_adb.SetContext(_dgg)
	return _dgg
}

// NewPdfAnnotationSound returns a new sound annotation.
func NewPdfAnnotationSound() *PdfAnnotationSound {
	_ffgg := NewPdfAnnotation()
	_ceb := &PdfAnnotationSound{}
	_ceb.PdfAnnotation = _ffgg
	_ceb.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_ffgg.SetContext(_ceb)
	return _ceb
}

// NewPdfWriter initializes a new PdfWriter.
func NewPdfWriter() PdfWriter {
	_dfgd := PdfWriter{}
	_dfgd._bdadf = map[_fed.PdfObject]struct{}{}
	_dfgd._gcbcf = []_fed.PdfObject{}
	_dfgd._affff = map[_fed.PdfObject][]*_fed.PdfObjectDictionary{}
	_dfgd._fefab = map[_fed.PdfObject]struct{}{}
	_dfgd._gbgag = 1
	_dfgd._cccf = 3
	_aedgeb := _fed.MakeDict()
	_eagf := []struct {
		_fdgaa _fed.PdfObjectName
		_cabde string
	}{{"\u0050\u0072\u006f\u0064\u0075\u0063\u0065\u0072", _abdga()}, {"\u0043r\u0065\u0061\u0074\u006f\u0072", _cabgbd()}, {"\u0041\u0075\u0074\u0068\u006f\u0072", _dfab()}, {"\u0053u\u0062\u006a\u0065\u0063\u0074", _gbbe()}, {"\u0054\u0069\u0074l\u0065", _caagg()}, {"\u004b\u0065\u0079\u0077\u006f\u0072\u0064\u0073", _deab()}}
	for _, _eagce := range _eagf {
		if _eagce._cabde != "" {
			_aedgeb.Set(_eagce._fdgaa, _fed.MakeString(_eagce._cabde))
		}
	}
	if _cbed := _gccda(); !_cbed.IsZero() {
		if _cgcbg, _ffcfg := NewPdfDateFromTime(_cbed); _ffcfg == nil {
			_aedgeb.Set("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065", _cgcbg.ToPdfObject())
		}
	}
	if _fdgaad := _gfec(); !_fdgaad.IsZero() {
		if _dbdfd, _edfeb := NewPdfDateFromTime(_fdgaad); _edfeb == nil {
			_aedgeb.Set("\u004do\u0064\u0044\u0061\u0074\u0065", _dbdfd.ToPdfObject())
		}
	}
	_gagab := _fed.PdfIndirectObject{}
	_gagab.PdfObject = _aedgeb
	_dfgd._egbgf = &_gagab
	_dfgd.addObject(&_gagab)
	_eabddf := _fed.PdfIndirectObject{}
	_dageb := _fed.MakeDict()
	_dageb.Set("\u0054\u0079\u0070\u0065", _fed.MakeName("\u0043a\u0074\u0061\u006c\u006f\u0067"))
	_eabddf.PdfObject = _dageb
	_dfgd._aeacb = &_eabddf
	_dfgd.addObject(_dfgd._aeacb)
	_faaea, _cdag := _bgdaa("\u0077")
	if _cdag != nil {
		_fef.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _cdag)
	}
	_dfgd._gdgg = _faaea
	_ggddg := _fed.PdfIndirectObject{}
	_gbade := _fed.MakeDict()
	_gbade.Set("\u0054\u0079\u0070\u0065", _fed.MakeName("\u0050\u0061\u0067e\u0073"))
	_gddecc := _fed.PdfObjectArray{}
	_gbade.Set("\u004b\u0069\u0064\u0073", &_gddecc)
	_gbade.Set("\u0043\u006f\u0075n\u0074", _fed.MakeInteger(0))
	_ggddg.PdfObject = _gbade
	_dfgd._eeafd = &_ggddg
	_dfgd._aadcf = map[_fed.PdfObject]struct{}{}
	_dfgd.addObject(_dfgd._eeafd)
	_dageb.Set("\u0050\u0061\u0067e\u0073", &_ggddg)
	_dfgd._cdefg = _dageb
	_fef.Log.Trace("\u0043\u0061\u0074\u0061\u006c\u006f\u0067\u0020\u0025\u0073", _eabddf)
	return _dfgd
}
func (_fad *PdfReader) newPdfActionSoundFromDict(_eedaf *_fed.PdfObjectDictionary) (*PdfActionSound, error) {
	return &PdfActionSound{Sound: _eedaf.Get("\u0053\u006f\u0075n\u0064"), Volume: _eedaf.Get("\u0056\u006f\u006c\u0075\u006d\u0065"), Synchronous: _eedaf.Get("S\u0079\u006e\u0063\u0068\u0072\u006f\u006e\u006f\u0075\u0073"), Repeat: _eedaf.Get("\u0052\u0065\u0070\u0065\u0061\u0074"), Mix: _eedaf.Get("\u004d\u0069\u0078")}, nil
}
func (_bfafd *pdfCIDFontType2) getFontDescriptor() *PdfFontDescriptor { return _bfafd._bgdgb }
func (_afgcf *fontFile) loadFromSegments(_agced, _febe []byte) error {
	_fef.Log.Trace("\u006c\u006f\u0061dF\u0072\u006f\u006d\u0053\u0065\u0067\u006d\u0065\u006e\u0074\u0073\u003a\u0020\u0025\u0064\u0020\u0025\u0064", len(_agced), len(_febe))
	_dgeg := _afgcf.parseASCIIPart(_agced)
	if _dgeg != nil {
		return _dgeg
	}
	_fef.Log.Trace("f\u006f\u006e\u0074\u0066\u0069\u006c\u0065\u003d\u0025\u0073", _afgcf)
	if len(_febe) == 0 {
		return nil
	}
	_fef.Log.Trace("f\u006f\u006e\u0074\u0066\u0069\u006c\u0065\u003d\u0025\u0073", _afgcf)
	return nil
}
func (_fcffdb *PdfWriter) addObject(_ebbe _fed.PdfObject) bool {
	_ggdce := _fcffdb.hasObject(_ebbe)
	if !_ggdce {
		_gcad := _fed.ResolveReferencesDeep(_ebbe, _fcffdb._fefab)
		if _gcad != nil {
			_fef.Log.Debug("E\u0052R\u004f\u0052\u003a\u0020\u0025\u0076\u0020\u002d \u0073\u006b\u0069\u0070pi\u006e\u0067", _gcad)
		}
		_fcffdb._gcbcf = append(_fcffdb._gcbcf, _ebbe)
		_fcffdb._bdadf[_ebbe] = struct{}{}
		return true
	}
	return false
}
func (_bdgg *PdfReader) newPdfAnnotationTextFromDict(_gbf *_fed.PdfObjectDictionary) (*PdfAnnotationText, error) {
	_adeg := PdfAnnotationText{}
	_gee, _dde := _bdgg.newPdfAnnotationMarkupFromDict(_gbf)
	if _dde != nil {
		return nil, _dde
	}
	_adeg.PdfAnnotationMarkup = _gee
	_adeg.Open = _gbf.Get("\u004f\u0070\u0065\u006e")
	_adeg.Name = _gbf.Get("\u004e\u0061\u006d\u0065")
	_adeg.State = _gbf.Get("\u0053\u0074\u0061t\u0065")
	_adeg.StateModel = _gbf.Get("\u0053\u0074\u0061\u0074\u0065\u004d\u006f\u0064\u0065\u006c")
	return &_adeg, nil
}

// GetPage returns the PdfPage model for the specified page number.
func (_eabdd *PdfReader) GetPage(pageNumber int) (*PdfPage, error) {
	if _eabdd._cdfggf.GetCrypter() != nil && !_eabdd._cdfggf.IsAuthenticated() {
		return nil, _d.Errorf("\u0066\u0069\u006c\u0065\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f\u0020\u0062e\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	}
	if len(_eabdd._gdac) < pageNumber {
		return nil, _bb.New("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0070\u0061\u0067\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0028\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0074o\u006f\u0020\u0073\u0068\u006f\u0072\u0074\u0029")
	}
	_cggf := pageNumber - 1
	if _cggf < 0 {
		return nil, _d.Errorf("\u0070\u0061\u0067\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0069\u006e\u0067\u0020\u006d\u0075\u0073t\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0061\u0074\u0020\u0031")
	}
	_acgacg := _eabdd.PageList[_cggf]
	return _acgacg, nil
}

// GetPageLabels returns the PageLabels entry in the PDF catalog.
// See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
func (_eegde *PdfReader) GetPageLabels() (_fed.PdfObject, error) {
	_eaaec := _fed.ResolveReference(_eegde._bfcdc.Get("\u0050\u0061\u0067\u0065\u004c\u0061\u0062\u0065\u006c\u0073"))
	if _eaaec == nil {
		return nil, nil
	}
	if !_eegde._bgbff {
		_eacag := _eegde.traverseObjectData(_eaaec)
		if _eacag != nil {
			return nil, _eacag
		}
	}
	return _eaaec, nil
}

// IsRadio returns true if the button field represents a radio button, false otherwise.
func (_aegd *PdfFieldButton) IsRadio() bool { return _aegd.GetType() == ButtonTypeRadio }

// ToPdfObject returns the PDF representation of the colorspace.
func (_gadca *PdfColorspaceSpecialSeparation) ToPdfObject() _fed.PdfObject {
	_cadf := _fed.MakeArray(_fed.MakeName("\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006f\u006e"))
	_cadf.Append(_gadca.ColorantName)
	_cadf.Append(_gadca.AlternateSpace.ToPdfObject())
	_cadf.Append(_gadca.TintTransform.ToPdfObject())
	if _gadca._fdffd != nil {
		_gadca._fdffd.PdfObject = _cadf
		return _gadca._fdffd
	}
	return _cadf
}
func (_agga *PdfAcroForm) filteredFields(_fcga FieldFilterFunc, _faba bool) []*PdfField {
	if _agga == nil {
		return nil
	}
	return _fcegc(_agga.Fields, _fcga, _faba)
}

// ToPdfObject implements interface PdfModel.
func (_dbc *PdfAnnotationSound) ToPdfObject() _fed.PdfObject {
	_dbc.PdfAnnotation.ToPdfObject()
	_gafc := _dbc._ffaab
	_acbb := _gafc.PdfObject.(*_fed.PdfObjectDictionary)
	_dbc.PdfAnnotationMarkup.appendToPdfDictionary(_acbb)
	_acbb.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u0053\u006f\u0075n\u0064"))
	_acbb.SetIfNotNil("\u0053\u006f\u0075n\u0064", _dbc.Sound)
	_acbb.SetIfNotNil("\u004e\u0061\u006d\u0065", _dbc.Name)
	return _gafc
}
func (_acec *pdfCIDFontType0) getFontDescriptor() *PdfFontDescriptor { return _acec._bgdgb }

// NewPdfAppender creates a new Pdf appender from a Pdf reader.
func NewPdfAppender(reader *PdfReader) (*PdfAppender, error) {
	_cfg := &PdfAppender{_ffcf: reader._faefaf, Reader: reader, _cgbc: reader._cdfggf, _aded: reader._aaebc}
	_aacb, _efcg := _cfg._ffcf.Seek(0, _ge.SeekEnd)
	if _efcg != nil {
		return nil, _efcg
	}
	_cfg._edga = _aacb
	if _, _efcg = _cfg._ffcf.Seek(0, _ge.SeekStart); _efcg != nil {
		return nil, _efcg
	}
	_cfg._ccc, _efcg = NewPdfReader(_cfg._ffcf)
	if _efcg != nil {
		return nil, _efcg
	}
	for _, _egdc := range _cfg.Reader.GetObjectNums() {
		if _cfg._efed < _egdc {
			_cfg._efed = _egdc
		}
	}
	_cfg._cdga = _cfg._cgbc.GetXrefTable()
	_cfg._eaa = _cfg._cgbc.GetXrefOffset()
	_cfg._dce = append(_cfg._dce, _cfg._ccc.PageList...)
	_cfg._bcgf = make(map[_fed.PdfObject]struct{})
	_cfg._aebf = make(map[_fed.PdfObject]int64)
	_cfg._egga = make(map[_fed.PdfObject]struct{})
	_cfg._eae = _cfg._ccc.AcroForm
	_cfg._bcbe = _cfg._ccc.DSS
	return _cfg, nil
}

// PdfFieldSignature signature field represents digital signatures and optional data for authenticating
// the name of the signer and verifying document contents.
type PdfFieldSignature struct {
	*PdfField
	*PdfAnnotationWidget
	V    *PdfSignature
	Lock *_fed.PdfIndirectObject
	SV   *_fed.PdfIndirectObject
}

func _fedf(_ebgad _fed.PdfObject) []*_fed.PdfObjectStream {
	if _ebgad == nil {
		return nil
	}
	_beaa, _bgbga := _fed.GetArray(_ebgad)
	if !_bgbga || _beaa.Len() == 0 {
		return nil
	}
	_debbb := make([]*_fed.PdfObjectStream, 0, _beaa.Len())
	for _, _gcceef := range _beaa.Elements() {
		if _cacf, _acgdc := _fed.GetStream(_gcceef); _acgdc {
			_debbb = append(_debbb, _cacf)
		}
	}
	return _debbb
}

// SetAnnotations sets the annotations list.
func (_geefd *PdfPage) SetAnnotations(annotations []*PdfAnnotation) { _geefd._abcb = annotations }

// IsCID returns true if the underlying font is CID.
func (_efec *PdfFont) IsCID() bool { return _efec.baseFields().isCIDFont() }
func _eec(_egb _fed.PdfObject) (*PdfFilespec, error) {
	if _egb == nil {
		return nil, nil
	}
	return NewPdfFilespecFromObj(_egb)
}
func _bgdab(_ggfgf _fed.PdfObject) (*PdfFunctionType3, error) {
	_beeb := &PdfFunctionType3{}
	var _edfg *_fed.PdfObjectDictionary
	if _fceaf, _eabe := _ggfgf.(*_fed.PdfIndirectObject); _eabe {
		_cged, _baeea := _fceaf.PdfObject.(*_fed.PdfObjectDictionary)
		if !_baeea {
			return nil, _bb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_beeb._dfeeb = _fceaf
		_edfg = _cged
	} else if _fcafg, _dfeebe := _ggfgf.(*_fed.PdfObjectDictionary); _dfeebe {
		_edfg = _fcafg
	} else {
		return nil, _bb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_bbfa, _efcbc := _fed.TraceToDirectObject(_edfg.Get("\u0044\u006f\u006d\u0061\u0069\u006e")).(*_fed.PdfObjectArray)
	if !_efcbc {
		_fef.Log.Error("D\u006fm\u0061\u0069\u006e\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063\u0069fi\u0065\u0064")
		return nil, _bb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if _bbfa.Len() != 2 {
		_fef.Log.Error("\u0044\u006f\u006d\u0061\u0069\u006e\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
		return nil, _bb.New("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0064\u006f\u006da\u0069\u006e\u0020\u0072an\u0067\u0065")
	}
	_agee, _edeed := _bbfa.ToFloat64Array()
	if _edeed != nil {
		return nil, _edeed
	}
	_beeb.Domain = _agee
	_bbfa, _efcbc = _fed.TraceToDirectObject(_edfg.Get("\u0052\u0061\u006eg\u0065")).(*_fed.PdfObjectArray)
	if _efcbc {
		if _bbfa.Len() < 0 || _bbfa.Len()%2 != 0 {
			return nil, _bb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0061\u006e\u0067\u0065")
		}
		_gcge, _afcae := _bbfa.ToFloat64Array()
		if _afcae != nil {
			return nil, _afcae
		}
		_beeb.Range = _gcge
	}
	_bbfa, _efcbc = _fed.TraceToDirectObject(_edfg.Get("\u0046u\u006e\u0063\u0074\u0069\u006f\u006es")).(*_fed.PdfObjectArray)
	if !_efcbc {
		_fef.Log.Error("\u0046\u0075\u006ect\u0069\u006f\u006e\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064")
		return nil, _bb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	_beeb.Functions = []PdfFunction{}
	for _, _faac := range _bbfa.Elements() {
		_gbde, _gaca := _bggad(_faac)
		if _gaca != nil {
			return nil, _gaca
		}
		_beeb.Functions = append(_beeb.Functions, _gbde)
	}
	_bbfa, _efcbc = _fed.TraceToDirectObject(_edfg.Get("\u0042\u006f\u0075\u006e\u0064\u0073")).(*_fed.PdfObjectArray)
	if !_efcbc {
		_fef.Log.Error("B\u006fu\u006e\u0064\u0073\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063\u0069fi\u0065\u0064")
		return nil, _bb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	_fdeg, _edeed := _bbfa.ToFloat64Array()
	if _edeed != nil {
		return nil, _edeed
	}
	_beeb.Bounds = _fdeg
	if len(_beeb.Bounds) != len(_beeb.Functions)-1 {
		_fef.Log.Error("B\u006f\u0075\u006e\u0064\u0073\u0020\u0028\u0025\u0064)\u0020\u0061\u006e\u0064\u0020\u006e\u0075m \u0066\u0075\u006e\u0063t\u0069\u006f\u006e\u0073\u0020\u0028\u0025\u0064\u0029 n\u006f\u0074 \u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067", len(_beeb.Bounds), len(_beeb.Functions))
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_bbfa, _efcbc = _fed.TraceToDirectObject(_edfg.Get("\u0045\u006e\u0063\u006f\u0064\u0065")).(*_fed.PdfObjectArray)
	if !_efcbc {
		_fef.Log.Error("E\u006ec\u006f\u0064\u0065\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063\u0069fi\u0065\u0064")
		return nil, _bb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	_beag, _edeed := _bbfa.ToFloat64Array()
	if _edeed != nil {
		return nil, _edeed
	}
	_beeb.Encode = _beag
	if len(_beeb.Encode) != 2*len(_beeb.Functions) {
		_fef.Log.Error("\u004c\u0065\u006e\u0020\u0065\u006e\u0063\u006f\u0064\u0065\u0020\u0028\u0025\u0064\u0029 \u0061\u006e\u0064\u0020\u006e\u0075\u006d\u0020\u0066\u0075\u006e\u0063\u0074i\u006f\u006e\u0073\u0020\u0028\u0025\u0064\u0029\u0020\u006e\u006f\u0074 m\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u0075\u0070", len(_beeb.Encode), len(_beeb.Functions))
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	return _beeb, nil
}

// GetAsTilingPattern returns a tiling pattern. Check with IsTiling() prior to using this.
func (_bgefc *PdfPattern) GetAsTilingPattern() *PdfTilingPattern {
	return _bgefc._ggadg.(*PdfTilingPattern)
}
func (_bfcd *PdfReader) loadAction(_egea _fed.PdfObject) (*PdfAction, error) {
	if _edce, _adcd := _fed.GetIndirect(_egea); _adcd {
		_cdg, _gdb := _bfcd.newPdfActionFromIndirectObject(_edce)
		if _gdb != nil {
			return nil, _gdb
		}
		return _cdg, nil
	} else if !_fed.IsNullObject(_egea) {
		return nil, _bb.New("\u0061\u0063\u0074\u0069\u006fn\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0070\u006f\u0069\u006e\u0074 \u0074\u006f\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
	}
	return nil, nil
}

// WatermarkImageOptions contains options for configuring the watermark process.
type WatermarkImageOptions struct {
	Alpha               float64
	FitToWidth          bool
	PreserveAspectRatio bool
}

// ImageToGray returns a new grayscale image based on the passed in RGB image.
func (_cggb *PdfColorspaceDeviceRGB) ImageToGray(img Image) (Image, error) {
	if img.ColorComponents != 3 {
		return img, _bb.New("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0061\u0020\u0044\u0065\u0076\u0069c\u0065\u0052\u0047\u0042")
	}
	_fdfg, _eeab := _eede.NewImage(int(img.Width), int(img.Height), int(img.BitsPerComponent), img.ColorComponents, img.Data, img._caeaf, img._ccdge)
	if _eeab != nil {
		return img, _eeab
	}
	_cbaa, _eeab := _eede.GrayConverter.Convert(_fdfg)
	if _eeab != nil {
		return img, _eeab
	}
	return _ddbab(_cbaa.Base()), nil
}

// NewPdfColorspaceDeviceCMYK returns a new CMYK32 colorspace object.
func NewPdfColorspaceDeviceCMYK() *PdfColorspaceDeviceCMYK { return &PdfColorspaceDeviceCMYK{} }

// NewPdfDateFromTime will create a PdfDate based on the given time
func NewPdfDateFromTime(timeObj _e.Time) (PdfDate, error) {
	_ecebf := timeObj.Format("\u002d\u0030\u0037\u003a\u0030\u0030")
	_egae, _ := _ba.ParseInt(_ecebf[1:3], 10, 32)
	_eaaeb, _ := _ba.ParseInt(_ecebf[4:6], 10, 32)
	return PdfDate{_abaff: int64(timeObj.Year()), _beaeg: int64(timeObj.Month()), _dcbg: int64(timeObj.Day()), _gdcccg: int64(timeObj.Hour()), _dbgdd: int64(timeObj.Minute()), _eaec: int64(timeObj.Second()), _caaae: _ecebf[0], _ecgbg: _egae, _aabea: _eaaeb}, nil
}
func (_dbd *PdfColorspaceLab) String() string { return "\u004c\u0061\u0062" }
func (_cbbef *PdfWriter) seekByName(_aedac _fed.PdfObject, _eadcd []string, _aabb string) ([]_fed.PdfObject, error) {
	_fef.Log.Trace("\u0053\u0065\u0065\u006b\u0020\u0062\u0079\u0020\u006e\u0061\u006d\u0065.\u002e\u0020\u0025\u0054", _aedac)
	var _ebaca []_fed.PdfObject
	if _ecgcb, _bdbcdc := _aedac.(*_fed.PdfIndirectObject); _bdbcdc {
		return _cbbef.seekByName(_ecgcb.PdfObject, _eadcd, _aabb)
	}
	if _adccc, _cgga := _aedac.(*_fed.PdfObjectStream); _cgga {
		return _cbbef.seekByName(_adccc.PdfObjectDictionary, _eadcd, _aabb)
	}
	if _edgda, _aadca := _aedac.(*_fed.PdfObjectDictionary); _aadca {
		_fef.Log.Trace("\u0044\u0069\u0063\u0074")
		for _, _ebeac := range _edgda.Keys() {
			_dcfag := _edgda.Get(_ebeac)
			if string(_ebeac) == _aabb {
				_ebaca = append(_ebaca, _dcfag)
			}
			for _, _ggggd := range _eadcd {
				if string(_ebeac) == _ggggd {
					_fef.Log.Trace("\u0046\u006f\u006c\u006c\u006f\u0077\u0020\u006b\u0065\u0079\u0020\u0025\u0073", _ggggd)
					_eabeg, _bdbag := _cbbef.seekByName(_dcfag, _eadcd, _aabb)
					if _bdbag != nil {
						return _ebaca, _bdbag
					}
					_ebaca = append(_ebaca, _eabeg...)
					break
				}
			}
		}
		return _ebaca, nil
	}
	return _ebaca, nil
}

// GetNumComponents returns the number of color components (1 for Separation).
func (_cbbc *PdfColorspaceSpecialSeparation) GetNumComponents() int { return 1 }

// ColorFromFloats returns a new PdfColor based on input color components.
func (_efedd *PdfColorspaceDeviceN) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != _efedd.GetNumComponents() {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_bdded, _gcaf := _efedd.TintTransform.Evaluate(vals)
	if _gcaf != nil {
		return nil, _gcaf
	}
	_ggbb, _gcaf := _efedd.AlternateSpace.ColorFromFloats(_bdded)
	if _gcaf != nil {
		return nil, _gcaf
	}
	return _ggbb, nil
}
func _eacf(_ffddb *PdfField) []*PdfField {
	_cdgg := []*PdfField{_ffddb}
	for _, _dcebbc := range _ffddb.Kids {
		_cdgg = append(_cdgg, _eacf(_dcebbc)...)
	}
	return _cdgg
}

// AnnotFilterFunc represents a PDF annotation filtering function. If the function
// returns true, the annotation is kept, otherwise it is discarded.
type AnnotFilterFunc func(*PdfAnnotation) bool

// PdfAnnotationCircle represents Circle annotations.
// (Section 12.5.6.8).
type PdfAnnotationCircle struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	BS _fed.PdfObject
	IC _fed.PdfObject
	BE _fed.PdfObject
	RD _fed.PdfObject
}

// ColorToRGB verifies that the input color is an RGB color. Method exists in
// order to satisfy the PdfColorspace interface.
func (_gbaa *PdfColorspaceDeviceRGB) ColorToRGB(color PdfColor) (PdfColor, error) {
	_cgbb, _fefdd := color.(*PdfColorDeviceRGB)
	if !_fefdd {
		_fef.Log.Debug("\u0049\u006e\u0070\u0075\u0074\u0020\u0063\u006f\u006c\u006f\u0072 \u006e\u006f\u0074\u0020\u0064\u0065\u0076\u0069\u0063\u0065 \u0052\u0047\u0042")
		return nil, _bb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	return _cgbb, nil
}
func _abgc(_dgcga *_fed.PdfObjectStream) (*PdfFunctionType0, error) {
	_afgga := &PdfFunctionType0{}
	_afgga._dacbd = _dgcga
	_cbefd := _dgcga.PdfObjectDictionary
	_ddadbe, _dbgb := _fed.TraceToDirectObject(_cbefd.Get("\u0044\u006f\u006d\u0061\u0069\u006e")).(*_fed.PdfObjectArray)
	if !_dbgb {
		_fef.Log.Error("D\u006fm\u0061\u0069\u006e\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063\u0069fi\u0065\u0064")
		return nil, _bb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if _ddadbe.Len() < 0 || _ddadbe.Len()%2 != 0 {
		_fef.Log.Error("\u0044\u006f\u006d\u0061\u0069\u006e\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
		return nil, _bb.New("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0064\u006f\u006da\u0069\u006e\u0020\u0072an\u0067\u0065")
	}
	_afgga.NumInputs = _ddadbe.Len() / 2
	_badb, _eafb := _ddadbe.ToFloat64Array()
	if _eafb != nil {
		return nil, _eafb
	}
	_afgga.Domain = _badb
	_ddadbe, _dbgb = _fed.TraceToDirectObject(_cbefd.Get("\u0052\u0061\u006eg\u0065")).(*_fed.PdfObjectArray)
	if !_dbgb {
		_fef.Log.Error("\u0052\u0061\u006e\u0067e \u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064")
		return nil, _bb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if _ddadbe.Len() < 0 || _ddadbe.Len()%2 != 0 {
		return nil, _bb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0061\u006e\u0067\u0065")
	}
	_afgga.NumOutputs = _ddadbe.Len() / 2
	_gccc, _eafb := _ddadbe.ToFloat64Array()
	if _eafb != nil {
		return nil, _eafb
	}
	_afgga.Range = _gccc
	_ddadbe, _dbgb = _fed.TraceToDirectObject(_cbefd.Get("\u0053\u0069\u007a\u0065")).(*_fed.PdfObjectArray)
	if !_dbgb {
		_fef.Log.Error("\u0053i\u007ae\u0020\u006e\u006f\u0074\u0020s\u0070\u0065c\u0069\u0066\u0069\u0065\u0064")
		return nil, _bb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	_gfce, _eafb := _ddadbe.ToIntegerArray()
	if _eafb != nil {
		return nil, _eafb
	}
	if len(_gfce) != _afgga.NumInputs {
		_fef.Log.Error("T\u0061\u0062\u006c\u0065\u0020\u0073\u0069\u007a\u0065\u0020\u006e\u006f\u0074\u0020\u006d\u0061\u0074\u0063h\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072 o\u0066\u0020\u0069n\u0070u\u0074\u0073")
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_afgga.Size = _gfce
	_dbde, _dbgb := _fed.TraceToDirectObject(_cbefd.Get("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0053\u0061\u006d\u0070\u006c\u0065")).(*_fed.PdfObjectInteger)
	if !_dbgb {
		_fef.Log.Error("B\u0069\u0074\u0073\u0050\u0065\u0072S\u0061\u006d\u0070\u006c\u0065\u0020\u006e\u006f\u0074 \u0073\u0070\u0065c\u0069f\u0069\u0065\u0064")
		return nil, _bb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if *_dbde != 1 && *_dbde != 2 && *_dbde != 4 && *_dbde != 8 && *_dbde != 12 && *_dbde != 16 && *_dbde != 24 && *_dbde != 32 {
		_fef.Log.Error("\u0042\u0069\u0074s \u0070\u0065\u0072\u0020\u0073\u0061\u006d\u0070\u006ce\u0020o\u0075t\u0073i\u0064\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064\u0029", *_dbde)
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_afgga.BitsPerSample = int(*_dbde)
	_afgga.Order = 1
	_dfac, _dbgb := _fed.TraceToDirectObject(_cbefd.Get("\u004f\u0072\u0064e\u0072")).(*_fed.PdfObjectInteger)
	if _dbgb {
		if *_dfac != 1 && *_dfac != 3 {
			_fef.Log.Error("\u0049n\u0076a\u006c\u0069\u0064\u0020\u006fr\u0064\u0065r\u0020\u0028\u0025\u0064\u0029", *_dfac)
			return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
		}
		_afgga.Order = int(*_dfac)
	}
	_ddadbe, _dbgb = _fed.TraceToDirectObject(_cbefd.Get("\u0045\u006e\u0063\u006f\u0064\u0065")).(*_fed.PdfObjectArray)
	if _dbgb {
		_dbcbf, _fafc := _ddadbe.ToFloat64Array()
		if _fafc != nil {
			return nil, _fafc
		}
		_afgga.Encode = _dbcbf
	}
	_ddadbe, _dbgb = _fed.TraceToDirectObject(_cbefd.Get("\u0044\u0065\u0063\u006f\u0064\u0065")).(*_fed.PdfObjectArray)
	if _dbgb {
		_cafb, _bccf := _ddadbe.ToFloat64Array()
		if _bccf != nil {
			return nil, _bccf
		}
		_afgga.Decode = _cafb
	}
	_bbgadg, _eafb := _fed.DecodeStream(_dgcga)
	if _eafb != nil {
		return nil, _eafb
	}
	_afgga._eggab = _bbgadg
	return _afgga, nil
}

// Subtype returns the font's "Subtype" field.
func (_eadfg *PdfFont) Subtype() string {
	_deae := _eadfg.baseFields()._afge
	if _dbgf, _bbeff := _eadfg._gdaa.(*pdfFontType0); _bbeff {
		_deae = _deae + "\u003a" + _dbgf.DescendantFont.Subtype()
	}
	return _deae
}

// ToPdfObject implements interface PdfModel.
func (_gfdc *PdfActionGoTo) ToPdfObject() _fed.PdfObject {
	_gfdc.PdfAction.ToPdfObject()
	_bd := _gfdc._fa
	_cag := _bd.PdfObject.(*_fed.PdfObjectDictionary)
	_cag.SetIfNotNil("\u0053", _fed.MakeName(string(ActionTypeGoTo)))
	_cag.SetIfNotNil("\u0044", _gfdc.D)
	return _bd
}

// PdfDate represents a date, which is a PDF string of the form:
// (D:YYYYMMDDHHmmSSOHH'mm)
type PdfDate struct {
	_abaff  int64
	_beaeg  int64
	_dcbg   int64
	_gdcccg int64
	_dbgdd  int64
	_eaec   int64
	_caaae  byte
	_ecgbg  int64
	_aabea  int64
}

// GetRuneMetrics returns the character metrics for the specified rune.
// A bool flag is returned to indicate whether or not the entry was found.
func (_fdedd pdfFontType3) GetRuneMetrics(r rune) (_geg.CharMetrics, bool) {
	_abbec := _fdedd.Encoder()
	if _abbec == nil {
		_fef.Log.Debug("\u004e\u006f\u0020en\u0063\u006f\u0064\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0066\u006f\u006e\u0074\u0073\u003d\u0025\u0073", _fdedd)
		return _geg.CharMetrics{}, false
	}
	_cfbd, _bdgf := _abbec.RuneToCharcode(r)
	if !_bdgf {
		if r != ' ' {
			_fef.Log.Trace("\u004e\u006f\u0020c\u0068\u0061\u0072\u0063o\u0064\u0065\u0020\u0066\u006f\u0072\u0020r\u0075\u006e\u0065\u003d\u0025\u0076\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", r, _fdedd)
		}
		return _geg.CharMetrics{}, false
	}
	_dfaff, _fcdeg := _fdedd.GetCharMetrics(_cfbd)
	return _dfaff, _fcdeg
}

// NewPdfColorspaceSpecialSeparation returns a new separation color.
func NewPdfColorspaceSpecialSeparation() *PdfColorspaceSpecialSeparation {
	_ebae := &PdfColorspaceSpecialSeparation{}
	return _ebae
}

// NewPdfAnnotationRichMedia returns a new rich media annotation.
func NewPdfAnnotationRichMedia() *PdfAnnotationRichMedia {
	_ebe := NewPdfAnnotation()
	_eccf := &PdfAnnotationRichMedia{}
	_eccf.PdfAnnotation = _ebe
	_ebe.SetContext(_eccf)
	return _eccf
}

// ToPdfObject implements interface PdfModel.
func (_cba *PdfActionGoToE) ToPdfObject() _fed.PdfObject {
	_cba.PdfAction.ToPdfObject()
	_eda := _cba._fa
	_bdb := _eda.PdfObject.(*_fed.PdfObjectDictionary)
	_bdb.SetIfNotNil("\u0053", _fed.MakeName(string(ActionTypeGoToE)))
	if _cba.F != nil {
		_bdb.Set("\u0046", _cba.F.ToPdfObject())
	}
	_bdb.SetIfNotNil("\u0044", _cba.D)
	_bdb.SetIfNotNil("\u004ee\u0077\u0057\u0069\u006e\u0064\u006fw", _cba.NewWindow)
	_bdb.SetIfNotNil("\u0054", _cba.T)
	return _eda
}

// DecodeArray returns the range of color component values in the Lab colorspace.
func (_dgbe *PdfColorspaceLab) DecodeArray() []float64 {
	_ecga := []float64{0, 100}
	if _dgbe.Range != nil && len(_dgbe.Range) == 4 {
		_ecga = append(_ecga, _dgbe.Range...)
	} else {
		_ecga = append(_ecga, -100, 100, -100, 100)
	}
	return _ecga
}
func _bbbce(_bgbc *PdfPage) map[_fed.PdfObjectName]_fed.PdfObject {
	_bdfb := make(map[_fed.PdfObjectName]_fed.PdfObject)
	if _bgbc.Resources == nil {
		return _bdfb
	}
	if _bgbc.Resources.Font != nil {
		if _eab, _cfdd := _fed.GetDict(_bgbc.Resources.Font); _cfdd {
			for _, _acbd := range _eab.Keys() {
				_bdfb[_acbd] = _eab.Get(_acbd)
			}
		}
	}
	if _bgbc.Resources.ExtGState != nil {
		if _dacg, _dagc := _fed.GetDict(_bgbc.Resources.ExtGState); _dagc {
			for _, _ggda := range _dacg.Keys() {
				_bdfb[_ggda] = _dacg.Get(_ggda)
			}
		}
	}
	if _bgbc.Resources.XObject != nil {
		if _ebcb, _bdfbd := _fed.GetDict(_bgbc.Resources.XObject); _bdfbd {
			for _, _agde := range _ebcb.Keys() {
				_bdfb[_agde] = _ebcb.Get(_agde)
			}
		}
	}
	if _bgbc.Resources.Pattern != nil {
		if _eaf, _bfbg := _fed.GetDict(_bgbc.Resources.Pattern); _bfbg {
			for _, _gffe := range _eaf.Keys() {
				_bdfb[_gffe] = _eaf.Get(_gffe)
			}
		}
	}
	if _bgbc.Resources.Shading != nil {
		if _dcbc, _eace := _fed.GetDict(_bgbc.Resources.Shading); _eace {
			for _, _bdfa := range _dcbc.Keys() {
				_bdfb[_bdfa] = _dcbc.Get(_bdfa)
			}
		}
	}
	if _bgbc.Resources.ProcSet != nil {
		if _dgff, _bfce := _fed.GetDict(_bgbc.Resources.ProcSet); _bfce {
			for _, _dab := range _dgff.Keys() {
				_bdfb[_dab] = _dgff.Get(_dab)
			}
		}
	}
	if _bgbc.Resources.Properties != nil {
		if _gbag, _fedae := _fed.GetDict(_bgbc.Resources.Properties); _fedae {
			for _, _cade := range _gbag.Keys() {
				_bdfb[_cade] = _gbag.Get(_cade)
			}
		}
	}
	return _bdfb
}

// SetType sets the field button's type.  Can be one of:
// - PdfFieldButtonPush for push button fields
// - PdfFieldButtonCheckbox for checkbox fields
// - PdfFieldButtonRadio for radio button fields
// This sets the field's flag appropriately.
func (_ggbe *PdfFieldButton) SetType(btype ButtonType) {
	_cadb := uint32(0)
	if _ggbe.Ff != nil {
		_cadb = uint32(*_ggbe.Ff)
	}
	switch btype {
	case ButtonTypePush:
		_cadb |= FieldFlagPushbutton.Mask()
	case ButtonTypeRadio:
		_cadb |= FieldFlagRadio.Mask()
	}
	_ggbe.Ff = _fed.MakeInteger(int64(_cadb))
}

// SetPdfCreator sets the Creator attribute of the output PDF.
func SetPdfCreator(creator string) { _abadca.Lock(); defer _abadca.Unlock(); _cgeda = creator }
func (_ccdae *Image) resampleLowBits(_cagfg []uint32) {
	_bgba := _eede.BytesPerLine(int(_ccdae.Width), int(_ccdae.BitsPerComponent), _ccdae.ColorComponents)
	_cbcbg := make([]byte, _ccdae.ColorComponents*_bgba*int(_ccdae.Height))
	_cefcf := int(_ccdae.BitsPerComponent) * _ccdae.ColorComponents * int(_ccdae.Width)
	_cece := uint8(8)
	var (
		_fgbec, _badca int
		_abbdd         uint32
	)
	for _ffbgb := 0; _ffbgb < int(_ccdae.Height); _ffbgb++ {
		_badca = _ffbgb * _bgba
		for _aecba := 0; _aecba < _cefcf; _aecba++ {
			_abbdd = _cagfg[_fgbec]
			_cece -= uint8(_ccdae.BitsPerComponent)
			_cbcbg[_badca] |= byte(_abbdd) << _cece
			if _cece == 0 {
				_cece = 8
				_badca++
			}
			_fgbec++
		}
	}
	_ccdae.Data = _cbcbg
}

var _ pdfFont = (*pdfCIDFontType2)(nil)

// NewPdfColorCalRGB returns a new CalRBG color.
func NewPdfColorCalRGB(a, b, c float64) *PdfColorCalRGB {
	_cceg := PdfColorCalRGB{a, b, c}
	return &_cceg
}

// ToInteger convert to an integer format.
func (_cab *PdfColorDeviceGray) ToInteger(bits int) uint32 {
	_feed := _bg.Pow(2, float64(bits)) - 1
	return uint32(_feed * _cab.Val())
}

// NewPdfOutline returns an initialized PdfOutline.
func NewPdfOutline() *PdfOutline {
	_cdgff := &PdfOutline{_cbad: _fed.MakeIndirectObject(_fed.MakeDict())}
	_cdgff._ffgd = _cdgff
	return _cdgff
}
func (_fbba *PdfAnnotation) String() string {
	_bdbf := ""
	_ecd, _cbcb := _fbba.ToPdfObject().(*_fed.PdfIndirectObject)
	if _cbcb {
		_bdbf = _d.Sprintf("\u0025\u0054\u003a\u0020\u0025\u0073", _fbba._adc, _ecd.PdfObject.String())
	}
	return _bdbf
}

// GetNumComponents returns the number of input color components, i.e. that are input to the tint transform.
func (_degf *PdfColorspaceDeviceN) GetNumComponents() int { return _degf.ColorantNames.Len() }
func _fdag(_fcde _fed.PdfObject) (*PdfColorspaceDeviceN, error) {
	_bcgd := NewPdfColorspaceDeviceN()
	if _bbfb, _fbad := _fcde.(*_fed.PdfIndirectObject); _fbad {
		_bcgd._dfgaa = _bbfb
	}
	_fcde = _fed.TraceToDirectObject(_fcde)
	_bbbad, _egba := _fcde.(*_fed.PdfObjectArray)
	if !_egba {
		return nil, _d.Errorf("\u0064\u0065\u0076\u0069\u0063\u0065\u004e\u0020\u0043\u0053\u003a \u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0062j\u0065\u0063\u0074")
	}
	if _bbbad.Len() != 4 && _bbbad.Len() != 5 {
		return nil, _d.Errorf("\u0064\u0065\u0076ic\u0065\u004e\u0020\u0043\u0053\u003a\u0020\u0049\u006ec\u006fr\u0072e\u0063t\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068")
	}
	_fcde = _bbbad.Get(0)
	_bggeg, _egba := _fcde.(*_fed.PdfObjectName)
	if !_egba {
		return nil, _d.Errorf("\u0064\u0065\u0076i\u0063\u0065\u004e\u0020C\u0053\u003a\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0066\u0061\u006d\u0069\u006c\u0079\u0020\u006e\u0061\u006d\u0065")
	}
	if *_bggeg != "\u0044e\u0076\u0069\u0063\u0065\u004e" {
		return nil, _d.Errorf("\u0064\u0065v\u0069\u0063\u0065\u004e\u0020\u0043\u0053\u003a\u0020\u0077\u0072\u006f\u006e\u0067\u0020\u0066\u0061\u006d\u0069\u006c\u0079\u0020na\u006d\u0065")
	}
	_fcde = _bbbad.Get(1)
	_fcde = _fed.TraceToDirectObject(_fcde)
	_eeaae, _egba := _fcde.(*_fed.PdfObjectArray)
	if !_egba {
		return nil, _d.Errorf("\u0064\u0065\u0076i\u0063\u0065\u004e\u0020C\u0053\u003a\u0020\u0049\u006e\u0076\u0061l\u0069\u0064\u0020\u006e\u0061\u006d\u0065\u0073\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_bcgd.ColorantNames = _eeaae
	_fcde = _bbbad.Get(2)
	_badg, _cbffa := NewPdfColorspaceFromPdfObject(_fcde)
	if _cbffa != nil {
		return nil, _cbffa
	}
	_bcgd.AlternateSpace = _badg
	_ccbc, _cbffa := _bggad(_bbbad.Get(3))
	if _cbffa != nil {
		return nil, _cbffa
	}
	_bcgd.TintTransform = _ccbc
	if _bbbad.Len() == 5 {
		_afgc, _afdfa := _ebed(_bbbad.Get(4))
		if _afdfa != nil {
			return nil, _afdfa
		}
		_bcgd.Attributes = _afgc
	}
	return _bcgd, nil
}

// AddExtension adds the specified extension to the Extensions dictionary.
// See section 7.1.2 "Extensions Dictionary" (pp. 108-109 PDF32000_2008).
func (_fcbad *PdfWriter) AddExtension(extName, baseVersion string, extLevel int) {
	_dcdb, _dcafg := _fed.GetDict(_fcbad._cdefg.Get("\u0045\u0078\u0074\u0065\u006e\u0073\u0069\u006f\u006e\u0073"))
	if !_dcafg {
		_dcdb = _fed.MakeDict()
		_fcbad._cdefg.Set("\u0045\u0078\u0074\u0065\u006e\u0073\u0069\u006f\u006e\u0073", _dcdb)
	}
	_faebc, _dcafg := _fed.GetDict(_dcdb.Get(_fed.PdfObjectName(extName)))
	if !_dcafg {
		_faebc = _fed.MakeDict()
		_dcdb.Set(_fed.PdfObjectName(extName), _faebc)
	}
	if _eaaab, _ := _fed.GetNameVal(_faebc.Get("B\u0061\u0073\u0065\u0056\u0065\u0072\u0073\u0069\u006f\u006e")); _eaaab != baseVersion {
		_faebc.Set("B\u0061\u0073\u0065\u0056\u0065\u0072\u0073\u0069\u006f\u006e", _fed.MakeName(baseVersion))
	}
	if _ggecf, _ := _fed.GetIntVal(_faebc.Get("\u0045\u0078\u0074\u0065\u006e\u0073\u0069\u006f\u006eL\u0065\u0076\u0065\u006c")); _ggecf != extLevel {
		_faebc.Set("\u0045\u0078\u0074\u0065\u006e\u0073\u0069\u006f\u006eL\u0065\u0076\u0065\u006c", _fed.MakeInteger(int64(extLevel)))
	}
}

// SetName sets the `Name` field of the signature.
func (_dggfg *PdfSignature) SetName(name string) { _dggfg.Name = _fed.MakeString(name) }

// PdfColorspaceCalRGB stores A, B, C components
type PdfColorspaceCalRGB struct {
	WhitePoint []float64
	BlackPoint []float64
	Gamma      []float64
	Matrix     []float64
	_dbafg     *_fed.PdfObjectDictionary
	_edee      *_fed.PdfIndirectObject
}

// IsCheckbox returns true if the button field represents a checkbox, false otherwise.
func (_gbeae *PdfFieldButton) IsCheckbox() bool { return _gbeae.GetType() == ButtonTypeCheckbox }

// PdfBorderEffect represents a PDF border effect.
type PdfBorderEffect struct {
	S *BorderEffect
	I *float64
}

// ToPdfObject implements interface PdfModel.
// Note: Call the sub-annotation's ToPdfObject to set both the generic and non-generic information.
func (_aeba *PdfAnnotation) ToPdfObject() _fed.PdfObject {
	_caee := _aeba._ffaab
	_ffad := _caee.PdfObject.(*_fed.PdfObjectDictionary)
	_ffad.Clear()
	_ffad.Set("\u0054\u0079\u0070\u0065", _fed.MakeName("\u0041\u006e\u006eo\u0074"))
	_ffad.SetIfNotNil("\u0052\u0065\u0063\u0074", _aeba.Rect)
	_ffad.SetIfNotNil("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073", _aeba.Contents)
	_ffad.SetIfNotNil("\u0050", _aeba.P)
	_ffad.SetIfNotNil("\u004e\u004d", _aeba.NM)
	_ffad.SetIfNotNil("\u004d", _aeba.M)
	_ffad.SetIfNotNil("\u0046", _aeba.F)
	_ffad.SetIfNotNil("\u0041\u0050", _aeba.AP)
	_ffad.SetIfNotNil("\u0041\u0053", _aeba.AS)
	_ffad.SetIfNotNil("\u0042\u006f\u0072\u0064\u0065\u0072", _aeba.Border)
	_ffad.SetIfNotNil("\u0043", _aeba.C)
	_ffad.SetIfNotNil("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074", _aeba.StructParent)
	_ffad.SetIfNotNil("\u004f\u0043", _aeba.OC)
	return _caee
}

// NewCompositePdfFontFromTTF loads a composite TTF font. Composite fonts can
// be used to represent unicode fonts which can have multi-byte character codes, representing a wide
// range of values. They are often used for symbolic languages, including Chinese, Japanese and Korean.
// It is represented by a Type0 Font with an underlying CIDFontType2 and an Identity-H encoding map.
// TODO: May be extended in the future to support a larger variety of CMaps and vertical fonts.
// NOTE: For simple fonts, use NewPdfFontFromTTF.
func NewCompositePdfFontFromTTF(r _ge.ReadSeeker) (*PdfFont, error) {
	_afgcc, _gageb := _aa.ReadAll(r)
	if _gageb != nil {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0066\u006f\u006e\u0074\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074s\u003a\u0020\u0025\u0076", _gageb)
		return nil, _gageb
	}
	_cdgac, _gageb := _geg.TtfParse(_eb.NewReader(_afgcc))
	if _gageb != nil {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067 \u0074\u0074\u0066\u0020\u0066\u006f\u006et\u003a\u0020\u0025\u0076", _gageb)
		return nil, _gageb
	}
	_bcde := &pdfCIDFontType2{fontCommon: fontCommon{_afge: "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0032"}, CIDToGIDMap: _fed.MakeName("\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079")}
	if len(_cdgac.Widths) <= 0 {
		return nil, _bb.New("\u0045\u0052\u0052O\u0052\u003a\u0020\u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065 \u0028\u0057\u0069\u0064\u0074\u0068\u0073\u0029")
	}
	_fbbef := 1000.0 / float64(_cdgac.UnitsPerEm)
	_gcbeb := _fbbef * float64(_cdgac.Widths[0])
	_ggddd := make(map[rune]int)
	_dfcb := make(map[_geg.GID]int)
	_bgcc := _geg.GID(len(_cdgac.Widths))
	for _gbaaf, _dgbbb := range _cdgac.Chars {
		if _dgbbb > _bgcc-1 {
			continue
		}
		_ddfdb := int(_fbbef * float64(_cdgac.Widths[_dgbbb]))
		_ggddd[_gbaaf] = _ddfdb
		_dfcb[_dgbbb] = _ddfdb
	}
	_bcde._bbff = _ggddd
	_bcde.DW = _fed.MakeInteger(int64(_gcbeb))
	_ebdg := _geaac(_dfcb, uint16(_bgcc))
	_bcde.W = _fed.MakeIndirectObject(_ebdg)
	_dagaf := _fed.MakeDict()
	_dagaf.Set("\u004f\u0072\u0064\u0065\u0072\u0069\u006e\u0067", _fed.MakeString("\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"))
	_dagaf.Set("\u0052\u0065\u0067\u0069\u0073\u0074\u0072\u0079", _fed.MakeString("\u0041\u0064\u006fb\u0065"))
	_dagaf.Set("\u0053\u0075\u0070\u0070\u006c\u0065\u006d\u0065\u006e\u0074", _fed.MakeInteger(0))
	_bcde.CIDSystemInfo = _dagaf
	_acgac := &PdfFontDescriptor{FontName: _fed.MakeName(_cdgac.PostScriptName), Ascent: _fed.MakeFloat(_fbbef * float64(_cdgac.TypoAscender)), Descent: _fed.MakeFloat(_fbbef * float64(_cdgac.TypoDescender)), CapHeight: _fed.MakeFloat(_fbbef * float64(_cdgac.CapHeight)), FontBBox: _fed.MakeArrayFromFloats([]float64{_fbbef * float64(_cdgac.Xmin), _fbbef * float64(_cdgac.Ymin), _fbbef * float64(_cdgac.Xmax), _fbbef * float64(_cdgac.Ymax)}), ItalicAngle: _fed.MakeFloat(_cdgac.ItalicAngle), MissingWidth: _fed.MakeFloat(_gcbeb)}
	_fafa, _gageb := _fed.MakeStream(_afgcc, _fed.NewFlateEncoder())
	if _gageb != nil {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074o\u0020m\u0061\u006b\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076", _gageb)
		return nil, _gageb
	}
	_fafa.PdfObjectDictionary.Set("\u004ce\u006e\u0067\u0074\u0068\u0031", _fed.MakeInteger(int64(len(_afgcc))))
	_acgac.FontFile2 = _fafa
	if _cdgac.Bold {
		_acgac.StemV = _fed.MakeInteger(120)
	} else {
		_acgac.StemV = _fed.MakeInteger(70)
	}
	_ccedf := _dcad
	if _cdgac.IsFixedPitch {
		_ccedf |= _gcaff
	}
	if _cdgac.ItalicAngle != 0 {
		_ccedf |= _fefa
	}
	_acgac.Flags = _fed.MakeInteger(int64(_ccedf))
	_bcde._daac = _cdgac.PostScriptName
	_bcde._bgdgb = _acgac
	_ggbdc := pdfFontType0{fontCommon: fontCommon{_afge: "\u0054\u0079\u0070e\u0030", _daac: _cdgac.PostScriptName}, DescendantFont: &PdfFont{_gdaa: _bcde}, Encoding: _fed.MakeName("\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079\u002d\u0048"), _eeabd: _cdgac.NewEncoder()}
	if len(_cdgac.Chars) > 0 {
		_begc := make(map[_edf.CharCode]rune, len(_cdgac.Chars))
		for _gfbbb, _aceb := range _cdgac.Chars {
			_caccf := _edf.CharCode(_aceb)
			if _fgfab, _ebfg := _begc[_caccf]; !_ebfg || (_ebfg && _fgfab > _gfbbb) {
				_begc[_caccf] = _gfbbb
			}
		}
		_ggbdc._ecfd = _edf.NewToUnicodeCMap(_begc)
	}
	_gcage := PdfFont{_gdaa: &_ggbdc}
	return &_gcage, nil
}
func _gcfc(_fggd *_fed.PdfObjectDictionary, _badc *fontCommon) (*pdfFontType0, error) {
	_babd, _fffce := _fed.GetArray(_fggd.Get("\u0044e\u0073c\u0065\u006e\u0064\u0061\u006e\u0074\u0046\u006f\u006e\u0074\u0073"))
	if !_fffce {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049n\u0076\u0061\u006cid\u0020\u0044\u0065\u0073\u0063\u0065n\u0064\u0061\u006e\u0074\u0046\u006f\u006e\u0074\u0073\u0020\u002d\u0020\u006e\u006f\u0074 \u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079 \u0025\u0073", _badc)
		return nil, _fed.ErrRangeError
	}
	if _babd.Len() != 1 {
		_fef.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0041\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020(%\u0064\u0029", _babd.Len())
		return nil, _fed.ErrRangeError
	}
	_cdbcc, _agefd := _faab(_babd.Get(0), false)
	if _agefd != nil {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046a\u0069\u006c\u0065d \u006c\u006f\u0061\u0064\u0069\u006eg\u0020\u0064\u0065\u0073\u0063\u0065\u006e\u0064\u0061\u006e\u0074\u0020\u0066\u006f\u006et\u003a\u0020\u0065\u0072\u0072\u003d\u0025\u0076 \u0025\u0073", _agefd, _badc)
		return nil, _agefd
	}
	_gfbe := _eagd(_badc)
	_gfbe.DescendantFont = _cdbcc
	_dagce, _fffce := _fed.GetNameVal(_fggd.Get("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067"))
	if _fffce {
		if _dagce == "\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079\u002d\u0048" || _dagce == "\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079\u002d\u0056" {
			_gfbe._eeabd = _dg.NewIdentityTextEncoder(_dagce)
		} else if _edf.IsPredefinedCMap(_dagce) {
			_gfbe._adgcc, _agefd = _edf.LoadPredefinedCMap(_dagce)
			if _agefd != nil {
				_fef.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0063o\u0075\u006c\u0064 \u006e\u006f\u0074\u0020l\u006f\u0061\u0064\u0020\u0070\u0072\u0065\u0064\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0043\u004d\u0061\u0070\u0020\u0025\u0073\u003a\u0020\u0025\u0076", _dagce, _agefd)
			}
		} else {
			_fef.Log.Debug("\u0055\u006e\u0068\u0061\u006e\u0064\u006c\u0065\u0064\u0020\u0063\u006da\u0070\u0020\u0025\u0071", _dagce)
		}
	}
	if _ebegc := _cdbcc.baseFields()._ecfd; _ebegc != nil {
		if _cagag := _ebegc.Name(); _cagag == "\u0041d\u006fb\u0065\u002d\u0043\u004e\u0053\u0031\u002d\u0055\u0043\u0053\u0032" || _cagag == "\u0041\u0064\u006f\u0062\u0065\u002d\u0047\u0042\u0031-\u0055\u0043\u0053\u0032" || _cagag == "\u0041\u0064\u006f\u0062\u0065\u002d\u004a\u0061\u0070\u0061\u006e\u0031-\u0055\u0043\u0053\u0032" || _cagag == "\u0041\u0064\u006f\u0062\u0065\u002d\u004b\u006f\u0072\u0065\u0061\u0031-\u0055\u0043\u0053\u0032" {
			_gfbe._eeabd = _dg.NewCMapEncoder(_dagce, _gfbe._adgcc, _ebegc)
		}
	}
	return _gfbe, nil
}

// ToPdfObject returns a PDF object representation of the outline destination.
func (_bfdbg OutlineDest) ToPdfObject() _fed.PdfObject {
	if (_bfdbg.PageObj == nil && _bfdbg.Page < 0) || _bfdbg.Mode == "" {
		return _fed.MakeNull()
	}
	_cbfgg := _fed.MakeArray()
	if _bfdbg.PageObj != nil {
		_cbfgg.Append(_bfdbg.PageObj)
	} else {
		_cbfgg.Append(_fed.MakeInteger(_bfdbg.Page))
	}
	_cbfgg.Append(_fed.MakeName(_bfdbg.Mode))
	switch _bfdbg.Mode {
	case "\u0046\u0069\u0074", "\u0046\u0069\u0074\u0042":
	case "\u0046\u0069\u0074\u0048", "\u0046\u0069\u0074B\u0048":
		_cbfgg.Append(_fed.MakeFloat(_bfdbg.Y))
	case "\u0046\u0069\u0074\u0056", "\u0046\u0069\u0074B\u0056":
		_cbfgg.Append(_fed.MakeFloat(_bfdbg.X))
	case "\u0058\u0059\u005a":
		_cbfgg.Append(_fed.MakeFloat(_bfdbg.X))
		_cbfgg.Append(_fed.MakeFloat(_bfdbg.Y))
		_cbfgg.Append(_fed.MakeFloat(_bfdbg.Zoom))
	default:
		_cbfgg.Set(1, _fed.MakeName("\u0046\u0069\u0074"))
	}
	return _cbfgg
}
func _bcba(_fggc string) (map[_dg.CharCode]_dg.GlyphName, error) {
	_cgbe := _eed.Split(_fggc, "\u000a")
	_gadg := make(map[_dg.CharCode]_dg.GlyphName)
	for _, _edff := range _cgbe {
		_bcffe := _feee.FindStringSubmatch(_edff)
		if _bcffe == nil {
			continue
		}
		_dfcba, _abee := _bcffe[1], _bcffe[2]
		_bagea, _abbfc := _ba.Atoi(_dfcba)
		if _abbfc != nil {
			_fef.Log.Debug("\u0045\u0052\u0052\u004fR\u003a\u0020\u0042\u0061\u0064\u0020\u0065\u006e\u0063\u006fd\u0069n\u0067\u0020\u006c\u0069\u006e\u0065\u002e \u0025\u0071", _edff)
			return nil, _fed.ErrTypeError
		}
		_gadg[_dg.CharCode(_bagea)] = _dg.GlyphName(_abee)
	}
	_fef.Log.Trace("g\u0065\u0074\u0045\u006e\u0063\u006fd\u0069\u006e\u0067\u0073\u003a\u0020\u006b\u0065\u0079V\u0061\u006c\u0075e\u0073=\u0025\u0023\u0076", _gadg)
	return _gadg, nil
}

// Encoder returns the font's text encoder.
func (_efaee pdfFontType0) Encoder() _dg.TextEncoder { return _efaee._eeabd }

// NewPdfActionNamed returns a new "named" action.
func NewPdfActionNamed() *PdfActionNamed {
	_gac := NewPdfAction()
	_efg := &PdfActionNamed{}
	_efg.PdfAction = _gac
	_gac.SetContext(_efg)
	return _efg
}

// IsTerminal returns true for terminal fields, false otherwise.
// Terminal fields are fields whose descendants are only widget annotations.
func (_cfab *PdfField) IsTerminal() bool { return len(_cfab.Kids) == 0 }

// GetShadingByName gets the shading specified by keyName. Returns nil if not existing.
// The bool flag indicated whether it was found or not.
func (_dfcad *PdfPageResources) GetShadingByName(keyName _fed.PdfObjectName) (*PdfShading, bool) {
	if _dfcad.Shading == nil {
		return nil, false
	}
	_ecaga, _defde := _fed.TraceToDirectObject(_dfcad.Shading).(*_fed.PdfObjectDictionary)
	if !_defde {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0053\u0068\u0061d\u0069\u006e\u0067\u0020\u0065\u006e\u0074r\u0079\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _dfcad.Shading)
		return nil, false
	}
	if _dgedd := _ecaga.Get(keyName); _dgedd != nil {
		_decc, _eegba := _dcca(_dgedd)
		if _eegba != nil {
			_fef.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020f\u0061\u0069l\u0065\u0064\u0020\u0074\u006f\u0020\u006c\u006fa\u0064\u0020\u0070\u0064\u0066\u0020\u0073\u0068\u0061\u0064\u0069\u006eg\u003a\u0020\u0025\u0076", _eegba)
			return nil, false
		}
		return _decc, true
	}
	return nil, false
}

// NewPdfActionRendition returns a new "rendition" action.
func NewPdfActionRendition() *PdfActionRendition {
	_bgb := NewPdfAction()
	_ag := &PdfActionRendition{}
	_ag.PdfAction = _bgb
	_bgb.SetContext(_ag)
	return _ag
}

// ToPdfObject returns colorspace in a PDF object format [name dictionary]
func (_fcagd *PdfColorspaceCalRGB) ToPdfObject() _fed.PdfObject {
	_aeca := &_fed.PdfObjectArray{}
	_aeca.Append(_fed.MakeName("\u0043\u0061\u006c\u0052\u0047\u0042"))
	_dgcg := _fed.MakeDict()
	if _fcagd.WhitePoint != nil {
		_eaegg := _fed.MakeArray(_fed.MakeFloat(_fcagd.WhitePoint[0]), _fed.MakeFloat(_fcagd.WhitePoint[1]), _fed.MakeFloat(_fcagd.WhitePoint[2]))
		_dgcg.Set("\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074", _eaegg)
	} else {
		_fef.Log.Error("\u0043\u0061l\u0052\u0047\u0042\u003a \u004d\u0069s\u0073\u0069\u006e\u0067\u0020\u0057\u0068\u0069t\u0065\u0050\u006f\u0069\u006e\u0074\u0020\u0028\u0052\u0065\u0071\u0075i\u0072\u0065\u0064\u0029")
	}
	if _fcagd.BlackPoint != nil {
		_ffec := _fed.MakeArray(_fed.MakeFloat(_fcagd.BlackPoint[0]), _fed.MakeFloat(_fcagd.BlackPoint[1]), _fed.MakeFloat(_fcagd.BlackPoint[2]))
		_dgcg.Set("\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074", _ffec)
	}
	if _fcagd.Gamma != nil {
		_bddc := _fed.MakeArray(_fed.MakeFloat(_fcagd.Gamma[0]), _fed.MakeFloat(_fcagd.Gamma[1]), _fed.MakeFloat(_fcagd.Gamma[2]))
		_dgcg.Set("\u0047\u0061\u006dm\u0061", _bddc)
	}
	if _fcagd.Matrix != nil {
		_bfacg := _fed.MakeArray(_fed.MakeFloat(_fcagd.Matrix[0]), _fed.MakeFloat(_fcagd.Matrix[1]), _fed.MakeFloat(_fcagd.Matrix[2]), _fed.MakeFloat(_fcagd.Matrix[3]), _fed.MakeFloat(_fcagd.Matrix[4]), _fed.MakeFloat(_fcagd.Matrix[5]), _fed.MakeFloat(_fcagd.Matrix[6]), _fed.MakeFloat(_fcagd.Matrix[7]), _fed.MakeFloat(_fcagd.Matrix[8]))
		_dgcg.Set("\u004d\u0061\u0074\u0072\u0069\u0078", _bfacg)
	}
	_aeca.Append(_dgcg)
	if _fcagd._edee != nil {
		_fcagd._edee.PdfObject = _aeca
		return _fcagd._edee
	}
	return _aeca
}

// NewPdfColorDeviceRGB returns a new PdfColorDeviceRGB based on the r,g,b component values.
func NewPdfColorDeviceRGB(r, g, b float64) *PdfColorDeviceRGB {
	_gdca := PdfColorDeviceRGB{r, g, b}
	return &_gdca
}
func _ecagf(_gffcc _ge.ReadSeeker, _ceafg *ReaderOpts, _bbcbf bool, _baed string) (*PdfReader, error) {
	if _ceafg == nil {
		_ceafg = NewReaderOpts()
	}
	_affad := &PdfReader{_faefaf: _gffcc, _aaebc: map[_fed.PdfObject]struct{}{}, _dcfcd: _bdgb(), _bgbff: _ceafg.LazyLoad}
	_ebcd, _efbab := _bgdaa("\u0072")
	if _efbab != nil {
		return nil, _efbab
	}
	_efbab = _fdg.Track(_ebcd, _baed)
	if _efbab != nil {
		return nil, _efbab
	}
	_affad._cfage = _ebcd
	_cgbge, _efbab := _fed.NewParser(_gffcc)
	if _efbab != nil {
		return nil, _efbab
	}
	_affad._cdfggf = _cgbge
	_abdede, _efbab := _affad.IsEncrypted()
	if _efbab != nil {
		return nil, _efbab
	}
	if !_abdede {
		_efbab = _affad.loadStructure()
		if _efbab != nil {
			return nil, _efbab
		}
	} else if _bbcbf {
		_cagfgg, _fcbgf := _affad.Decrypt([]byte(_ceafg.Password))
		if _fcbgf != nil {
			return nil, _fcbgf
		}
		if !_cagfgg {
			return nil, _bb.New("\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0064\u0065c\u0072\u0079\u0070\u0074\u0020\u0070\u0061\u0073\u0073w\u006f\u0072\u0064\u0020p\u0072\u006f\u0074\u0065\u0063\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0065\u0020\u002d\u0020\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0073\u0070\u0065\u0063\u0069\u0066y\u0020\u0070\u0061s\u0073\u0020\u0074\u006f\u0020\u0044\u0065\u0063\u0072\u0079\u0070\u0074")
		}
	}
	return _affad, nil
}

// NewPdfColorspaceCalGray returns a new CalGray colorspace object.
func NewPdfColorspaceCalGray() *PdfColorspaceCalGray {
	_fcaa := &PdfColorspaceCalGray{}
	_fcaa.BlackPoint = []float64{0.0, 0.0, 0.0}
	_fcaa.Gamma = 1
	return _fcaa
}

// PdfAnnotationHighlight represents Highlight annotations.
// (Section 12.5.6.10).
type PdfAnnotationHighlight struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	QuadPoints _fed.PdfObject
}

// GetExtGState gets the ExtGState specified by keyName. Returns a bool
// indicating whether it was found or not.
func (_eefda *PdfPageResources) GetExtGState(keyName _fed.PdfObjectName) (_fed.PdfObject, bool) {
	if _eefda.ExtGState == nil {
		return nil, false
	}
	_cbbb, _gfcc := _fed.TraceToDirectObject(_eefda.ExtGState).(*_fed.PdfObjectDictionary)
	if !_gfcc {
		_fef.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064 \u0045\u0078\u0074\u0047\u0053\u0074\u0061\u0074\u0065\u0020\u0065\u006e\u0074\u0072\u0079\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _eefda.ExtGState)
		return nil, false
	}
	if _cgbbe := _cbbb.Get(keyName); _cgbbe != nil {
		return _cgbbe, true
	}
	return nil, false
}
func (_agfe *PdfWriter) writeString(_abfgb string) {
	if _agfe._deee != nil {
		return
	}
	_eedfb, _dbae := _agfe._adge.WriteString(_abfgb)
	_agfe._cgdb += int64(_eedfb)
	_agfe._deee = _dbae
}

// ToPdfObject returns the PDF representation of the pattern.
func (_aggga *PdfPattern) ToPdfObject() _fed.PdfObject {
	_febgd := _aggga.getDict()
	_febgd.Set("\u0054\u0079\u0070\u0065", _fed.MakeName("\u0050a\u0074\u0074\u0065\u0072\u006e"))
	_febgd.Set("P\u0061\u0074\u0074\u0065\u0072\u006e\u0054\u0079\u0070\u0065", _fed.MakeInteger(_aggga.PatternType))
	return _aggga._fbefb
}
func _caagg() string { _abadca.Lock(); defer _abadca.Unlock(); return _gfcfc }

// ToInteger convert to an integer format.
func (_gdcc *PdfColorDeviceRGB) ToInteger(bits int) [3]uint32 {
	_bfaf := _bg.Pow(2, float64(bits)) - 1
	return [3]uint32{uint32(_bfaf * _gdcc.R()), uint32(_bfaf * _gdcc.G()), uint32(_bfaf * _gdcc.B())}
}

// CustomKeys returns all custom info keys as list.
func (_ccdcf *PdfInfo) CustomKeys() []string {
	if _ccdcf._debc == nil {
		return nil
	}
	_abbeb := make([]string, len(_ccdcf._debc.Keys()))
	for _, _ceba := range _ccdcf._debc.Keys() {
		_abbeb = append(_abbeb, _ceba.String())
	}
	return _abbeb
}

// ImageToRGB converts Lab colorspace image to RGB and returns the result.
func (_aabd *PdfColorspaceLab) ImageToRGB(img Image) (Image, error) {
	_eded := func(_gagg float64) float64 {
		if _gagg >= 6.0/29 {
			return _gagg * _gagg * _gagg
		}
		return 108.0 / 841 * (_gagg - 4/29)
	}
	_befg := img._ccdge
	if len(_befg) != 6 {
		_fef.Log.Trace("\u0049\u006d\u0061\u0067\u0065\u0020\u002d\u0020\u004c\u0061\u0062\u0020\u0044e\u0063\u006f\u0064\u0065\u0020\u0072\u0061\u006e\u0067e\u0020\u0021\u003d\u0020\u0036\u002e\u002e\u002e\u0020\u0075\u0073\u0065\u0020\u005b0\u0020\u0031\u0030\u0030\u0020\u0061\u006d\u0069\u006e\u0020\u0061\u006d\u0061\u0078\u0020\u0062\u006d\u0069\u006e\u0020\u0062\u006d\u0061\u0078\u005d\u0020\u0064\u0065\u0066\u0061u\u006c\u0074\u0020\u0064\u0065\u0063\u006f\u0064\u0065 \u0061\u0072r\u0061\u0079")
		_befg = _aabd.DecodeArray()
	}
	_dfgb := _bba.NewReader(img.getBase())
	_agbd := _eede.NewImageBase(int(img.Width), int(img.Height), int(img.BitsPerComponent), 3, nil, img._caeaf, img._ccdge)
	_efb := _bba.NewWriter(_agbd)
	_dbebe := _bg.Pow(2, float64(img.BitsPerComponent)) - 1
	_beac := make([]uint32, 3)
	var (
		_bdad                                             error
		Ls, As, Bs, L, M, N, X, Y, Z, _efaa, _geff, _dbca float64
	)
	for {
		_bdad = _dfgb.ReadSamples(_beac)
		if _bdad == _ge.EOF {
			break
		} else if _bdad != nil {
			return img, _bdad
		}
		Ls = float64(_beac[0]) / _dbebe
		As = float64(_beac[1]) / _dbebe
		Bs = float64(_beac[2]) / _dbebe
		Ls = _eede.LinearInterpolate(Ls, 0.0, 1.0, _befg[0], _befg[1])
		As = _eede.LinearInterpolate(As, 0.0, 1.0, _befg[2], _befg[3])
		Bs = _eede.LinearInterpolate(Bs, 0.0, 1.0, _befg[4], _befg[5])
		L = (Ls+16)/116 + As/500
		M = (Ls + 16) / 116
		N = (Ls+16)/116 - Bs/200
		X = _aabd.WhitePoint[0] * _eded(L)
		Y = _aabd.WhitePoint[1] * _eded(M)
		Z = _aabd.WhitePoint[2] * _eded(N)
		_efaa = 3.240479*X + -1.537150*Y + -0.498535*Z
		_geff = -0.969256*X + 1.875992*Y + 0.041556*Z
		_dbca = 0.055648*X + -0.204043*Y + 1.057311*Z
		_efaa = _bg.Min(_bg.Max(_efaa, 0), 1.0)
		_geff = _bg.Min(_bg.Max(_geff, 0), 1.0)
		_dbca = _bg.Min(_bg.Max(_dbca, 0), 1.0)
		_beac[0] = uint32(_efaa * _dbebe)
		_beac[1] = uint32(_geff * _dbebe)
		_beac[2] = uint32(_dbca * _dbebe)
		if _bdad = _efb.WriteSamples(_beac); _bdad != nil {
			return img, _bdad
		}
	}
	return _ddbab(&_agbd), nil
}

// AddExtGState adds a graphics state to the XObject resources.
func (_eaae *PdfPage) AddExtGState(name _fed.PdfObjectName, egs *_fed.PdfObjectDictionary) error {
	if _eaae.Resources == nil {
		_eaae.Resources = NewPdfPageResources()
	}
	if _eaae.Resources.ExtGState == nil {
		_eaae.Resources.ExtGState = _fed.MakeDict()
	}
	_aeggf, _gbcbe := _fed.TraceToDirectObject(_eaae.Resources.ExtGState).(*_fed.PdfObjectDictionary)
	if !_gbcbe {
		_fef.Log.Debug("\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0045\u0078t\u0047\u0053\u0074\u0061\u0074\u0065\u0020\u0064i\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u003a\u0020\u0025\u0076", _fed.TraceToDirectObject(_eaae.Resources.ExtGState))
		return _bb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_aeggf.Set(name, egs)
	return nil
}

// ToPdfObject returns the PDF representation of the shading pattern.
func (_bacac *PdfShadingPattern) ToPdfObject() _fed.PdfObject {
	_bacac.PdfPattern.ToPdfObject()
	_adeeeg := _bacac.getDict()
	if _bacac.Shading != nil {
		_adeeeg.Set("\u0053h\u0061\u0064\u0069\u006e\u0067", _bacac.Shading.ToPdfObject())
	}
	if _bacac.Matrix != nil {
		_adeeeg.Set("\u004d\u0061\u0074\u0072\u0069\u0078", _bacac.Matrix)
	}
	if _bacac.ExtGState != nil {
		_adeeeg.Set("\u0045x\u0074\u0047\u0053\u0074\u0061\u0074e", _bacac.ExtGState)
	}
	return _bacac._fbefb
}
func _gbcga(_addag *_fed.PdfObjectDictionary) (*PdfShadingType2, error) {
	_fcbfeg := PdfShadingType2{}
	_bcgggc := _addag.Get("\u0043\u006f\u006f\u0072\u0064\u0073")
	if _bcgggc == nil {
		_fef.Log.Debug("R\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0061\u0074\u0074\u0072\u0069b\u0075\u0074\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u003a\u0020\u0020\u0043\u006f\u006f\u0072d\u0073")
		return nil, ErrRequiredAttributeMissing
	}
	_cffgbd, _fgee := _bcgggc.(*_fed.PdfObjectArray)
	if !_fgee {
		_fef.Log.Debug("\u0043\u006f\u006f\u0072d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _bcgggc)
		return nil, _bb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _cffgbd.Len() != 4 {
		_fef.Log.Debug("\u0043\u006f\u006f\u0072d\u0073\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074 \u0034\u0020\u0028\u0067\u006f\u0074\u0020%\u0064\u0029", _cffgbd.Len())
		return nil, _bb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065")
	}
	_fcbfeg.Coords = _cffgbd
	if _dcdae := _addag.Get("\u0044\u006f\u006d\u0061\u0069\u006e"); _dcdae != nil {
		_dcdae = _fed.TraceToDirectObject(_dcdae)
		_bfddc, _adcfe := _dcdae.(*_fed.PdfObjectArray)
		if !_adcfe {
			_fef.Log.Debug("\u0044\u006f\u006d\u0061i\u006e\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _dcdae)
			return nil, _bb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_fcbfeg.Domain = _bfddc
	}
	_bcgggc = _addag.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e")
	if _bcgggc == nil {
		_fef.Log.Debug("\u0052\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0020\u0046\u0075\u006ec\u0074\u0069\u006f\u006e")
		return nil, ErrRequiredAttributeMissing
	}
	_fcbfeg.Function = []PdfFunction{}
	if _bagee, _gdbbcb := _bcgggc.(*_fed.PdfObjectArray); _gdbbcb {
		for _, _eaeaf := range _bagee.Elements() {
			_caeaa, _edcac := _bggad(_eaeaf)
			if _edcac != nil {
				_fef.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _edcac)
				return nil, _edcac
			}
			_fcbfeg.Function = append(_fcbfeg.Function, _caeaa)
		}
	} else {
		_bffcg, _cedgb := _bggad(_bcgggc)
		if _cedgb != nil {
			_fef.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _cedgb)
			return nil, _cedgb
		}
		_fcbfeg.Function = append(_fcbfeg.Function, _bffcg)
	}
	if _caab := _addag.Get("\u0045\u0078\u0074\u0065\u006e\u0064"); _caab != nil {
		_caab = _fed.TraceToDirectObject(_caab)
		_ggdbc, _aefg := _caab.(*_fed.PdfObjectArray)
		if !_aefg {
			_fef.Log.Debug("\u004d\u0061\u0074\u0072i\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _caab)
			return nil, _fed.ErrTypeError
		}
		if _ggdbc.Len() != 2 {
			_fef.Log.Debug("\u0045\u0078\u0074\u0065n\u0064\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074 \u0032\u0020\u0028\u0067\u006f\u0074\u0020%\u0064\u0029", _ggdbc.Len())
			return nil, ErrInvalidAttribute
		}
		_fcbfeg.Extend = _ggdbc
	}
	return &_fcbfeg, nil
}

// SetContext set the sub annotation (context).
func (_dccd *PdfShading) SetContext(ctx PdfModel) { _dccd._cebded = ctx }
func (_ebc *PdfReader) newPdfActionGoTo3DViewFromDict(_fgb *_fed.PdfObjectDictionary) (*PdfActionGoTo3DView, error) {
	return &PdfActionGoTo3DView{TA: _fgb.Get("\u0054\u0041"), V: _fgb.Get("\u0056")}, nil
}

// ImageToRGB returns the passed in image. Method exists in order to satisfy
// the PdfColorspace interface.
func (_geed *PdfColorspaceDeviceRGB) ImageToRGB(img Image) (Image, error) { return img, nil }

// NewPdfAnnotationStrikeOut returns a new text strikeout annotation.
func NewPdfAnnotationStrikeOut() *PdfAnnotationStrikeOut {
	_cff := NewPdfAnnotation()
	_feac := &PdfAnnotationStrikeOut{}
	_feac.PdfAnnotation = _cff
	_feac.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_cff.SetContext(_feac)
	return _feac
}

// ColorFromPdfObjects loads the color from PDF objects.
// The first objects (if present) represent the color in underlying colorspace.  The last one represents
// the name of the pattern.
func (_fga *PdfColorspaceSpecialPattern) ColorFromPdfObjects(objects []_fed.PdfObject) (PdfColor, error) {
	if len(objects) < 1 {
		return nil, _bb.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066 \u0070\u0061\u0072\u0061\u006d\u0065\u0074e\u0072\u0073")
	}
	_bdac := &PdfColorPattern{}
	_dcdf, _cege := objects[len(objects)-1].(*_fed.PdfObjectName)
	if !_cege {
		_fef.Log.Debug("\u0050\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006ft\u0020a\u0020\u006e\u0061\u006d\u0065\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", objects[len(objects)-1])
		return nil, ErrTypeCheck
	}
	_bdac.PatternName = *_dcdf
	if len(objects) > 1 {
		_addbf := objects[0 : len(objects)-1]
		if _fga.UnderlyingCS == nil {
			_fef.Log.Debug("P\u0061\u0074t\u0065\u0072\u006e\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0077\u0069\u0074\u0068\u0020\u0064\u0065\u0066\u0069\u006ee\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0063\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u0020\u0062\u0075\u0074\u0020\u0075\u006e\u0064\u0065\u0072\u006c\u0079i\u006e\u0067\u0020\u0063\u0073\u0020\u006d\u0069\u0073\u0073\u0069n\u0067")
			return nil, _bb.New("\u0075n\u0064\u0065\u0072\u006cy\u0069\u006e\u0067\u0020\u0043S\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d")
		}
		_daeb, _bgee := _fga.UnderlyingCS.ColorFromPdfObjects(_addbf)
		if _bgee != nil {
			_fef.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055n\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0076\u0069\u0061\u0020\u0075\u006e\u0064\u0065\u0072\u006c\u0079\u0069\u006e\u0067\u0020\u0063\u0073\u003a\u0020\u0025\u0076", _bgee)
			return nil, _bgee
		}
		_bdac.Color = _daeb
	}
	return _bdac, nil
}

// PdfColorDeviceCMYK is a CMYK32 color, where each component is defined in the range 0.0 - 1.0 where 1.0 is the primary intensity.
type PdfColorDeviceCMYK [4]float64

// PdfAnnotation3D represents 3D annotations.
// (Section 13.6.2).
type PdfAnnotation3D struct {
	*PdfAnnotation
	T3DD _fed.PdfObject
	T3DV _fed.PdfObject
	T3DA _fed.PdfObject
	T3DI _fed.PdfObject
	T3DB _fed.PdfObject
}

// NewPdfActionLaunch returns a new "launch" action.
func NewPdfActionLaunch() *PdfActionLaunch {
	_fcd := NewPdfAction()
	_ac := &PdfActionLaunch{}
	_ac.PdfAction = _fcd
	_fcd.SetContext(_ac)
	return _ac
}

// String returns a string representation of what flags are set.
func (_ebef FieldFlag) String() string {
	_fcfad := ""
	if _ebef == FieldFlagClear {
		_fcfad = "\u0043\u006c\u0065a\u0072"
		return _fcfad
	}
	if _ebef&FieldFlagReadOnly > 0 {
		_fcfad += "\u007cR\u0065\u0061\u0064\u004f\u006e\u006cy"
	}
	if _ebef&FieldFlagRequired > 0 {
		_fcfad += "\u007cR\u0065\u0061\u0064\u004f\u006e\u006cy"
	}
	if _ebef&FieldFlagNoExport > 0 {
		_fcfad += "\u007cN\u006f\u0045\u0078\u0070\u006f\u0072t"
	}
	if _ebef&FieldFlagNoToggleToOff > 0 {
		_fcfad += "\u007c\u004e\u006f\u0054\u006f\u0067\u0067\u006c\u0065T\u006f\u004f\u0066\u0066"
	}
	if _ebef&FieldFlagRadio > 0 {
		_fcfad += "\u007c\u0052\u0061\u0064\u0069\u006f"
	}
	if _ebef&FieldFlagPushbutton > 0 {
		_fcfad += "|\u0050\u0075\u0073\u0068\u0062\u0075\u0074\u0074\u006f\u006e"
	}
	if _ebef&FieldFlagRadiosInUnision > 0 {
		_fcfad += "\u007c\u0052a\u0064\u0069\u006fs\u0049\u006e\u0055\u006e\u0069\u0073\u0069\u006f\u006e"
	}
	if _ebef&FieldFlagMultiline > 0 {
		_fcfad += "\u007c\u004d\u0075\u006c\u0074\u0069\u006c\u0069\u006e\u0065"
	}
	if _ebef&FieldFlagPassword > 0 {
		_fcfad += "\u007cP\u0061\u0073\u0073\u0077\u006f\u0072d"
	}
	if _ebef&FieldFlagFileSelect > 0 {
		_fcfad += "|\u0046\u0069\u006c\u0065\u0053\u0065\u006c\u0065\u0063\u0074"
	}
	if _ebef&FieldFlagDoNotScroll > 0 {
		_fcfad += "\u007c\u0044\u006fN\u006f\u0074\u0053\u0063\u0072\u006f\u006c\u006c"
	}
	if _ebef&FieldFlagComb > 0 {
		_fcfad += "\u007c\u0043\u006fm\u0062"
	}
	if _ebef&FieldFlagRichText > 0 {
		_fcfad += "\u007cR\u0069\u0063\u0068\u0054\u0065\u0078t"
	}
	if _ebef&FieldFlagDoNotSpellCheck > 0 {
		_fcfad += "\u007c\u0044o\u004e\u006f\u0074S\u0070\u0065\u006c\u006c\u0043\u0068\u0065\u0063\u006b"
	}
	if _ebef&FieldFlagCombo > 0 {
		_fcfad += "\u007c\u0043\u006f\u006d\u0062\u006f"
	}
	if _ebef&FieldFlagEdit > 0 {
		_fcfad += "\u007c\u0045\u0064i\u0074"
	}
	if _ebef&FieldFlagSort > 0 {
		_fcfad += "\u007c\u0053\u006fr\u0074"
	}
	if _ebef&FieldFlagMultiSelect > 0 {
		_fcfad += "\u007c\u004d\u0075l\u0074\u0069\u0053\u0065\u006c\u0065\u0063\u0074"
	}
	if _ebef&FieldFlagCommitOnSelChange > 0 {
		_fcfad += "\u007cC\u006fm\u006d\u0069\u0074\u004f\u006eS\u0065\u006cC\u0068\u0061\u006e\u0067\u0065"
	}
	return _eed.Trim(_fcfad, "\u007c")
}

// DefaultImageHandler is the default implementation of the ImageHandler using the standard go library.
type DefaultImageHandler struct{}
type pdfFontType0 struct {
	fontCommon
	_deadb         *_fed.PdfIndirectObject
	_eeabd         _dg.TextEncoder
	Encoding       _fed.PdfObject
	DescendantFont *PdfFont
	_adgcc         *_edf.CMap
}

// PdfActionJavaScript represents a javaScript action.
type PdfActionJavaScript struct {
	*PdfAction
	JS _fed.PdfObject
}

// ColorFromFloats returns a new PdfColorDevice based on the input slice of
// color components. The slice should contain four elements representing the
// cyan, magenta, yellow and key components of the color. The values of the
// elements should be between 0 and 1.
func (_gcf *PdfColorspaceDeviceCMYK) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 4 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_ecbc := vals[0]
	if _ecbc < 0.0 || _ecbc > 1.0 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_eccae := vals[1]
	if _eccae < 0.0 || _eccae > 1.0 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_abaf := vals[2]
	if _abaf < 0.0 || _abaf > 1.0 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_cefc := vals[3]
	if _cefc < 0.0 || _cefc > 1.0 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_eabd := NewPdfColorDeviceCMYK(_ecbc, _eccae, _abaf, _cefc)
	return _eabd, nil
}

// PdfShadingType2 is an Axial shading.
type PdfShadingType2 struct {
	*PdfShading
	Coords   *_fed.PdfObjectArray
	Domain   *_fed.PdfObjectArray
	Function []PdfFunction
	Extend   *_fed.PdfObjectArray
}

func _efaeg(_cddb *_fed.PdfIndirectObject) (*PdfOutline, error) {
	_bfbf, _dfcga := _cddb.PdfObject.(*_fed.PdfObjectDictionary)
	if !_dfcga {
		return nil, _d.Errorf("\u006f\u0075\u0074l\u0069\u006e\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	_gffd := NewPdfOutline()
	if _cgdea := _bfbf.Get("\u0054\u0079\u0070\u0065"); _cgdea != nil {
		_acecf, _fbae := _cgdea.(*_fed.PdfObjectName)
		if _fbae {
			if *_acecf != "\u004f\u0075\u0074\u006c\u0069\u006e\u0065\u0073" {
				_fef.Log.Debug("E\u0052\u0052\u004f\u0052\u0020\u0054y\u0070\u0065\u0020\u0021\u003d\u0020\u004f\u0075\u0074l\u0069\u006e\u0065s\u0020(\u0025\u0073\u0029", *_acecf)
			}
		}
	}
	if _bgbdc := _bfbf.Get("\u0043\u006f\u0075n\u0074"); _bgbdc != nil {
		_edfad, _fcfce := _fed.GetNumberAsInt64(_bgbdc)
		if _fcfce != nil {
			return nil, _fcfce
		}
		_gffd.Count = &_edfad
	}
	return _gffd, nil
}

const (
	BorderStyleSolid     BorderStyle = iota
	BorderStyleDashed    BorderStyle = iota
	BorderStyleBeveled   BorderStyle = iota
	BorderStyleInset     BorderStyle = iota
	BorderStyleUnderline BorderStyle = iota
)

// GetOptimizer returns current PDF optimizer.
func (_feec *PdfWriter) GetOptimizer() Optimizer { return _feec._ggfgb }
func (_bbegb *PdfReader) loadDSS() (*DSS, error) {
	if _bbegb._cdfggf.GetCrypter() != nil && !_bbegb._cdfggf.IsAuthenticated() {
		return nil, _d.Errorf("\u0066\u0069\u006ce\u0020\u006e\u0065\u0065d\u0020\u0074\u006f\u0020\u0062\u0065\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	}
	_gagaf := _bbegb._bfcdc.Get("\u0044\u0053\u0053")
	if _gagaf == nil {
		return nil, nil
	}
	_bacc, _ := _fed.GetIndirect(_gagaf)
	_gagaf = _fed.TraceToDirectObject(_gagaf)
	switch _fdabc := _gagaf.(type) {
	case *_fed.PdfObjectNull:
		return nil, nil
	case *_fed.PdfObjectDictionary:
		return _bcbbb(_bacc, _fdabc)
	}
	return nil, _d.Errorf("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0044\u0053\u0053 \u0065\u006e\u0074\u0072y \u0025\u0054", _gagaf)
}

// GetPdfName returns the PDF name used to indicate the border style.
// (Table 166 p. 395).
func (_acdf *BorderStyle) GetPdfName() string {
	switch *_acdf {
	case BorderStyleSolid:
		return "\u0053"
	case BorderStyleDashed:
		return "\u0044"
	case BorderStyleBeveled:
		return "\u0042"
	case BorderStyleInset:
		return "\u0049"
	case BorderStyleUnderline:
		return "\u0055"
	}
	return ""
}

// PdfFontDescriptor specifies metrics and other attributes of a font and can refer to a FontFile
// for embedded fonts.
// 9.8 Font Descriptors (page 281)
type PdfFontDescriptor struct {
	FontName     _fed.PdfObject
	FontFamily   _fed.PdfObject
	FontStretch  _fed.PdfObject
	FontWeight   _fed.PdfObject
	Flags        _fed.PdfObject
	FontBBox     _fed.PdfObject
	ItalicAngle  _fed.PdfObject
	Ascent       _fed.PdfObject
	Descent      _fed.PdfObject
	Leading      _fed.PdfObject
	CapHeight    _fed.PdfObject
	XHeight      _fed.PdfObject
	StemV        _fed.PdfObject
	StemH        _fed.PdfObject
	AvgWidth     _fed.PdfObject
	MaxWidth     _fed.PdfObject
	MissingWidth _fed.PdfObject
	FontFile     _fed.PdfObject
	FontFile2    _fed.PdfObject
	FontFile3    _fed.PdfObject
	CharSet      _fed.PdfObject
	_ffda        int
	_ffegc       float64
	*fontFile
	_afef *_geg.TtfType

	// Additional entries for CIDFonts
	Style  _fed.PdfObject
	Lang   _fed.PdfObject
	FD     _fed.PdfObject
	CIDSet _fed.PdfObject
	_eafa  *_fed.PdfIndirectObject
}

// NewPdfAnnotationFileAttachment returns a new file attachment annotation.
func NewPdfAnnotationFileAttachment() *PdfAnnotationFileAttachment {
	_def := NewPdfAnnotation()
	_bgbde := &PdfAnnotationFileAttachment{}
	_bgbde.PdfAnnotation = _def
	_bgbde.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_def.SetContext(_bgbde)
	return _bgbde
}

// SetNameDictionary sets the Names entry in the PDF catalog.
// See section 7.7.4 "Name Dictionary" (p. 80 PDF32000_2008).
func (_cfabc *PdfWriter) SetNameDictionary(names _fed.PdfObject) error {
	if names == nil {
		return nil
	}
	_fef.Log.Trace("\u0053e\u0074\u0074\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006co\u0067\u0020\u004e\u0061\u006d\u0065\u0073\u002e\u002e\u002e")
	_cfabc._cdefg.Set("\u004e\u0061\u006de\u0073", names)
	return _cfabc.addObjects(names)
}

// ToJBIG2Image converts current image to the core.JBIG2Image.
func (_dbbe *Image) ToJBIG2Image() (*_fed.JBIG2Image, error) {
	_dgbef, _egbaf := _dbbe.ToGoImage()
	if _egbaf != nil {
		return nil, _egbaf
	}
	return _fed.GoImageToJBIG2(_dgbef, _fed.JB2ImageAutoThreshold)
}

// String returns a string that describes `base`.
func (_eggaff fontCommon) String() string {
	return _d.Sprintf("\u0046\u004f\u004e\u0054\u007b\u0025\u0073\u007d", _eggaff.coreString())
}

// SetNamedDestinations sets the Dests entry in the PDF catalog.
// See section 12.3.2.3 "Named Destinations" (p. 367 PDF32000_2008).
func (_bceda *PdfWriter) SetNamedDestinations(dests _fed.PdfObject) error {
	if dests == nil {
		return nil
	}
	_fef.Log.Trace("\u0053e\u0074\u0074\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006co\u0067\u0020\u0044\u0065\u0073\u0074\u0073\u002e\u002e\u002e")
	_bceda._cdefg.Set("\u0044\u0065\u0073t\u0073", dests)
	return _bceda.addObjects(dests)
}
func _aedaf(_aece *fontCommon) *pdfCIDFontType2 { return &pdfCIDFontType2{fontCommon: *_aece} }

// ImageToRGB converts image in CalGray color space to RGB (A, B, C -> X, Y, Z).
func (_dca *PdfColorspaceCalGray) ImageToRGB(img Image) (Image, error) {
	_agdd := _bba.NewReader(img.getBase())
	_ddba := _eede.NewImageBase(int(img.Width), int(img.Height), int(img.BitsPerComponent), 3, nil, nil, nil)
	_dcea := _bba.NewWriter(_ddba)
	_beca := _bg.Pow(2, float64(img.BitsPerComponent)) - 1
	_bbcf := make([]uint32, 3)
	var (
		_edb                                  uint32
		ANorm, X, Y, Z, _gbfbd, _ffgc, _egfcf float64
		_agcf                                 error
	)
	for {
		_edb, _agcf = _agdd.ReadSample()
		if _agcf == _ge.EOF {
			break
		} else if _agcf != nil {
			return img, _agcf
		}
		ANorm = float64(_edb) / _beca
		X = _dca.WhitePoint[0] * _bg.Pow(ANorm, _dca.Gamma)
		Y = _dca.WhitePoint[1] * _bg.Pow(ANorm, _dca.Gamma)
		Z = _dca.WhitePoint[2] * _bg.Pow(ANorm, _dca.Gamma)
		_gbfbd = 3.240479*X + -1.537150*Y + -0.498535*Z
		_ffgc = -0.969256*X + 1.875992*Y + 0.041556*Z
		_egfcf = 0.055648*X + -0.204043*Y + 1.057311*Z
		_gbfbd = _bg.Min(_bg.Max(_gbfbd, 0), 1.0)
		_ffgc = _bg.Min(_bg.Max(_ffgc, 0), 1.0)
		_egfcf = _bg.Min(_bg.Max(_egfcf, 0), 1.0)
		_bbcf[0] = uint32(_gbfbd * _beca)
		_bbcf[1] = uint32(_ffgc * _beca)
		_bbcf[2] = uint32(_egfcf * _beca)
		if _agcf = _dcea.WriteSamples(_bbcf); _agcf != nil {
			return img, _agcf
		}
	}
	return _ddbab(&_ddba), nil
}

// ToPdfObject implements interface PdfModel.
func (_cbebe *PdfFilespec) ToPdfObject() _fed.PdfObject {
	_feeg := _cbebe.getDict()
	_feeg.Clear()
	_feeg.Set("\u0054\u0079\u0070\u0065", _fed.MakeName("\u0046\u0069\u006c\u0065\u0073\u0070\u0065\u0063"))
	_feeg.SetIfNotNil("\u0046\u0053", _cbebe.FS)
	_feeg.SetIfNotNil("\u0046", _cbebe.F)
	_feeg.SetIfNotNil("\u0055\u0046", _cbebe.UF)
	_feeg.SetIfNotNil("\u0044\u004f\u0053", _cbebe.DOS)
	_feeg.SetIfNotNil("\u004d\u0061\u0063", _cbebe.Mac)
	_feeg.SetIfNotNil("\u0055\u006e\u0069\u0078", _cbebe.Unix)
	_feeg.SetIfNotNil("\u0049\u0044", _cbebe.ID)
	_feeg.SetIfNotNil("\u0056", _cbebe.V)
	_feeg.SetIfNotNil("\u0045\u0046", _cbebe.EF)
	_feeg.SetIfNotNil("\u0052\u0046", _cbebe.RF)
	_feeg.SetIfNotNil("\u0044\u0065\u0073\u0063", _cbebe.Desc)
	_feeg.SetIfNotNil("\u0043\u0049", _cbebe.CI)
	return _cbebe._dfeff
}

// PdfAnnotationTrapNet represents TrapNet annotations.
// (Section 12.5.6.21).
type PdfAnnotationTrapNet struct{ *PdfAnnotation }

// GetModelFromPrimitive returns the model corresponding to the `primitive` PdfObject.
func (_bfca *modelManager) GetModelFromPrimitive(primitive _fed.PdfObject) PdfModel {
	model, _eadd := _bfca._dded[primitive]
	if !_eadd {
		return nil
	}
	return model
}
func (_aabed *PdfReader) newPdfSignatureFromIndirect(_dfdcb *_fed.PdfIndirectObject) (*PdfSignature, error) {
	_cfbba, _badce := _dfdcb.PdfObject.(*_fed.PdfObjectDictionary)
	if !_badce {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0053\u0069\u0067\u006e\u0061\u0074\u0075\u0072e\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u006e\u006ft\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020a \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
		return nil, ErrTypeCheck
	}
	if _gdfaf, _gecg := _aabed._dcfcd.GetModelFromPrimitive(_dfdcb).(*PdfSignature); _gecg {
		return _gdfaf, nil
	}
	_bdge := &PdfSignature{}
	_bdge._gccdf = _dfdcb
	_bdge.Type, _ = _fed.GetName(_cfbba.Get("\u0054\u0079\u0070\u0065"))
	_bdge.Filter, _badce = _fed.GetName(_cfbba.Get("\u0046\u0069\u006c\u0074\u0065\u0072"))
	if !_badce {
		_fef.Log.Error("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053i\u0067\u006e\u0061\u0074\u0075r\u0065\u0020\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrInvalidAttribute
	}
	_bdge.SubFilter, _ = _fed.GetName(_cfbba.Get("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r"))
	_bdge.Contents, _badce = _fed.GetString(_cfbba.Get("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"))
	if !_badce {
		_fef.Log.Error("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0063\u006f\u006et\u0065\u006e\u0074\u0073\u0020\u006d\u0069s\u0073\u0069\u006e\u0067")
		return nil, ErrInvalidAttribute
	}
	_bdge.Cert = _cfbba.Get("\u0043\u0065\u0072\u0074")
	_bdge.ByteRange, _ = _fed.GetArray(_cfbba.Get("\u0042y\u0074\u0065\u0052\u0061\u006e\u0067e"))
	_bdge.Reference, _ = _fed.GetArray(_cfbba.Get("\u0052e\u0066\u0065\u0072\u0065\u006e\u0063e"))
	_bdge.Changes, _ = _fed.GetArray(_cfbba.Get("\u0043h\u0061\u006e\u0067\u0065\u0073"))
	_bdge.Name, _ = _fed.GetString(_cfbba.Get("\u004e\u0061\u006d\u0065"))
	_bdge.M, _ = _fed.GetString(_cfbba.Get("\u004d"))
	_bdge.Location, _ = _fed.GetString(_cfbba.Get("\u004c\u006f\u0063\u0061\u0074\u0069\u006f\u006e"))
	_bdge.Reason, _ = _fed.GetString(_cfbba.Get("\u0052\u0065\u0061\u0073\u006f\u006e"))
	_bdge.ContactInfo, _ = _fed.GetString(_cfbba.Get("C\u006f\u006e\u0074\u0061\u0063\u0074\u0049\u006e\u0066\u006f"))
	_bdge.R, _ = _fed.GetInt(_cfbba.Get("\u0052"))
	_bdge.V, _ = _fed.GetInt(_cfbba.Get("\u0056"))
	_bdge.PropBuild, _ = _fed.GetDict(_cfbba.Get("\u0050\u0072\u006f\u0070\u005f\u0042\u0075\u0069\u006c\u0064"))
	_bdge.PropAuthTime, _ = _fed.GetInt(_cfbba.Get("\u0050\u0072\u006f\u0070\u005f\u0041\u0075\u0074\u0068\u0054\u0069\u006d\u0065"))
	_bdge.PropAuthType, _ = _fed.GetName(_cfbba.Get("\u0050\u0072\u006f\u0070\u005f\u0041\u0075\u0074\u0068\u0054\u0079\u0070\u0065"))
	return _bdge, nil
}
func _dggg(_acdgd *_fed.PdfObjectDictionary) (*PdfTilingPattern, error) {
	_ccab := &PdfTilingPattern{}
	_eccce := _acdgd.Get("\u0050a\u0069\u006e\u0074\u0054\u0079\u0070e")
	if _eccce == nil {
		_fef.Log.Debug("\u0050\u0061\u0069\u006e\u0074\u0054\u0079\u0070\u0065\u0020\u006d\u0069s\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_ccfcbg, _eaddg := _eccce.(*_fed.PdfObjectInteger)
	if !_eaddg {
		_fef.Log.Debug("\u0050\u0061\u0069\u006e\u0074\u0054y\u0070\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0028\u0067\u006ft\u0020\u0025\u0054\u0029", _eccce)
		return nil, _fed.ErrTypeError
	}
	_ccab.PaintType = _ccfcbg
	_eccce = _acdgd.Get("\u0054\u0069\u006c\u0069\u006e\u0067\u0054\u0079\u0070\u0065")
	if _eccce == nil {
		_fef.Log.Debug("\u0054i\u006ci\u006e\u0067\u0054\u0079\u0070e\u0020\u006di\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_dafeg, _eaddg := _eccce.(*_fed.PdfObjectInteger)
	if !_eaddg {
		_fef.Log.Debug("\u0054\u0069\u006cin\u0067\u0054\u0079\u0070\u0065\u0020\u006e\u006f\u0074 \u0061n\u0020i\u006et\u0065\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _eccce)
		return nil, _fed.ErrTypeError
	}
	_ccab.TilingType = _dafeg
	_eccce = _acdgd.Get("\u0042\u0042\u006f\u0078")
	if _eccce == nil {
		_fef.Log.Debug("\u0042\u0042\u006fx\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_eccce = _fed.TraceToDirectObject(_eccce)
	_acbe, _eaddg := _eccce.(*_fed.PdfObjectArray)
	if !_eaddg {
		_fef.Log.Debug("\u0042B\u006f\u0078 \u0073\u0068\u006fu\u006c\u0064\u0020\u0062\u0065\u0020\u0073p\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0079\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061y\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _eccce)
		return nil, _fed.ErrTypeError
	}
	_eaeab, _bagd := NewPdfRectangle(*_acbe)
	if _bagd != nil {
		_fef.Log.Debug("\u0042\u0042\u006f\u0078\u0020\u0065\u0072\u0072\u006fr\u003a\u0020\u0025\u0076", _bagd)
		return nil, _bagd
	}
	_ccab.BBox = _eaeab
	_eccce = _acdgd.Get("\u0058\u0053\u0074e\u0070")
	if _eccce == nil {
		_fef.Log.Debug("\u0058\u0053\u0074\u0065\u0070\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_dcebd, _bagd := _fed.GetNumberAsFloat(_eccce)
	if _bagd != nil {
		_fef.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0058S\u0074e\u0070\u0020\u0061\u0073\u0020\u0066\u006c\u006f\u0061\u0074\u003a\u0020\u0025\u0076", _dcebd)
		return nil, _bagd
	}
	_ccab.XStep = _fed.MakeFloat(_dcebd)
	_eccce = _acdgd.Get("\u0059\u0053\u0074e\u0070")
	if _eccce == nil {
		_fef.Log.Debug("\u0059\u0053\u0074\u0065\u0070\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_cfefd, _bagd := _fed.GetNumberAsFloat(_eccce)
	if _bagd != nil {
		_fef.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0059S\u0074e\u0070\u0020\u0061\u0073\u0020\u0066\u006c\u006f\u0061\u0074\u003a\u0020\u0025\u0076", _cfefd)
		return nil, _bagd
	}
	_ccab.YStep = _fed.MakeFloat(_cfefd)
	_eccce = _acdgd.Get("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s")
	if _eccce == nil {
		_fef.Log.Debug("\u0052\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0073\u0020\u006d\u0069s\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_acdgd, _eaddg = _fed.TraceToDirectObject(_eccce).(*_fed.PdfObjectDictionary)
	if !_eaddg {
		return nil, _d.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0065\u0073\u006f\u0075\u0072\u0063e\u0020d\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0054\u0029", _eccce)
	}
	_gfcfb, _bagd := NewPdfPageResourcesFromDict(_acdgd)
	if _bagd != nil {
		return nil, _bagd
	}
	_ccab.Resources = _gfcfb
	if _gaabd := _acdgd.Get("\u004d\u0061\u0074\u0072\u0069\u0078"); _gaabd != nil {
		_cgbfg, _aeeb := _gaabd.(*_fed.PdfObjectArray)
		if !_aeeb {
			_fef.Log.Debug("\u004d\u0061\u0074\u0072i\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _gaabd)
			return nil, _fed.ErrTypeError
		}
		_ccab.Matrix = _cgbfg
	}
	return _ccab, nil
}

// GetContext returns the action context which contains the specific type-dependent context.
// The context represents the subaction.
func (_fb *PdfAction) GetContext() PdfModel {
	if _fb == nil {
		return nil
	}
	return _fb._fcc
}

// PdfAcroForm represents the AcroForm dictionary used for representation of form data in PDF.
type PdfAcroForm struct {
	Fields          *[]*PdfField
	NeedAppearances *_fed.PdfObjectBool
	SigFlags        *_fed.PdfObjectInteger
	CO              *_fed.PdfObjectArray
	DR              *PdfPageResources
	DA              *_fed.PdfObjectString
	Q               *_fed.PdfObjectInteger
	XFA             _fed.PdfObject
	_ceed           *_fed.PdfIndirectObject
}

// StringToCharcodeBytes maps the provided string runes to charcode bytes and
// it returns the resulting slice of bytes, along with the number of runes
// which could not be converted. If the number of misses is 0, all string runes
// were successfully converted.
func (_eeeg *PdfFont) StringToCharcodeBytes(str string) ([]byte, int) {
	return _eeeg.RunesToCharcodeBytes([]rune(str))
}
func (_eadaa *PdfReader) newPdfFieldFromIndirectObject(_abfa *_fed.PdfIndirectObject, _ggcf *PdfField) (*PdfField, error) {
	if _bffea, _dfdc := _eadaa._dcfcd.GetModelFromPrimitive(_abfa).(*PdfField); _dfdc {
		return _bffea, nil
	}
	_eadbcc, _afcda := _fed.GetDict(_abfa)
	if !_afcda {
		return nil, _d.Errorf("\u0050\u0064f\u0046\u0069\u0065\u006c\u0064 \u0069\u006e\u0064\u0069\u0072e\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	_bfgf := NewPdfField()
	_bfgf._cbaae = _abfa
	_bfgf._cbaae.PdfObject = _eadbcc
	if _addbc, _fcda := _fed.GetName(_eadbcc.Get("\u0046\u0054")); _fcda {
		_bfgf.FT = _addbc
	}
	if _ggcf != nil {
		_bfgf.Parent = _ggcf
	}
	_bfgf.T, _ = _eadbcc.Get("\u0054").(*_fed.PdfObjectString)
	_bfgf.TU, _ = _eadbcc.Get("\u0054\u0055").(*_fed.PdfObjectString)
	_bfgf.TM, _ = _eadbcc.Get("\u0054\u004d").(*_fed.PdfObjectString)
	_bfgf.Ff, _ = _eadbcc.Get("\u0046\u0066").(*_fed.PdfObjectInteger)
	_bfgf.V = _eadbcc.Get("\u0056")
	_bfgf.DV = _eadbcc.Get("\u0044\u0056")
	_bfgf.AA = _eadbcc.Get("\u0041\u0041")
	_acde := _bfgf.FT
	if _acde == nil && _ggcf != nil {
		_acde = _ggcf.FT
	}
	if _acde != nil {
		switch *_acde {
		case "\u0054\u0078":
			_bebc, _dcdfa := _ffadd(_eadbcc)
			if _dcdfa != nil {
				return nil, _dcdfa
			}
			_bebc.PdfField = _bfgf
			_bfgf._ggbfc = _bebc
		case "\u0043\u0068":
			_beaf, _cbgcf := _eaeac(_eadbcc)
			if _cbgcf != nil {
				return nil, _cbgcf
			}
			_beaf.PdfField = _bfgf
			_bfgf._ggbfc = _beaf
		case "\u0042\u0074\u006e":
			_adbeb, _bgefb := _abce(_eadbcc)
			if _bgefb != nil {
				return nil, _bgefb
			}
			_adbeb.PdfField = _bfgf
			_bfgf._ggbfc = _adbeb
		case "\u0053\u0069\u0067":
			_fafg, _bgbb := _eadaa.newPdfFieldSignatureFromDict(_eadbcc)
			if _bgbb != nil {
				return nil, _bgbb
			}
			_fafg.PdfField = _bfgf
			_bfgf._ggbfc = _fafg
		default:
			_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065d\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", *_bfgf.FT)
			return nil, _bb.New("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074\u0079p\u0065")
		}
	}
	if _cgbf, _eecf := _fed.GetName(_eadbcc.Get("\u0053u\u0062\u0074\u0079\u0070\u0065")); _eecf {
		if *_cgbf == "\u0057\u0069\u0064\u0067\u0065\u0074" {
			_fcff, _gabf := _eadaa.newPdfAnnotationFromIndirectObject(_abfa)
			if _gabf != nil {
				return nil, _gabf
			}
			_dabb, _efba := _fcff.GetContext().(*PdfAnnotationWidget)
			if !_efba {
				return nil, _bb.New("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0077\u0069\u0064\u0067e\u0074 \u0061n\u006e\u006f\u0074\u0061\u0074\u0069\u006fn")
			}
			_dabb._eagb = _bfgf
			_dabb.Parent = _bfgf._cbaae
			_bfgf.Annotations = append(_bfgf.Annotations, _dabb)
			return _bfgf, nil
		}
	}
	_fcbcbe := true
	if _gdef, _bcgdd := _fed.GetArray(_eadbcc.Get("\u004b\u0069\u0064\u0073")); _bcgdd {
		_edcee := make([]*_fed.PdfIndirectObject, 0, _gdef.Len())
		for _, _dcebb := range _gdef.Elements() {
			_ccegf, _edbe := _fed.GetIndirect(_dcebb)
			if !_edbe {
				_ffgae, _cdgc := _fed.GetStream(_dcebb)
				if _cdgc && _ffgae.PdfObjectDictionary != nil {
					_fcab, _afdg := _fed.GetNameVal(_ffgae.Get("\u0054\u0079\u0070\u0065"))
					if _afdg && _fcab == "\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061" {
						_fef.Log.Debug("E\u0052RO\u0052:\u0020f\u006f\u0072\u006d\u0020\u0066i\u0065\u006c\u0064 \u004b\u0069\u0064\u0073\u0020a\u0072\u0072\u0061y\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0073\u0020\u0069n\u0076\u0061\u006cid \u004d\u0065\u0074\u0061\u0064\u0061t\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e")
						continue
					}
				}
				return nil, _bb.New("n\u006f\u0074\u0020\u0061\u006e\u0020i\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0028\u0066\u006f\u0072\u006d\u0020\u0066\u0069\u0065\u006cd\u0029")
			}
			_ddec, _bfgc := _fed.GetDict(_ccegf)
			if !_bfgc {
				return nil, ErrTypeCheck
			}
			if _fcbcbe {
				_fcbcbe = !_bcegf(_ddec)
			}
			_edcee = append(_edcee, _ccegf)
		}
		for _, _afgge := range _edcee {
			if _fcbcbe {
				_bccg, _ebgcd := _eadaa.newPdfAnnotationFromIndirectObject(_afgge)
				if _ebgcd != nil {
					_fef.Log.Debug("\u0045r\u0072\u006fr\u0020\u006c\u006fa\u0064\u0069\u006e\u0067\u0020\u0077\u0069d\u0067\u0065\u0074\u0020\u0061\u006en\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u006f\u0072 \u0066\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u0076", _ebgcd)
					return nil, _ebgcd
				}
				_faef, _cefea := _bccg._adc.(*PdfAnnotationWidget)
				if !_cefea {
					return nil, ErrTypeCheck
				}
				_faef._eagb = _bfgf
				_bfgf.Annotations = append(_bfgf.Annotations, _faef)
			} else {
				_cgae, _cbag := _eadaa.newPdfFieldFromIndirectObject(_afgge, _bfgf)
				if _cbag != nil {
					_fef.Log.Debug("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0063\u0068\u0069\u006c\u0064\u0020\u0066\u0069\u0065\u006c\u0064: \u0025\u0076", _cbag)
					return nil, _cbag
				}
				_bfgf.Kids = append(_bfgf.Kids, _cgae)
			}
		}
	}
	return _bfgf, nil
}

// ColorToRGB converts a CalRGB color to an RGB color.
func (_cdabg *PdfColorspaceCalRGB) ColorToRGB(color PdfColor) (PdfColor, error) {
	_gggag, _cceb := color.(*PdfColorCalRGB)
	if !_cceb {
		_fef.Log.Debug("\u0049\u006e\u0070ut\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006e\u006f\u0074\u0020\u0063\u0061\u006c\u0020\u0072\u0067\u0062")
		return nil, _bb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_abgg := _gggag.A()
	_adcbf := _gggag.B()
	_egab := _gggag.C()
	X := _cdabg.Matrix[0]*_bg.Pow(_abgg, _cdabg.Gamma[0]) + _cdabg.Matrix[3]*_bg.Pow(_adcbf, _cdabg.Gamma[1]) + _cdabg.Matrix[6]*_bg.Pow(_egab, _cdabg.Gamma[2])
	Y := _cdabg.Matrix[1]*_bg.Pow(_abgg, _cdabg.Gamma[0]) + _cdabg.Matrix[4]*_bg.Pow(_adcbf, _cdabg.Gamma[1]) + _cdabg.Matrix[7]*_bg.Pow(_egab, _cdabg.Gamma[2])
	Z := _cdabg.Matrix[2]*_bg.Pow(_abgg, _cdabg.Gamma[0]) + _cdabg.Matrix[5]*_bg.Pow(_adcbf, _cdabg.Gamma[1]) + _cdabg.Matrix[8]*_bg.Pow(_egab, _cdabg.Gamma[2])
	_fdbaa := 3.240479*X + -1.537150*Y + -0.498535*Z
	_gbge := -0.969256*X + 1.875992*Y + 0.041556*Z
	_fgcad := 0.055648*X + -0.204043*Y + 1.057311*Z
	_fdbaa = _bg.Min(_bg.Max(_fdbaa, 0), 1.0)
	_gbge = _bg.Min(_bg.Max(_gbge, 0), 1.0)
	_fgcad = _bg.Min(_bg.Max(_fgcad, 0), 1.0)
	return NewPdfColorDeviceRGB(_fdbaa, _gbge, _fgcad), nil
}

// NewPdfReaderWithOpts creates a new PdfReader for an input io.ReadSeeker interface
// with a ReaderOpts.
// If ReaderOpts is nil it will be set to default value from NewReaderOpts.
func NewPdfReaderWithOpts(rs _ge.ReadSeeker, opts *ReaderOpts) (*PdfReader, error) {
	const _gcgeb = "\u006d\u006f\u0064\u0065\u006c\u003a\u004e\u0065\u0077\u0050\u0064f\u0052\u0065\u0061\u0064\u0065\u0072\u0057\u0069\u0074\u0068O\u0070\u0074\u0073"
	return _ecagf(rs, opts, true, _gcgeb)
}
func _dfab() string { _abadca.Lock(); defer _abadca.Unlock(); return _eebc }

// NewPdfAnnotationPopup returns a new popup annotation.
func NewPdfAnnotationPopup() *PdfAnnotationPopup {
	_afg := NewPdfAnnotation()
	_dgda := &PdfAnnotationPopup{}
	_dgda.PdfAnnotation = _afg
	_afg.SetContext(_dgda)
	return _dgda
}

// NewPdfRectangle creates a PDF rectangle object based on an input array of 4 integers.
// Defining the lower left (LL) and upper right (UR) corners with
// floating point numbers.
func NewPdfRectangle(arr _fed.PdfObjectArray) (*PdfRectangle, error) {
	_caae := PdfRectangle{}
	if arr.Len() != 4 {
		return nil, _bb.New("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0072\u0065\u0063\u0074\u0061\u006e\u0067\u006c\u0065\u0020\u0061\u0072r\u0061\u0079\u002c\u0020\u006c\u0065\u006e \u0021\u003d\u0020\u0034")
	}
	var _fgddb error
	_caae.Llx, _fgddb = _fed.GetNumberAsFloat(arr.Get(0))
	if _fgddb != nil {
		return nil, _fgddb
	}
	_caae.Lly, _fgddb = _fed.GetNumberAsFloat(arr.Get(1))
	if _fgddb != nil {
		return nil, _fgddb
	}
	_caae.Urx, _fgddb = _fed.GetNumberAsFloat(arr.Get(2))
	if _fgddb != nil {
		return nil, _fgddb
	}
	_caae.Ury, _fgddb = _fed.GetNumberAsFloat(arr.Get(3))
	if _fgddb != nil {
		return nil, _fgddb
	}
	return &_caae, nil
}
func (_bedac *PdfPage) getParentResources() (*PdfPageResources, error) {
	_badffd := _bedac.Parent
	for _badffd != nil {
		_cdggc, _abfea := _fed.GetDict(_badffd)
		if !_abfea {
			_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020n\u006f\u0064\u0065")
			return nil, _bb.New("i\u006e\u0076\u0061\u006cid\u0020p\u0061\u0072\u0065\u006e\u0074 \u006f\u0062\u006a\u0065\u0063\u0074")
		}
		if _baada := _cdggc.Get("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s"); _baada != nil {
			_afagg, _ggbc := _fed.GetDict(_baada)
			if !_ggbc {
				return nil, _bb.New("i\u006e\u0076\u0061\u006cid\u0020r\u0065\u0073\u006f\u0075\u0072c\u0065\u0020\u0064\u0069\u0063\u0074")
			}
			_abdfe, _cbfd := NewPdfPageResourcesFromDict(_afagg)
			if _cbfd != nil {
				return nil, _cbfd
			}
			return _abdfe, nil
		}
		_badffd = _cdggc.Get("\u0050\u0061\u0072\u0065\u006e\u0074")
	}
	return nil, nil
}
func (_acgdd *PdfWriter) copyObjects() {
	_gbaab := make(map[_fed.PdfObject]_fed.PdfObject)
	_ggbbb := make([]_fed.PdfObject, 0, len(_acgdd._gcbcf))
	_bgcga := make(map[_fed.PdfObject]struct{}, len(_acgdd._gcbcf))
	_gcgfb := make(map[_fed.PdfObject]struct{})
	for _, _aacdc := range _acgdd._gcbcf {
		_aaead := _acgdd.copyObject(_aacdc, _gbaab, _gcgfb, false)
		if _, _dcgeac := _gcgfb[_aacdc]; _dcgeac {
			continue
		}
		_ggbbb = append(_ggbbb, _aaead)
		_bgcga[_aaead] = struct{}{}
	}
	_acgdd._gcbcf = _ggbbb
	_acgdd._bdadf = _bgcga
	_acgdd._egbgf = _acgdd.copyObject(_acgdd._egbgf, _gbaab, nil, false).(*_fed.PdfIndirectObject)
	_acgdd._aeacb = _acgdd.copyObject(_acgdd._aeacb, _gbaab, nil, false).(*_fed.PdfIndirectObject)
	if _acgdd._cfdabb != nil {
		_acgdd._cfdabb = _acgdd.copyObject(_acgdd._cfdabb, _gbaab, nil, false).(*_fed.PdfIndirectObject)
	}
	if _acgdd._bgeec {
		_afagf := make(map[_fed.PdfObject]int64)
		for _befgc, _geeea := range _acgdd._afgcd {
			if _fecdc, _bebf := _gbaab[_befgc]; _bebf {
				_afagf[_fecdc] = _geeea
			} else {
				_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020a\u0070\u0070\u0065n\u0064\u0020\u006d\u006fd\u0065\u0020\u002d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0063\u006f\u0070\u0079\u0020\u006e\u006f\u0074\u0020\u0069\u006e\u0020\u006d\u0061\u0070")
			}
		}
		_acgdd._afgcd = _afagf
	}
}
func (_gege *PdfColorspaceDeviceCMYK) String() string {
	return "\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b"
}

// SetContext sets the sub action (context).
func (_bbb *PdfAction) SetContext(ctx PdfModel) { _bbb._fcc = ctx }

// GetContext returns the PdfField context which is the more specific field data type, e.g. PdfFieldButton
// for a button field.
func (_efgd *PdfField) GetContext() PdfModel { return _efgd._ggbfc }
func _cabef(_cfccf *_fed.PdfObjectDictionary, _dbce *fontCommon, _addf _dg.TextEncoder) (*pdfFontSimple, error) {
	_ffegg := _acadg(_dbce)
	_ffegg._cffd = _addf
	if _addf == nil {
		_fbeeb := _cfccf.Get("\u0046i\u0072\u0073\u0074\u0043\u0068\u0061r")
		if _fbeeb == nil {
			_fbeeb = _fed.MakeInteger(0)
		}
		_ffegg.FirstChar = _fbeeb
		_bcgcd, _cdeg := _fed.GetIntVal(_fbeeb)
		if !_cdeg {
			_fef.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u0046i\u0072s\u0074C\u0068\u0061\u0072\u0020\u0074\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029", _fbeeb)
			return nil, _fed.ErrTypeError
		}
		_adgg := _dg.CharCode(_bcgcd)
		_fbeeb = _cfccf.Get("\u004c\u0061\u0073\u0074\u0043\u0068\u0061\u0072")
		if _fbeeb == nil {
			_fbeeb = _fed.MakeInteger(255)
		}
		_ffegg.LastChar = _fbeeb
		_bcgcd, _cdeg = _fed.GetIntVal(_fbeeb)
		if !_cdeg {
			_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004c\u0061\u0073\u0074\u0043h\u0061\u0072\u0020\u0074\u0079\u0070\u0065 \u0028\u0025\u0054\u0029", _fbeeb)
			return nil, _fed.ErrTypeError
		}
		_gdgda := _dg.CharCode(_bcgcd)
		_ffegg._dadc = make(map[_dg.CharCode]float64)
		_fbeeb = _cfccf.Get("\u0057\u0069\u0064\u0074\u0068\u0073")
		if _fbeeb != nil {
			_ffegg.Widths = _fbeeb
			_gfee, _ddaf := _fed.GetArray(_fbeeb)
			if !_ddaf {
				_fef.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020W\u0069\u0064t\u0068\u0073\u0020\u0061\u0074\u0074\u0072\u0069b\u0075\u0074\u0065\u0020\u0021\u003d\u0020\u0061\u0072\u0072\u0061\u0079 \u0028\u0025\u0054\u0029", _fbeeb)
				return nil, _fed.ErrTypeError
			}
			_eacgg, _begcc := _gfee.ToFloat64Array()
			if _begcc != nil {
				_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0077\u0069d\u0074\u0068\u0073\u0020\u0074\u006f\u0020a\u0072\u0072\u0061\u0079")
				return nil, _begcc
			}
			if len(_eacgg) != int(_gdgda-_adgg+1) {
				_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0077\u0069\u0064\u0074\u0068s\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0025\u0064 \u0028\u0025\u0064\u0029", _gdgda-_adgg+1, len(_eacgg))
				return nil, _fed.ErrRangeError
			}
			for _acdbd, _dbebf := range _eacgg {
				_ffegg._dadc[_adgg+_dg.CharCode(_acdbd)] = _dbebf
			}
		}
	}
	_ffegg.Encoding = _fed.TraceToDirectObject(_cfccf.Get("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067"))
	return _ffegg, nil
}

// PdfAnnotationFileAttachment represents FileAttachment annotations.
// (Section 12.5.6.15).
type PdfAnnotationFileAttachment struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	FS   _fed.PdfObject
	Name _fed.PdfObject
}

// NewPdfColorspaceICCBased returns a new ICCBased colorspace object.
func NewPdfColorspaceICCBased(N int) (*PdfColorspaceICCBased, error) {
	_cfba := &PdfColorspaceICCBased{}
	if N != 1 && N != 3 && N != 4 {
		return nil, _d.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020\u0028\u0031/\u0033\u002f\u0034\u0029")
	}
	_cfba.N = N
	return _cfba, nil
}

// GetContainingPdfObject returns the container of the PdfAcroForm (indirect object).
func (_gdcee *PdfAcroForm) GetContainingPdfObject() _fed.PdfObject { return _gdcee._ceed }

// HasColorspaceByName checks if the colorspace with the specified name exists in the page resources.
func (_fbfca *PdfPageResources) HasColorspaceByName(keyName _fed.PdfObjectName) bool {
	_dcda, _gdbgd := _fbfca.GetColorspaces()
	if _gdbgd != nil {
		_fef.Log.Debug("\u0045\u0052R\u004f\u0052\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0072\u0061\u0063\u0065: \u0025\u0076", _gdbgd)
		return false
	}
	if _dcda == nil {
		return false
	}
	_, _cafg := _dcda.Colorspaces[string(keyName)]
	return _cafg
}

// PdfActionResetForm represents a resetForm action.
type PdfActionResetForm struct {
	*PdfAction
	Fields _fed.PdfObject
	Flags  _fed.PdfObject
}

func _edec(_dgfffg _geg.StdFont) pdfFontSimple {
	_fdae := _dgfffg.Descriptor()
	return pdfFontSimple{fontCommon: fontCommon{_afge: "\u0054\u0079\u0070e\u0031", _daac: _dgfffg.Name()}, _abef: _dgfffg.GetMetricsTable(), _daaa: &PdfFontDescriptor{FontName: _fed.MakeName(string(_fdae.Name)), FontFamily: _fed.MakeName(_fdae.Family), FontWeight: _fed.MakeFloat(float64(_fdae.Weight)), Flags: _fed.MakeInteger(int64(_fdae.Flags)), FontBBox: _fed.MakeArrayFromFloats(_fdae.BBox[:]), ItalicAngle: _fed.MakeFloat(_fdae.ItalicAngle), Ascent: _fed.MakeFloat(_fdae.Ascent), Descent: _fed.MakeFloat(_fdae.Descent), CapHeight: _fed.MakeFloat(_fdae.CapHeight), XHeight: _fed.MakeFloat(_fdae.XHeight), StemV: _fed.MakeFloat(_fdae.StemV), StemH: _fed.MakeFloat(_fdae.StemH)}, _cffd: _dgfffg.Encoder()}
}

// SetContentStream sets the pattern cell's content stream.
func (_febfd *PdfTilingPattern) SetContentStream(content []byte, encoder _fed.StreamEncoder) error {
	_ddbde, _aaec := _febfd._fbefb.(*_fed.PdfObjectStream)
	if !_aaec {
		_fef.Log.Debug("\u0054\u0069l\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _febfd._fbefb)
		return _fed.ErrTypeError
	}
	if encoder == nil {
		encoder = _fed.NewRawEncoder()
	}
	_gcdff := _ddbde.PdfObjectDictionary
	_bbabe := encoder.MakeStreamDict()
	_gcdff.Merge(_bbabe)
	_bggd, _effaa := encoder.EncodeBytes(content)
	if _effaa != nil {
		return _effaa
	}
	_gcdff.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _fed.MakeInteger(int64(len(_bggd))))
	_ddbde.Stream = _bggd
	return nil
}

// SetContext sets the sub annotation (context).
func (_bbg *PdfAnnotation) SetContext(ctx PdfModel) { _bbg._adc = ctx }

// BorderEffect represents a border effect (Table 167 p. 395).
type BorderEffect int

func (_dcef *pdfFontSimple) baseFields() *fontCommon { return &_dcef.fontCommon }

// PdfFunctionType2 defines an exponential interpolation of one input value and n
// output values:
//      f(x) = y_0, ..., y_(n-1)
// y_j = C0_j + x^N * (C1_j - C0_j); for 0 <= j < n
// When N=1 ; linear interpolation between C0 and C1.
type PdfFunctionType2 struct {
	Domain []float64
	Range  []float64
	C0     []float64
	C1     []float64
	N      float64
	_fbebb *_fed.PdfIndirectObject
}

func (_eeb *PdfColorspaceDeviceGray) String() string {
	return "\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079"
}

// GetBorderWidth returns the border style's width.
func (_acg *PdfBorderStyle) GetBorderWidth() float64 {
	if _acg.W == nil {
		return 1
	}
	return *_acg.W
}

// PdfWriter handles outputing PDF content.
type PdfWriter struct {
	_aeacb       *_fed.PdfIndirectObject
	_eeafd       *_fed.PdfIndirectObject
	_aadcf       map[_fed.PdfObject]struct{}
	_gcbcf       []_fed.PdfObject
	_bdadf       map[_fed.PdfObject]struct{}
	_cccge       []*_fed.PdfIndirectObject
	_aecef       *PdfOutlineTreeNode
	_cdefg       *_fed.PdfObjectDictionary
	_fdcbb       []_fed.PdfObject
	_egbgf       *_fed.PdfIndirectObject
	_adge        *_b.Writer
	_cgdb        int64
	_deee        error
	_cbebf       *_fed.PdfCrypt
	_fgeef       *_fed.PdfObjectDictionary
	_cfdabb      *_fed.PdfIndirectObject
	_ggbbg       *_fed.PdfObjectArray
	_gbgag       int
	_cccf        int
	_egdec       *bool
	_affff       map[_fed.PdfObject][]*_fed.PdfObjectDictionary
	_cccab       *PdfAcroForm
	_ggfgb       Optimizer
	_agbdc       map[int]crossReference
	_febb        int64
	ObjNumOffset int
	_bgeec       bool
	_ccabce      _fed.XrefTable
	_fcbac       int64
	_defa        int64
	_afgcd       map[_fed.PdfObject]int64
	_fefab       map[_fed.PdfObject]struct{}
	_gdgg        string
}

// ToPdfObject implements interface PdfModel.
func (_ffbd *PdfBorderStyle) ToPdfObject() _fed.PdfObject {
	_gdbg := _fed.MakeDict()
	if _ffbd._dfa != nil {
		if _gfea, _gccg := _ffbd._dfa.(*_fed.PdfIndirectObject); _gccg {
			_gfea.PdfObject = _gdbg
		}
	}
	_gdbg.Set("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u0042\u006f\u0072\u0064\u0065\u0072"))
	if _ffbd.W != nil {
		_gdbg.Set("\u0057", _fed.MakeFloat(*_ffbd.W))
	}
	if _ffbd.S != nil {
		_gdbg.Set("\u0053", _fed.MakeName(_ffbd.S.GetPdfName()))
	}
	if _ffbd.D != nil {
		_gdbg.Set("\u0044", _fed.MakeArrayFromIntegers(*_ffbd.D))
	}
	if _ffbd._dfa != nil {
		return _ffbd._dfa
	}
	return _gdbg
}

// CharcodesToUnicodeWithStats is identical to CharcodesToUnicode except it returns more statistical
// information about hits and misses from the reverse mapping process.
// NOTE: The number of runes returned may be greater than the number of charcodes.
// TODO(peterwilliams97): Deprecate in v4 and use only CharcodesToStrings()
func (_eeae *PdfFont) CharcodesToUnicodeWithStats(charcodes []_dg.CharCode) (_dgfff []rune, _dcbb, _agfg int) {
	_ccbb, _dcbb, _agfg := _eeae.CharcodesToStrings(charcodes)
	return []rune(_eed.Join(_ccbb, "")), _dcbb, _agfg
}

// RepairAcroForm attempts to rebuild the AcroForm fields using the widget
// annotations present in the document pages. Pass nil for the opts parameter
// in order to use the default options.
// NOTE: Currently, the opts parameter is declared in order to enable adding
// future options, but passing nil will always result in the default options
// being used.
func (_afecc *PdfReader) RepairAcroForm(opts *AcroFormRepairOptions) error {
	var _dggbf []*PdfField
	_edbge := map[*_fed.PdfIndirectObject]struct{}{}
	for _, _gfbef := range _afecc.PageList {
		_geage, _fgdaf := _gfbef.GetAnnotations()
		if _fgdaf != nil {
			return _fgdaf
		}
		for _, _dadda := range _geage {
			var _cbafd *PdfField
			switch _ababa := _dadda.GetContext().(type) {
			case *PdfAnnotationWidget:
				if _ababa._eagb != nil {
					_cbafd = _ababa._eagb
					break
				}
				if _acefe, _fbfb := _fed.GetIndirect(_ababa.Parent); _fbfb {
					_cbafd, _fgdaf = _afecc.newPdfFieldFromIndirectObject(_acefe, nil)
					if _fgdaf == nil {
						break
					}
					_fef.Log.Debug("W\u0041\u0052\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0070\u0061\u0072s\u0065\u0020\u0066\u006f\u0072\u006d\u0020\u0066\u0069\u0065ld\u0020\u0025\u002bv\u003a \u0025\u0076", _acefe, _fgdaf)
				}
				if _ababa._ffaab != nil {
					_cbafd, _fgdaf = _afecc.newPdfFieldFromIndirectObject(_ababa._ffaab, nil)
					if _fgdaf == nil {
						break
					}
					_fef.Log.Debug("W\u0041\u0052\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0070\u0061\u0072s\u0065\u0020\u0066\u006f\u0072\u006d\u0020\u0066\u0069\u0065ld\u0020\u0025\u002bv\u003a \u0025\u0076", _ababa._ffaab, _fgdaf)
				}
			}
			if _cbafd == nil {
				continue
			}
			if _, _fdbga := _edbge[_cbafd._cbaae]; _fdbga {
				continue
			}
			_edbge[_cbafd._cbaae] = struct{}{}
			_dggbf = append(_dggbf, _cbafd)
		}
	}
	if len(_dggbf) == 0 {
		return nil
	}
	if _afecc.AcroForm == nil {
		_afecc.AcroForm = NewPdfAcroForm()
	}
	_afecc.AcroForm.Fields = &_dggbf
	return nil
}

// NewPdfAnnotationLink returns a new link annotation.
func NewPdfAnnotationLink() *PdfAnnotationLink {
	_bcf := NewPdfAnnotation()
	_cgde := &PdfAnnotationLink{}
	_cgde.PdfAnnotation = _bcf
	_bcf.SetContext(_cgde)
	return _cgde
}

// GetNumComponents returns the number of color components (3 for RGB).
func (_afdfb *PdfColorDeviceRGB) GetNumComponents() int { return 3 }

// GetAnnotations returns the list of page annotations for `page`. If not loaded attempts to load the
// annotations, otherwise returns the loaded list.
func (_dega *PdfPage) GetAnnotations() ([]*PdfAnnotation, error) {
	if _dega._abcb != nil {
		return _dega._abcb, nil
	}
	if _dega.Annots == nil {
		_dega._abcb = []*PdfAnnotation{}
		return nil, nil
	}
	if _dega._fdcd == nil {
		_dega._abcb = []*PdfAnnotation{}
		return nil, nil
	}
	_eaedb, _aedabe := _dega._fdcd.loadAnnotations(_dega.Annots)
	if _aedabe != nil {
		return nil, _aedabe
	}
	if _eaedb == nil {
		_dega._abcb = []*PdfAnnotation{}
	}
	_dega._abcb = _eaedb
	return _dega._abcb, nil
}

// NewPdfActionResetForm returns a new "reset form" action.
func NewPdfActionResetForm() *PdfActionResetForm {
	_bf := NewPdfAction()
	_dgc := &PdfActionResetForm{}
	_dgc.PdfAction = _bf
	_bf.SetContext(_dgc)
	return _dgc
}
func (_bccc *pdfCIDFontType2) baseFields() *fontCommon { return &_bccc.fontCommon }

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain three elements representing the
// L (range 0-100), A (range -100-100) and B (range -100-100) components of
// the color.
func (_feab *PdfColorspaceLab) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 3 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_dfca := vals[0]
	if _dfca < 0.0 || _dfca > 100.0 {
		_fef.Log.Debug("\u004c\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067e\u0020\u0028\u0067\u006f\u0074\u0020%\u0076\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0030-\u0031\u0030\u0030\u0029", _dfca)
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_deed := vals[1]
	_effe := float64(-100)
	_ecbaa := float64(100)
	if len(_feab.Range) > 1 {
		_effe = _feab.Range[0]
		_ecbaa = _feab.Range[1]
	}
	if _deed < _effe || _deed > _ecbaa {
		_fef.Log.Debug("\u0041\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067e\u0020\u0028\u0067\u006f\u0074\u0020%\u0076\u003b\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0025\u0076\u0020\u0074o\u0020\u0025\u0076\u0029", _deed, _effe, _ecbaa)
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_abgd := vals[2]
	_befe := float64(-100)
	_ceea := float64(100)
	if len(_feab.Range) > 3 {
		_befe = _feab.Range[2]
		_ceea = _feab.Range[3]
	}
	if _abgd < _befe || _abgd > _ceea {
		_fef.Log.Debug("\u0062\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067e\u0020\u0028\u0067\u006f\u0074\u0020%\u0076\u003b\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0025\u0076\u0020\u0074o\u0020\u0025\u0076\u0029", _abgd, _befe, _ceea)
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_bbag := NewPdfColorLab(_dfca, _deed, _abgd)
	return _bbag, nil
}

// PdfFunctionType3 defines stitching of the subdomains of several 1-input functions to produce
// a single new 1-input function.
type PdfFunctionType3 struct {
	Domain    []float64
	Range     []float64
	Functions []PdfFunction
	Bounds    []float64
	Encode    []float64
	_dfeeb    *_fed.PdfIndirectObject
}

// PdfActionSound represents a sound action.
type PdfActionSound struct {
	*PdfAction
	Sound       _fed.PdfObject
	Volume      _fed.PdfObject
	Synchronous _fed.PdfObject
	Repeat      _fed.PdfObject
	Mix         _fed.PdfObject
}

// PdfFilespec represents a file specification which can either refer to an external or embedded file.
type PdfFilespec struct {
	Type   _fed.PdfObject
	FS     _fed.PdfObject
	F      _fed.PdfObject
	UF     _fed.PdfObject
	DOS    _fed.PdfObject
	Mac    _fed.PdfObject
	Unix   _fed.PdfObject
	ID     _fed.PdfObject
	V      _fed.PdfObject
	EF     _fed.PdfObject
	RF     _fed.PdfObject
	Desc   _fed.PdfObject
	CI     _fed.PdfObject
	_dfeff _fed.PdfObject
}

// PdfShadingType1 is a Function-based shading.
type PdfShadingType1 struct {
	*PdfShading
	Domain   *_fed.PdfObjectArray
	Matrix   *_fed.PdfObjectArray
	Function []PdfFunction
}

// ToPdfObject implements interface PdfModel.
func (_bda *PdfActionHide) ToPdfObject() _fed.PdfObject {
	_bda.PdfAction.ToPdfObject()
	_abb := _bda._fa
	_dcge := _abb.PdfObject.(*_fed.PdfObjectDictionary)
	_dcge.SetIfNotNil("\u0053", _fed.MakeName(string(ActionTypeHide)))
	_dcge.SetIfNotNil("\u0054", _bda.T)
	_dcge.SetIfNotNil("\u0048", _bda.H)
	return _abb
}

// PdfColorspaceDeviceCMYK represents a CMYK32 colorspace.
type PdfColorspaceDeviceCMYK struct{}

// NewPdfAnnotationInk returns a new ink annotation.
func NewPdfAnnotationInk() *PdfAnnotationInk {
	_fada := NewPdfAnnotation()
	_bgfd := &PdfAnnotationInk{}
	_bgfd.PdfAnnotation = _fada
	_bgfd.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_fada.SetContext(_bgfd)
	return _bgfd
}
func _abce(_eadgc *_fed.PdfObjectDictionary) (*PdfFieldButton, error) {
	_dgec := &PdfFieldButton{}
	_dgec.Opt, _ = _fed.GetArray(_eadgc.Get("\u004f\u0070\u0074"))
	return _dgec, nil
}

var _edadd = _cdd.MustCompile("\u005b\\\u006e\u005c\u0072\u005d\u002b")

func _abbfgf(_edggc _fed.PdfObject, _cgbg *PdfReader) (*OutlineDest, error) {
	_dgbbbf, _cdecf := _fed.GetArray(_edggc)
	if !_cdecf {
		return nil, _bb.New("\u006f\u0075\u0074\u006c\u0069\u006e\u0065 \u0064\u0065\u0073t\u0069\u006e\u0061\u0074i\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_dcgab := _dgbbbf.Len()
	if _dcgab < 2 {
		return nil, _d.Errorf("\u0069n\u0076\u0061l\u0069\u0064\u0020\u006fu\u0074\u006c\u0069n\u0065\u0020\u0064\u0065\u0073\u0074\u0069\u006e\u0061ti\u006f\u006e\u0020a\u0072\u0072a\u0079\u0020\u006c\u0065\u006e\u0067t\u0068\u003a \u0025\u0064", _dcgab)
	}
	_fgdbe := &OutlineDest{Mode: "\u0046\u0069\u0074"}
	_effcg := _dgbbbf.Get(0)
	if _cdebfb, _bfdgf := _fed.GetIndirect(_effcg); _bfdgf {
		if _, _dabbg, _ffbcfe := _cgbg.PageFromIndirectObject(_cdebfb); _ffbcfe == nil {
			_fgdbe.Page = int64(_dabbg - 1)
		} else {
			_fef.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0063o\u0075\u006c\u0064 \u006e\u006f\u0074\u0020g\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0069\u006e\u0064\u0065\u0078\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u002b\u0076", _cdebfb)
		}
		_fgdbe.PageObj = _cdebfb
	} else if _ddgg, _ebfag := _fed.GetIntVal(_effcg); _ebfag {
		if _ddgg >= 0 && _ddgg < len(_cgbg.PageList) {
			_fgdbe.PageObj = _cgbg.PageList[_ddgg].GetPageAsIndirectObject()
		} else {
			_fef.Log.Debug("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064", _ddgg)
		}
		_fgdbe.Page = int64(_ddgg)
	} else {
		return nil, _d.Errorf("\u0069\u006eva\u006c\u0069\u0064 \u006f\u0075\u0074\u006cine\u0020de\u0073\u0074\u0069\u006e\u0061\u0074\u0069on\u0020\u0070\u0061\u0067\u0065\u003a\u0020%\u0054", _effcg)
	}
	_fedb, _cdecf := _fed.GetNameVal(_dgbbbf.Get(1))
	if !_cdecf {
		_fef.Log.Debug("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006fn\u0020\u006d\u0061\u0067\u006e\u0069\u0066\u0069\u0063\u0061\u0074i\u006f\u006e\u0020\u006d\u006f\u0064\u0065\u003a\u0020\u0025\u0076", _dgbbbf.Get(1))
		return _fgdbe, nil
	}
	switch _fedb {
	case "\u0046\u0069\u0074", "\u0046\u0069\u0074\u0042":
	case "\u0046\u0069\u0074\u0048", "\u0046\u0069\u0074B\u0048":
		if _dcgab > 2 {
			_fgdbe.Y, _ = _fed.GetNumberAsFloat(_fed.TraceToDirectObject(_dgbbbf.Get(2)))
		}
	case "\u0046\u0069\u0074\u0056", "\u0046\u0069\u0074B\u0056":
		if _dcgab > 2 {
			_fgdbe.X, _ = _fed.GetNumberAsFloat(_fed.TraceToDirectObject(_dgbbbf.Get(2)))
		}
	case "\u0058\u0059\u005a":
		if _dcgab > 4 {
			_fgdbe.X, _ = _fed.GetNumberAsFloat(_fed.TraceToDirectObject(_dgbbbf.Get(2)))
			_fgdbe.Y, _ = _fed.GetNumberAsFloat(_fed.TraceToDirectObject(_dgbbbf.Get(3)))
			_fgdbe.Zoom, _ = _fed.GetNumberAsFloat(_fed.TraceToDirectObject(_dgbbbf.Get(4)))
		}
	default:
		_fedb = "\u0046\u0069\u0074"
	}
	_fgdbe.Mode = _fedb
	return _fgdbe, nil
}
func (_bbe *PdfReader) newPdfAnnotationCaretFromDict(_abd *_fed.PdfObjectDictionary) (*PdfAnnotationCaret, error) {
	_bdc := PdfAnnotationCaret{}
	_adec, _acb := _bbe.newPdfAnnotationMarkupFromDict(_abd)
	if _acb != nil {
		return nil, _acb
	}
	_bdc.PdfAnnotationMarkup = _adec
	_bdc.RD = _abd.Get("\u0052\u0044")
	_bdc.Sy = _abd.Get("\u0053\u0079")
	return &_bdc, nil
}
func (_bfaee *pdfFontType3) baseFields() *fontCommon { return &_bfaee.fontCommon }

// NewStandard14FontWithEncoding returns the standard 14 font named `basefont` as a *PdfFont and
// a TextEncoder that encodes all the runes in `alphabet`, or an error if this is not possible.
// An error can occur if `basefont` is not one the standard 14 font names.
func NewStandard14FontWithEncoding(basefont StdFontName, alphabet map[rune]int) (*PdfFont, _dg.SimpleEncoder, error) {
	_bbedb, _eead := _abba(basefont)
	if _eead != nil {
		return nil, nil, _eead
	}
	_dgef, _aedb := _bbedb.Encoder().(_dg.SimpleEncoder)
	if !_aedb {
		return nil, nil, _d.Errorf("\u006f\u006e\u006c\u0079\u0020s\u0069\u006d\u0070\u006c\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u0073\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u002c\u0020\u0067\u006f\u0074\u0020\u0025\u0054", _bbedb.Encoder())
	}
	_bgefe := make(map[rune]_dg.GlyphName)
	for _dfbee := range alphabet {
		if _, _cdff := _dgef.RuneToCharcode(_dfbee); !_cdff {
			_, _bggef := _bbedb._abef.Read(_dfbee)
			if !_bggef {
				_fef.Log.Trace("r\u0075\u006e\u0065\u0020\u0025\u0023x\u003d\u0025\u0071\u0020\u006e\u006f\u0074\u0020\u0069n\u0020\u0074\u0068e\u0020f\u006f\u006e\u0074", _dfbee, _dfbee)
				continue
			}
			_bcac, _bggef := _dg.RuneToGlyph(_dfbee)
			if !_bggef {
				_fef.Log.Debug("\u006eo\u0020\u0067\u006c\u0079\u0070\u0068\u0020\u0066\u006f\u0072\u0020r\u0075\u006e\u0065\u0020\u0025\u0023\u0078\u003d\u0025\u0071", _dfbee, _dfbee)
				continue
			}
			if len(_bgefe) >= 255 {
				return nil, nil, _bb.New("\u0074\u006f\u006f\u0020\u006d\u0061\u006e\u0079\u0020\u0063\u0068\u0061\u0072a\u0063\u0074\u0065\u0072\u0073\u0020f\u006f\u0072\u0020\u0073\u0069\u006d\u0070\u006c\u0065\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067")
			}
			_bgefe[_dfbee] = _bcac
		}
	}
	var (
		_cebd  []_dg.CharCode
		_gafab []_dg.CharCode
	)
	for _dfaaa := _dg.CharCode(1); _dfaaa <= 0xff; _dfaaa++ {
		_ddcd, _edgdb := _dgef.CharcodeToRune(_dfaaa)
		if !_edgdb {
			_cebd = append(_cebd, _dfaaa)
			continue
		}
		if _, _edgdb = alphabet[_ddcd]; !_edgdb {
			_gafab = append(_gafab, _dfaaa)
		}
	}
	_bdeg := append(_cebd, _gafab...)
	if len(_bdeg) < len(_bgefe) {
		return nil, nil, _d.Errorf("n\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0065\u006ec\u006f\u0064\u0065\u0020\u0025\u0064\u0020ru\u006e\u0065\u0073\u002c \u0062\u0075\u0074\u0020\u0068\u0061\u0076\u0065\u0020on\u006c\u0079 \u0025\u0064\u0020\u0073\u006c\u006f\u0074\u0073", len(_bgefe), len(_bdeg))
	}
	_ffdf := make([]rune, 0, len(_bgefe))
	for _bcgge := range _bgefe {
		_ffdf = append(_ffdf, _bcgge)
	}
	_ef.Slice(_ffdf, func(_gbgeb, _cfcb int) bool { return _ffdf[_gbgeb] < _ffdf[_cfcb] })
	_edaeg := make(map[_dg.CharCode]_dg.GlyphName, len(_ffdf))
	for _, _gccdd := range _ffdf {
		_aeea := _bdeg[0]
		_bdeg = _bdeg[1:]
		_edaeg[_aeea] = _bgefe[_gccdd]
	}
	_dgef = _dg.ApplyDifferences(_dgef, _edaeg)
	_bbedb.SetEncoder(_dgef)
	return &PdfFont{_gdaa: &_bbedb}, _dgef, nil
}
func _ffebf(_geegg *PdfField, _fcad _fed.PdfObject) {
	for _, _fbgcc := range _geegg.Annotations {
		_fbgcc.AS = _fcad
		_fbgcc.ToPdfObject()
	}
}
func _eecggd(_cfgbf *_fed.PdfObjectDictionary) (*PdfShadingPattern, error) {
	_ggaad := &PdfShadingPattern{}
	_begde := _cfgbf.Get("\u0053h\u0061\u0064\u0069\u006e\u0067")
	if _begde == nil {
		_fef.Log.Debug("\u0053h\u0061d\u0069\u006e\u0067\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_ddadea, _daebd := _dcca(_begde)
	if _daebd != nil {
		_fef.Log.Debug("\u0045r\u0072\u006f\u0072\u0020l\u006f\u0061\u0064\u0069\u006eg\u0020s\u0068a\u0064\u0069\u006e\u0067\u003a\u0020\u0025v", _daebd)
		return nil, _daebd
	}
	_ggaad.Shading = _ddadea
	if _efded := _cfgbf.Get("\u004d\u0061\u0074\u0072\u0069\u0078"); _efded != nil {
		_geadg, _gdcbg := _efded.(*_fed.PdfObjectArray)
		if !_gdcbg {
			_fef.Log.Debug("\u004d\u0061\u0074\u0072i\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _efded)
			return nil, _fed.ErrTypeError
		}
		_ggaad.Matrix = _geadg
	}
	if _bcca := _cfgbf.Get("\u0045x\u0074\u0047\u0053\u0074\u0061\u0074e"); _bcca != nil {
		_ggaad.ExtGState = _bcca
	}
	return _ggaad, nil
}

// PdfAnnotationSquare represents Square annotations.
// (Section 12.5.6.8).
type PdfAnnotationSquare struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	BS _fed.PdfObject
	IC _fed.PdfObject
	BE _fed.PdfObject
	RD _fed.PdfObject
}

func (_adee *PdfReader) newPdfAnnotationFromIndirectObject(_bceb *_fed.PdfIndirectObject) (*PdfAnnotation, error) {
	_gfe, _caf := _bceb.PdfObject.(*_fed.PdfObjectDictionary)
	if !_caf {
		return nil, _d.Errorf("\u0061\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0069\u006e\u0064\u0069r\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006ft\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020a \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	if model := _adee._dcfcd.GetModelFromPrimitive(_gfe); model != nil {
		_fdbe, _fgd := model.(*PdfAnnotation)
		if !_fgd {
			return nil, _d.Errorf("\u0063\u0061\u0063\u0068\u0065\u0064 \u006d\u006f\u0064\u0065\u006c\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0050D\u0046\u0020\u0061\u006e\u006e\u006f\u0074a\u0074\u0069\u006f\u006e")
		}
		return _fdbe, nil
	}
	_abbb := &PdfAnnotation{}
	_abbb._ffaab = _bceb
	_adee._dcfcd.Register(_gfe, _abbb)
	if _cbf := _gfe.Get("\u0054\u0079\u0070\u0065"); _cbf != nil {
		_dgbf, _ebeg := _cbf.(*_fed.PdfObjectName)
		if !_ebeg {
			_fef.Log.Trace("\u0049\u006e\u0063\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069\u0074\u0079\u0021\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0054\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064 \u0062\u0065\u0020\u004e\u0061m\u0065", _cbf)
		} else {
			if *_dgbf != "\u0041\u006e\u006eo\u0074" {
				_fef.Log.Trace("\u0055\u006e\u0073\u0075\u0073\u0070\u0065\u0063\u0074\u0065d\u0020\u0054\u0079\u0070\u0065\u0020\u0021=\u0020\u0041\u006e\u006e\u006f\u0074\u0020\u0028\u0025\u0073\u0029", *_dgbf)
			}
		}
	}
	if _bgef := _gfe.Get("\u0052\u0065\u0063\u0074"); _bgef != nil {
		_abbb.Rect = _bgef
	}
	if _dae := _gfe.Get("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"); _dae != nil {
		_abbb.Contents = _dae
	}
	if _fdf := _gfe.Get("\u0050"); _fdf != nil {
		_abbb.P = _fdf
	}
	if _gbb := _gfe.Get("\u004e\u004d"); _gbb != nil {
		_abbb.NM = _gbb
	}
	if _bgd := _gfe.Get("\u004d"); _bgd != nil {
		_abbb.M = _bgd
	}
	if _cacd := _gfe.Get("\u0046"); _cacd != nil {
		_abbb.F = _cacd
	}
	if _egbg := _gfe.Get("\u0041\u0050"); _egbg != nil {
		_abbb.AP = _egbg
	}
	if _ddd := _gfe.Get("\u0041\u0053"); _ddd != nil {
		_abbb.AS = _ddd
	}
	if _bcb := _gfe.Get("\u0042\u006f\u0072\u0064\u0065\u0072"); _bcb != nil {
		_abbb.Border = _bcb
	}
	if _eade := _gfe.Get("\u0043"); _eade != nil {
		_abbb.C = _eade
	}
	if _fead := _gfe.Get("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074"); _fead != nil {
		_abbb.StructParent = _fead
	}
	if _afb := _gfe.Get("\u004f\u0043"); _afb != nil {
		_abbb.OC = _afb
	}
	_ebg := _gfe.Get("\u0053u\u0062\u0074\u0079\u0070\u0065")
	if _ebg == nil {
		_fef.Log.Debug("\u0057\u0041\u0052\u004e\u0049\u004e\u0047:\u0020\u0043\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069\u0074\u0079 \u0069s\u0073\u0075\u0065\u0020\u002d\u0020a\u006e\u006e\u006f\u0074\u0061\u0074\u0069o\u006e\u0020\u0053\u0075\u0062\u0074\u0079\u0070\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u002d\u0020\u0061\u0073\u0073u\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0073\u0075\u0062\u0074\u0079p\u0065")
		_abbb._adc = nil
		return _abbb, nil
	}
	_gce, _ada := _ebg.(*_fed.PdfObjectName)
	if !_ada {
		_fef.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0053\u0075\u0062ty\u0070\u0065\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065 !\u003d\u0020n\u0061\u006d\u0065\u0020\u0028\u0025\u0054\u0029", _ebg)
		return nil, _d.Errorf("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0053\u0075\u0062\u0074\u0079\u0070\u0065\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0021\u003d n\u0061\u006d\u0065 \u0028%\u0054\u0029", _ebg)
	}
	switch *_gce {
	case "\u0054\u0065\u0078\u0074":
		_gea, _fegf := _adee.newPdfAnnotationTextFromDict(_gfe)
		if _fegf != nil {
			return nil, _fegf
		}
		_gea.PdfAnnotation = _abbb
		_abbb._adc = _gea
		return _abbb, nil
	case "\u004c\u0069\u006e\u006b":
		_cfbg, _gace := _adee.newPdfAnnotationLinkFromDict(_gfe)
		if _gace != nil {
			return nil, _gace
		}
		_cfbg.PdfAnnotation = _abbb
		_abbb._adc = _cfbg
		return _abbb, nil
	case "\u0046\u0072\u0065\u0065\u0054\u0065\u0078\u0074":
		_agag, _afd := _adee.newPdfAnnotationFreeTextFromDict(_gfe)
		if _afd != nil {
			return nil, _afd
		}
		_agag.PdfAnnotation = _abbb
		_abbb._adc = _agag
		return _abbb, nil
	case "\u004c\u0069\u006e\u0065":
		_abag, _fefcb := _adee.newPdfAnnotationLineFromDict(_gfe)
		if _fefcb != nil {
			return nil, _fefcb
		}
		_abag.PdfAnnotation = _abbb
		_abbb._adc = _abag
		_fef.Log.Trace("\u004c\u0049\u004e\u0045\u0020\u0041N\u004e\u004f\u0054\u0041\u0054\u0049\u004f\u004e\u003a\u0020\u0061\u006e\u006eo\u0074\u0020\u0028\u0025\u0054\u0029\u003a \u0025\u002b\u0076\u000a", _abbb, _abbb)
		_fef.Log.Trace("\u004c\u0049\u004eE\u0020\u0041\u004e\u004eO\u0054\u0041\u0054\u0049\u004f\u004e\u003a \u0063\u0074\u0078\u0020\u0028\u0025\u0054\u0029\u003a\u0020\u0025\u002b\u0076\u000a", _abag, _abag)
		_fef.Log.Trace("\u004c\u0049\u004e\u0045\u0020\u0041\u004e\u004e\u004f\u0054\u0041\u0054\u0049\u004f\u004e\u0020\u004d\u0061\u0072\u006b\u0075\u0070\u003a\u0020c\u0074\u0078\u0020\u0028\u0025T\u0029\u003a \u0025\u002b\u0076\u000a", _abag.PdfAnnotationMarkup, _abag.PdfAnnotationMarkup)
		return _abbb, nil
	case "\u0053\u0071\u0075\u0061\u0072\u0065":
		_cbac, _fdd := _adee.newPdfAnnotationSquareFromDict(_gfe)
		if _fdd != nil {
			return nil, _fdd
		}
		_cbac.PdfAnnotation = _abbb
		_abbb._adc = _cbac
		return _abbb, nil
	case "\u0043\u0069\u0072\u0063\u006c\u0065":
		_fee, _cacc := _adee.newPdfAnnotationCircleFromDict(_gfe)
		if _cacc != nil {
			return nil, _cacc
		}
		_fee.PdfAnnotation = _abbb
		_abbb._adc = _fee
		return _abbb, nil
	case "\u0050o\u006c\u0079\u0067\u006f\u006e":
		_bgaa, _gcb := _adee.newPdfAnnotationPolygonFromDict(_gfe)
		if _gcb != nil {
			return nil, _gcb
		}
		_bgaa.PdfAnnotation = _abbb
		_abbb._adc = _bgaa
		return _abbb, nil
	case "\u0050\u006f\u006c\u0079\u004c\u0069\u006e\u0065":
		_bbac, _cbg := _adee.newPdfAnnotationPolyLineFromDict(_gfe)
		if _cbg != nil {
			return nil, _cbg
		}
		_bbac.PdfAnnotation = _abbb
		_abbb._adc = _bbac
		return _abbb, nil
	case "\u0048i\u0067\u0068\u006c\u0069\u0067\u0068t":
		_bfa, _abbg := _adee.newPdfAnnotationHighlightFromDict(_gfe)
		if _abbg != nil {
			return nil, _abbg
		}
		_bfa.PdfAnnotation = _abbb
		_abbb._adc = _bfa
		return _abbb, nil
	case "\u0055n\u0064\u0065\u0072\u006c\u0069\u006ee":
		_dcgea, _bgg := _adee.newPdfAnnotationUnderlineFromDict(_gfe)
		if _bgg != nil {
			return nil, _bgg
		}
		_dcgea.PdfAnnotation = _abbb
		_abbb._adc = _dcgea
		return _abbb, nil
	case "\u0053\u0071\u0075\u0069\u0067\u0067\u006c\u0079":
		_gfc, _fgc := _adee.newPdfAnnotationSquigglyFromDict(_gfe)
		if _fgc != nil {
			return nil, _fgc
		}
		_gfc.PdfAnnotation = _abbb
		_abbb._adc = _gfc
		return _abbb, nil
	case "\u0053t\u0072\u0069\u006b\u0065\u004f\u0075t":
		_cbcbe, _gcbe := _adee.newPdfAnnotationStrikeOut(_gfe)
		if _gcbe != nil {
			return nil, _gcbe
		}
		_cbcbe.PdfAnnotation = _abbb
		_abbb._adc = _cbcbe
		return _abbb, nil
	case "\u0043\u0061\u0072e\u0074":
		_bbbb, _fbcg := _adee.newPdfAnnotationCaretFromDict(_gfe)
		if _fbcg != nil {
			return nil, _fbcg
		}
		_bbbb.PdfAnnotation = _abbb
		_abbb._adc = _bbbb
		return _abbb, nil
	case "\u0053\u0074\u0061m\u0070":
		_fefe, _ega := _adee.newPdfAnnotationStampFromDict(_gfe)
		if _ega != nil {
			return nil, _ega
		}
		_fefe.PdfAnnotation = _abbb
		_abbb._adc = _fefe
		return _abbb, nil
	case "\u0049\u006e\u006b":
		_ddc, _gcef := _adee.newPdfAnnotationInkFromDict(_gfe)
		if _gcef != nil {
			return nil, _gcef
		}
		_ddc.PdfAnnotation = _abbb
		_abbb._adc = _ddc
		return _abbb, nil
	case "\u0050\u006f\u0070u\u0070":
		_bfb, _gcc := _adee.newPdfAnnotationPopupFromDict(_gfe)
		if _gcc != nil {
			return nil, _gcc
		}
		_bfb.PdfAnnotation = _abbb
		_abbb._adc = _bfb
		return _abbb, nil
	case "\u0046\u0069\u006c\u0065\u0041\u0074\u0074\u0061\u0063h\u006d\u0065\u006e\u0074":
		_efe, _aede := _adee.newPdfAnnotationFileAttachmentFromDict(_gfe)
		if _aede != nil {
			return nil, _aede
		}
		_efe.PdfAnnotation = _abbb
		_abbb._adc = _efe
		return _abbb, nil
	case "\u0053\u006f\u0075n\u0064":
		_edef, _bfc := _adee.newPdfAnnotationSoundFromDict(_gfe)
		if _bfc != nil {
			return nil, _bfc
		}
		_edef.PdfAnnotation = _abbb
		_abbb._adc = _edef
		return _abbb, nil
	case "\u0052i\u0063\u0068\u004d\u0065\u0064\u0069a":
		_cdde, _be := _adee.newPdfAnnotationRichMediaFromDict(_gfe)
		if _be != nil {
			return nil, _be
		}
		_cdde.PdfAnnotation = _abbb
		_abbb._adc = _cdde
		return _abbb, nil
	case "\u004d\u006f\u0076i\u0065":
		_cbff, _fbd := _adee.newPdfAnnotationMovieFromDict(_gfe)
		if _fbd != nil {
			return nil, _fbd
		}
		_cbff.PdfAnnotation = _abbb
		_abbb._adc = _cbff
		return _abbb, nil
	case "\u0053\u0063\u0072\u0065\u0065\u006e":
		_fagf, _cbe := _adee.newPdfAnnotationScreenFromDict(_gfe)
		if _cbe != nil {
			return nil, _cbe
		}
		_fagf.PdfAnnotation = _abbb
		_abbb._adc = _fagf
		return _abbb, nil
	case "\u0057\u0069\u0064\u0067\u0065\u0074":
		_bbgef, _gaac := _adee.newPdfAnnotationWidgetFromDict(_gfe)
		if _gaac != nil {
			return nil, _gaac
		}
		_bbgef.PdfAnnotation = _abbb
		_abbb._adc = _bbgef
		return _abbb, nil
	case "P\u0072\u0069\u006e\u0074\u0065\u0072\u004d\u0061\u0072\u006b":
		_dffc, _feb := _adee.newPdfAnnotationPrinterMarkFromDict(_gfe)
		if _feb != nil {
			return nil, _feb
		}
		_dffc.PdfAnnotation = _abbb
		_abbb._adc = _dffc
		return _abbb, nil
	case "\u0054r\u0061\u0070\u004e\u0065\u0074":
		_bgdf, _fgca := _adee.newPdfAnnotationTrapNetFromDict(_gfe)
		if _fgca != nil {
			return nil, _fgca
		}
		_bgdf.PdfAnnotation = _abbb
		_abbb._adc = _bgdf
		return _abbb, nil
	case "\u0057a\u0074\u0065\u0072\u006d\u0061\u0072k":
		_cgf, _dbee := _adee.newPdfAnnotationWatermarkFromDict(_gfe)
		if _dbee != nil {
			return nil, _dbee
		}
		_cgf.PdfAnnotation = _abbb
		_abbb._adc = _cgf
		return _abbb, nil
	case "\u0033\u0044":
		_efgg, _cfc := _adee.newPdfAnnotation3DFromDict(_gfe)
		if _cfc != nil {
			return nil, _cfc
		}
		_efgg.PdfAnnotation = _abbb
		_abbb._adc = _efgg
		return _abbb, nil
	case "\u0050\u0072\u006f\u006a\u0065\u0063\u0074\u0069\u006f\u006e":
		_aad, _ggc := _adee.newPdfAnnotationProjectionFromDict(_gfe)
		if _ggc != nil {
			return nil, _ggc
		}
		_aad.PdfAnnotation = _abbb
		_abbb._adc = _aad
		return _abbb, nil
	case "\u0052\u0065\u0064\u0061\u0063\u0074":
		_aee, _gcae := _adee.newPdfAnnotationRedactFromDict(_gfe)
		if _gcae != nil {
			return nil, _gcae
		}
		_aee.PdfAnnotation = _abbb
		_abbb._adc = _aee
		return _abbb, nil
	}
	_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020a\u006e\u006e\u006f\u0074\u0061t\u0069\u006fn\u003a\u0020\u0025\u0073", *_gce)
	return nil, nil
}

// PdfActionRendition represents a Rendition action.
type PdfActionRendition struct {
	*PdfAction
	R  _fed.PdfObject
	AN _fed.PdfObject
	OP _fed.PdfObject
	JS _fed.PdfObject
}

// SetPdfSubject sets the Subject attribute of the output PDF.
func SetPdfSubject(subject string) { _abadca.Lock(); defer _abadca.Unlock(); _eeffe = subject }

// ToPdfObject implements interface PdfModel.
func (_bbbe *PdfActionThread) ToPdfObject() _fed.PdfObject {
	_bbbe.PdfAction.ToPdfObject()
	_bdg := _bbbe._fa
	_ade := _bdg.PdfObject.(*_fed.PdfObjectDictionary)
	_ade.SetIfNotNil("\u0053", _fed.MakeName(string(ActionTypeThread)))
	if _bbbe.F != nil {
		_ade.Set("\u0046", _bbbe.F.ToPdfObject())
	}
	_ade.SetIfNotNil("\u0044", _bbbe.D)
	_ade.SetIfNotNil("\u0042", _bbbe.B)
	return _bdg
}

// NewBorderStyle returns an initialized PdfBorderStyle.
func NewBorderStyle() *PdfBorderStyle { _ccag := &PdfBorderStyle{}; return _ccag }
func (_dda *PdfReader) newPdfActionLaunchFromDict(_afc *_fed.PdfObjectDictionary) (*PdfActionLaunch, error) {
	_fbc, _bad := _eec(_afc.Get("\u0046"))
	if _bad != nil {
		return nil, _bad
	}
	return &PdfActionLaunch{Win: _afc.Get("\u0057\u0069\u006e"), Mac: _afc.Get("\u004d\u0061\u0063"), Unix: _afc.Get("\u0055\u006e\u0069\u0078"), NewWindow: _afc.Get("\u004ee\u0077\u0057\u0069\u006e\u0064\u006fw"), F: _fbc}, nil
}
func (_daecg *pdfFontSimple) addEncoding() error {
	var (
		_daeeb  string
		_gcbebg map[_dg.CharCode]_dg.GlyphName
		_acabc  _dg.SimpleEncoder
	)
	if _daecg.Encoder() != nil {
		_effdd, _cadg := _daecg.Encoder().(_dg.SimpleEncoder)
		if _cadg && _effdd != nil {
			_daeeb = _effdd.BaseName()
		}
	}
	if _daecg.Encoding != nil {
		_edcfc, _cabb, _eeaf := _daecg.getFontEncoding()
		if _eeaf != nil {
			_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0042\u0061\u0073\u0065F\u006f\u006e\u0074\u003d\u0025\u0071\u0020\u0053u\u0062t\u0079\u0070\u0065\u003d\u0025\u0071\u0020\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003d\u0025\u0073 \u0028\u0025\u0054\u0029\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _daecg._daac, _daecg._afge, _daecg.Encoding, _daecg.Encoding, _eeaf)
			return _eeaf
		}
		if _edcfc != "" {
			_daeeb = _edcfc
		}
		_gcbebg = _cabb
		_acabc, _eeaf = _dg.NewSimpleTextEncoder(_daeeb, _gcbebg)
		if _eeaf != nil {
			return _eeaf
		}
	}
	if _acabc == nil {
		_dbdd := _daecg._bgdgb
		if _dbdd != nil {
			switch _daecg._afge {
			case "\u0054\u0079\u0070e\u0031":
				if _dbdd.fontFile != nil && _dbdd.fontFile._dddff != nil {
					_fef.Log.Debug("\u0055\u0073\u0069\u006e\u0067\u0020\u0066\u006f\u006et\u0046\u0069\u006c\u0065")
					_acabc = _dbdd.fontFile._dddff
				}
			case "\u0054\u0072\u0075\u0065\u0054\u0079\u0070\u0065":
				if _dbdd._afef != nil {
					_fef.Log.Debug("\u0055s\u0069n\u0067\u0020\u0046\u006f\u006e\u0074\u0046\u0069\u006c\u0065\u0032")
					_agdee, _bbfbb := _dbdd._afef.MakeEncoder()
					if _bbfbb == nil {
						_acabc = _agdee
					}
				}
			}
		}
	}
	if _acabc != nil {
		if _gcbebg != nil {
			_fef.Log.Trace("\u0064\u0069\u0066fe\u0072\u0065\u006e\u0063\u0065\u0073\u003d\u0025\u002b\u0076\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _gcbebg, _daecg.baseFields())
			_acabc = _dg.ApplyDifferences(_acabc, _gcbebg)
		}
		_daecg.SetEncoder(_acabc)
	}
	return nil
}

// ToPdfObject returns the PDF representation of the tiling pattern.
func (_ffcdd *PdfTilingPattern) ToPdfObject() _fed.PdfObject {
	_ffcdd.PdfPattern.ToPdfObject()
	_gafd := _ffcdd.getDict()
	if _ffcdd.PaintType != nil {
		_gafd.Set("\u0050a\u0069\u006e\u0074\u0054\u0079\u0070e", _ffcdd.PaintType)
	}
	if _ffcdd.TilingType != nil {
		_gafd.Set("\u0054\u0069\u006c\u0069\u006e\u0067\u0054\u0079\u0070\u0065", _ffcdd.TilingType)
	}
	if _ffcdd.BBox != nil {
		_gafd.Set("\u0042\u0042\u006f\u0078", _ffcdd.BBox.ToPdfObject())
	}
	if _ffcdd.XStep != nil {
		_gafd.Set("\u0058\u0053\u0074e\u0070", _ffcdd.XStep)
	}
	if _ffcdd.YStep != nil {
		_gafd.Set("\u0059\u0053\u0074e\u0070", _ffcdd.YStep)
	}
	if _ffcdd.Resources != nil {
		_gafd.Set("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s", _ffcdd.Resources.ToPdfObject())
	}
	if _ffcdd.Matrix != nil {
		_gafd.Set("\u004d\u0061\u0074\u0072\u0069\u0078", _ffcdd.Matrix)
	}
	return _ffcdd._fbefb
}

// ToPdfObject implements interface PdfModel.
func (_aae *PdfAnnotationLink) ToPdfObject() _fed.PdfObject {
	_aae.PdfAnnotation.ToPdfObject()
	_bffc := _aae._ffaab
	_fae := _bffc.PdfObject.(*_fed.PdfObjectDictionary)
	_fae.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u004c\u0069\u006e\u006b"))
	if _aae._cge != nil && _aae._cge._fcc != nil {
		_fae.Set("\u0041", _aae._cge._fcc.ToPdfObject())
	} else if _aae.A != nil {
		_fae.Set("\u0041", _aae.A)
	}
	_fae.SetIfNotNil("\u0044\u0065\u0073\u0074", _aae.Dest)
	_fae.SetIfNotNil("\u0048", _aae.H)
	_fae.SetIfNotNil("\u0050\u0041", _aae.PA)
	_fae.SetIfNotNil("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073", _aae.QuadPoints)
	_fae.SetIfNotNil("\u0042\u0053", _aae.BS)
	return _bffc
}

// ToPdfObject returns the PDF representation of the colorspace.
func (_eadb *PdfColorspaceDeviceGray) ToPdfObject() _fed.PdfObject {
	return _fed.MakeName("\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079")
}

// UpdatePage updates the `page` in the new revision if it has changed.
func (_fgfa *PdfAppender) UpdatePage(page *PdfPage) { _fgfa.updateObjectsDeep(page.ToPdfObject(), nil) }

// NewPdfColorDeviceGray returns a new grayscale color based on an input grayscale float value in range [0-1].
func NewPdfColorDeviceGray(grayVal float64) *PdfColorDeviceGray {
	_egdd := PdfColorDeviceGray(grayVal)
	return &_egdd
}

// NewPdfActionThread returns a new "thread" action.
func NewPdfActionThread() *PdfActionThread {
	_bc := NewPdfAction()
	_cb := &PdfActionThread{}
	_cb.PdfAction = _bc
	_bc.SetContext(_cb)
	return _cb
}

// Write writes the Appender output to io.Writer.
// It can only be called once and further invocations will result in an error.
func (_febf *PdfAppender) Write(w _ge.Writer) error {
	if _febf._dfcc {
		return _bb.New("\u0061\u0070\u0070\u0065\u006e\u0064\u0065\u0072\u0020\u0077\u0072\u0069\u0074e\u0020\u0063\u0061\u006e\u0020\u006fn\u006c\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0076\u006f\u006b\u0065\u0064 \u006f\u006e\u0063\u0065")
	}
	_eedd := NewPdfWriter()
	_fgce, _gdd := _fed.GetDict(_eedd._eeafd)
	if !_gdd {
		return _bb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0061g\u0065\u0073\u0020\u006f\u0062\u006a\u0020(\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0029")
	}
	_cbdg, _gdd := _fgce.Get("\u004b\u0069\u0064\u0073").(*_fed.PdfObjectArray)
	if !_gdd {
		return _bb.New("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0050\u0061g\u0065\u0073\u0020\u004b\u0069\u0064\u0073\u0020o\u0062\u006a\u0020\u0028\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072\u0061\u0079\u0029")
	}
	_gffb, _gdd := _fgce.Get("\u0043\u006f\u0075n\u0074").(*_fed.PdfObjectInteger)
	if !_gdd {
		return _bb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064 \u0050\u0061\u0067e\u0073\u0020\u0043\u006fu\u006e\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0029")
	}
	_agb := _febf._ccc._cdfggf
	_fbed := _agb.GetTrailer()
	if _fbed == nil {
		return _bb.New("\u006di\u0073s\u0069\u006e\u0067\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072")
	}
	_ecec, _gdd := _fed.GetIndirect(_fbed.Get("\u0052\u006f\u006f\u0074"))
	if !_gdd {
		return _bb.New("c\u0061\u0074\u0061\u006c\u006f\u0067 \u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064")
	}
	_acgc, _gdd := _fed.GetDict(_ecec)
	if !_gdd {
		_fef.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u003a\u0020\u0028\u0072\u006f\u006f\u0074\u0020\u0025\u0071\u0029\u0020\u0028\u0074\u0072\u0061\u0069\u006c\u0065\u0072\u0020\u0025\u0073\u0029", _ecec, *_fbed)
		return _bb.New("\u006di\u0073s\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067")
	}
	for _, _acdc := range _acgc.Keys() {
		if _eedd._cdefg.Get(_acdc) == nil {
			_bbeef := _acgc.Get(_acdc)
			_eedd._cdefg.Set(_acdc, _bbeef)
		}
	}
	if _febf._eae != nil {
		_eedd._cdefg.Set("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d", _febf._eae.ToPdfObject())
		_febf.updateObjectsDeep(_febf._eae.ToPdfObject(), nil)
	}
	if _febf._bcbe != nil {
		_febf.updateObjectsDeep(_febf._bcbe.ToPdfObject(), nil)
		_eedd._cdefg.Set("\u0044\u0053\u0053", _febf._bcbe.GetContainingPdfObject())
	}
	if _eedd._gbgag < 2 {
		_eedd.AddExtension("\u0045\u0053\u0049\u0043", "\u0031\u002e\u0037", 5)
		_eedd.AddExtension("\u0041\u0044\u0042\u0045", "\u0031\u002e\u0037", 8)
	}
	_febf.addNewObject(_eedd._egbgf)
	_febf.addNewObject(_eedd._aeacb)
	_bfeb := false
	if len(_febf._ccc.PageList) != len(_febf._dce) {
		_bfeb = true
	} else {
		for _bceg := range _febf._ccc.PageList {
			switch {
			case _febf._dce[_bceg] == _febf._ccc.PageList[_bceg]:
			case _febf._dce[_bceg] == _febf.Reader.PageList[_bceg]:
			default:
				_bfeb = true
			}
			if _bfeb {
				break
			}
		}
	}
	if _bfeb {
		_febf.updateObjectsDeep(_eedd._eeafd, nil)
	} else {
		_febf._egga[_eedd._eeafd] = struct{}{}
	}
	_eedd._eeafd.ObjectNumber = _febf.Reader._fadda.ObjectNumber
	_febf._aebf[_eedd._eeafd] = _febf.Reader._fadda.ObjectNumber
	_gdbb := []_fed.PdfObjectName{"\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s", "\u004d\u0065\u0064\u0069\u0061\u0042\u006f\u0078", "\u0043r\u006f\u0070\u0042\u006f\u0078", "\u0052\u006f\u0074\u0061\u0074\u0065"}
	for _, _fff := range _febf._dce {
		_gbd := _fff.ToPdfObject()
		*_gffb = *_gffb + 1
		if _fddf, _cgfg := _gbd.(*_fed.PdfIndirectObject); _cgfg && _fddf.GetParser() == _febf._ccc._cdfggf {
			_cbdg.Append(&_fddf.PdfObjectReference)
			continue
		}
		if _gdfce, _abaa := _fed.GetDict(_gbd); _abaa {
			_fdggg, _dea := _gdfce.Get("\u0050\u0061\u0072\u0065\u006e\u0074").(*_fed.PdfIndirectObject)
			for _dea {
				_fef.Log.Trace("\u0050a\u0067e\u0020\u0050\u0061\u0072\u0065\u006e\u0074\u003a\u0020\u0025\u0054", _fdggg)
				_abbc, _egac := _fdggg.PdfObject.(*_fed.PdfObjectDictionary)
				if !_egac {
					return _bb.New("i\u006e\u0076\u0061\u006cid\u0020P\u0061\u0072\u0065\u006e\u0074 \u006f\u0062\u006a\u0065\u0063\u0074")
				}
				for _, _aced := range _gdbb {
					_fef.Log.Trace("\u0046\u0069\u0065\u006c\u0064\u0020\u0025\u0073", _aced)
					if _gdfce.Get(_aced) != nil {
						_fef.Log.Trace("\u002d \u0070a\u0067\u0065\u0020\u0068\u0061s\u0020\u0061l\u0072\u0065\u0061\u0064\u0079")
						continue
					}
					if _aaad := _abbc.Get(_aced); _aaad != nil {
						_fef.Log.Trace("\u0049\u006e\u0068\u0065ri\u0074\u0069\u006e\u0067\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0025\u0073", _aced)
						_gdfce.Set(_aced, _aaad)
					}
				}
				_fdggg, _dea = _abbc.Get("\u0050\u0061\u0072\u0065\u006e\u0074").(*_fed.PdfIndirectObject)
				_fef.Log.Trace("\u004ee\u0078t\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u003a\u0020\u0025\u0054", _abbc.Get("\u0050\u0061\u0072\u0065\u006e\u0074"))
			}
			_gdfce.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _eedd._eeafd)
		}
		_febf.updateObjectsDeep(_gbd, nil)
		_cbdg.Append(_gbd)
	}
	if _, _eged := _febf._ffcf.Seek(0, _ge.SeekStart); _eged != nil {
		return _eged
	}
	_cffcb := make(map[SignatureHandler]_ge.Writer)
	_bfae := _fed.MakeArray()
	for _, _bbc := range _febf._gdba {
		if _cedg, _bgadb := _fed.GetIndirect(_bbc); _bgadb {
			if _bee, _dgca := _cedg.PdfObject.(*pdfSignDictionary); _dgca {
				_dgffa := *_bee._gdgfa
				var _edgd error
				_cffcb[_dgffa], _edgd = _dgffa.NewDigest(_bee._agafa)
				if _edgd != nil {
					return _edgd
				}
				_bfae.Append(_fed.MakeInteger(0xfffff), _fed.MakeInteger(0xfffff))
			}
		}
	}
	if _bfae.Len() > 0 {
		_bfae.Append(_fed.MakeInteger(0xfffff), _fed.MakeInteger(0xfffff))
	}
	for _, _efcd := range _febf._gdba {
		if _bgfe, _aaefg := _fed.GetIndirect(_efcd); _aaefg {
			if _ceef, _ffaae := _bgfe.PdfObject.(*pdfSignDictionary); _ffaae {
				_ceef.Set("\u0042y\u0074\u0065\u0052\u0061\u006e\u0067e", _bfae)
			}
		}
	}
	_gfcb := len(_cffcb) > 0
	var _gdgb _ge.Reader = _febf._ffcf
	if _gfcb {
		_cbffd := make([]_ge.Writer, 0, len(_cffcb))
		for _, _gacc := range _cffcb {
			_cbffd = append(_cbffd, _gacc)
		}
		_gdgb = _ge.TeeReader(_febf._ffcf, _ge.MultiWriter(_cbffd...))
	}
	_feeag, _dacd := _ge.Copy(w, _gdgb)
	if _dacd != nil {
		return _dacd
	}
	if len(_febf._gdba) == 0 {
		return nil
	}
	_eedd._febb = _feeag
	_eedd.ObjNumOffset = _febf._efed
	_eedd._bgeec = true
	_eedd._ccabce = _febf._cdga
	_eedd._fcbac = _febf._eaa
	_eedd._defa = _febf._edga
	_eedd._cccf = _febf._ccc.PdfVersion().Minor
	_eedd._afgcd = _febf._aebf
	_accb := _febf._cgbc.GetXrefType()
	if _accb != nil {
		_efee := *_accb == _fed.XrefTypeObjectStream
		_eedd._egdec = &_efee
	}
	_eedd._bdadf = map[_fed.PdfObject]struct{}{}
	_eedd._gcbcf = []_fed.PdfObject{}
	for _, _cbae := range _febf._gdba {
		if _, _fdeb := _febf._egga[_cbae]; _fdeb {
			continue
		}
		_eedd.addObject(_cbae)
	}
	_ggga := w
	if _gfcb {
		_ggga = _eb.NewBuffer(nil)
	}
	if _fdda := _eedd.Write(_ggga); _fdda != nil {
		return _fdda
	}
	if _gfcb {
		_gbeg := _ggga.(*_eb.Buffer).Bytes()
		_fdcge := _fed.MakeArray()
		var _cgfa []*pdfSignDictionary
		var _ceeb int64
		for _, _ceeg := range _eedd._gcbcf {
			if _daef, _aadf := _fed.GetIndirect(_ceeg); _aadf {
				if _agbb, _ffadb := _daef.PdfObject.(*pdfSignDictionary); _ffadb {
					_cgfa = append(_cgfa, _agbb)
					_gfbbd := _agbb._baaf + int64(_agbb._becf)
					_fdcge.Append(_fed.MakeInteger(_ceeb), _fed.MakeInteger(_gfbbd-_ceeb))
					_ceeb = _agbb._baaf + int64(_agbb._dgcbc)
				}
			}
		}
		_fdcge.Append(_fed.MakeInteger(_ceeb), _fed.MakeInteger(_feeag+int64(len(_gbeg))-_ceeb))
		_eafg := []byte(_fdcge.WriteString())
		for _, _cgbd := range _cgfa {
			_ggca := int(_cgbd._baaf - _feeag)
			for _fcdg := _cgbd._acade; _fcdg < _cgbd._aagf; _fcdg++ {
				_gbeg[_ggca+_fcdg] = ' '
			}
			_deg := _gbeg[_ggca+_cgbd._acade : _ggca+_cgbd._aagf]
			copy(_deg, _eafg)
		}
		var _cgdg int
		for _, _ffadc := range _cgfa {
			_gfcf := int(_ffadc._baaf - _feeag)
			_eacd := _gbeg[_cgdg : _gfcf+_ffadc._becf]
			_fagcc := *_ffadc._gdgfa
			_cffcb[_fagcc].Write(_eacd)
			_cgdg = _gfcf + _ffadc._dgcbc
		}
		for _, _ecba := range _cgfa {
			_bacd := _gbeg[_cgdg:]
			_ebba := *_ecba._gdgfa
			_cffcb[_ebba].Write(_bacd)
		}
		for _, _aabe := range _cgfa {
			_fbedd := int(_aabe._baaf - _feeag)
			_cfcc := *_aabe._gdgfa
			_fbdcf := _cffcb[_cfcc]
			if _adfe := _cfcc.Sign(_aabe._agafa, _fbdcf); _adfe != nil {
				return _adfe
			}
			_aabe._agafa.ByteRange = _fdcge
			_egec := []byte(_aabe._agafa.Contents.WriteString())
			for _fce := _aabe._acade; _fce < _aabe._aagf; _fce++ {
				_gbeg[_fbedd+_fce] = ' '
			}
			for _dcc := _aabe._becf; _dcc < _aabe._dgcbc; _dcc++ {
				_gbeg[_fbedd+_dcc] = ' '
			}
			_abcf := _gbeg[_fbedd+_aabe._acade : _fbedd+_aabe._aagf]
			copy(_abcf, _eafg)
			_abcf = _gbeg[_fbedd+_aabe._becf : _fbedd+_aabe._dgcbc]
			copy(_abcf, _egec)
		}
		_bea := _eb.NewBuffer(_gbeg)
		_, _dacd = _ge.Copy(w, _bea)
		if _dacd != nil {
			return _dacd
		}
	}
	_febf._dfcc = true
	return nil
}

// PageProcessCallback callback function used in page loading
// that could be used to modify the page content.
//
// If an error is returned, the `ToWriter` process would fail.
//
// This callback, if defined, will take precedence over `PageCallback` callback.
type PageProcessCallback func(_bdgae int, _ebbc *PdfPage) error

// ToPdfObject implements interface PdfModel.
func (_afcg *PdfAnnotationUnderline) ToPdfObject() _fed.PdfObject {
	_afcg.PdfAnnotation.ToPdfObject()
	_ddbd := _afcg._ffaab
	_aff := _ddbd.PdfObject.(*_fed.PdfObjectDictionary)
	_afcg.PdfAnnotationMarkup.appendToPdfDictionary(_aff)
	_aff.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u0055n\u0064\u0065\u0072\u006c\u0069\u006ee"))
	_aff.SetIfNotNil("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073", _afcg.QuadPoints)
	return _ddbd
}
func _gbaea(_bbdd _fed.PdfObject) (*PdfColorspaceSpecialSeparation, error) {
	_cdfe := NewPdfColorspaceSpecialSeparation()
	if _fdbd, _cbbf := _bbdd.(*_fed.PdfIndirectObject); _cbbf {
		_cdfe._fdffd = _fdbd
	}
	_bbdd = _fed.TraceToDirectObject(_bbdd)
	_gbgd, _cbdga := _bbdd.(*_fed.PdfObjectArray)
	if !_cbdga {
		return nil, _d.Errorf("\u0073\u0065p\u0061\u0072\u0061\u0074\u0069\u006f\u006e\u0020\u0043\u0053\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0062je\u0063\u0074")
	}
	if _gbgd.Len() != 4 {
		return nil, _d.Errorf("\u0073\u0065p\u0061\u0072\u0061\u0074i\u006f\u006e \u0043\u0053\u003a\u0020\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u006ce\u006e\u0067\u0074\u0068")
	}
	_bbdd = _gbgd.Get(0)
	_ddge, _cbdga := _bbdd.(*_fed.PdfObjectName)
	if !_cbdga {
		return nil, _d.Errorf("\u0073\u0065\u0070ar\u0061\u0074\u0069\u006f\u006e\u0020\u0043\u0053\u003a \u0069n\u0076a\u006ci\u0064\u0020\u0066\u0061\u006d\u0069\u006c\u0079\u0020\u006e\u0061\u006d\u0065")
	}
	if *_ddge != "\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006f\u006e" {
		return nil, _d.Errorf("\u0073\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006f\u006e\u0020\u0043\u0053\u003a\u0020w\u0072o\u006e\u0067\u0020\u0066\u0061\u006d\u0069\u006c\u0079\u0020\u006e\u0061\u006d\u0065")
	}
	_bbdd = _gbgd.Get(1)
	_ddge, _cbdga = _bbdd.(*_fed.PdfObjectName)
	if !_cbdga {
		return nil, _d.Errorf("\u0073\u0065pa\u0072\u0061\u0074i\u006f\u006e\u0020\u0043S: \u0049nv\u0061\u006c\u0069\u0064\u0020\u0063\u006flo\u0072\u0061\u006e\u0074\u0020\u006e\u0061m\u0065")
	}
	_cdfe.ColorantName = _ddge
	_bbdd = _gbgd.Get(2)
	_bdaec, _adfeb := NewPdfColorspaceFromPdfObject(_bbdd)
	if _adfeb != nil {
		return nil, _adfeb
	}
	_cdfe.AlternateSpace = _bdaec
	_efdf, _adfeb := _bggad(_gbgd.Get(3))
	if _adfeb != nil {
		return nil, _adfeb
	}
	_cdfe.TintTransform = _efdf
	return _cdfe, nil
}

// Evaluate runs the function on the passed in slice and returns the results.
func (_dadg *PdfFunctionType3) Evaluate(x []float64) ([]float64, error) {
	if len(x) != 1 {
		_fef.Log.Error("\u004f\u006e\u006c\u0079 o\u006e\u0065\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0061\u006c\u006c\u006f\u0077e\u0064")
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	return nil, _bb.New("\u006e\u006f\u0074\u0020im\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074")
}

// ColorToRGB converts a CalGray color to an RGB color.
func (_eeaa *PdfColorspaceCalGray) ColorToRGB(color PdfColor) (PdfColor, error) {
	_aafe, _ecfe := color.(*PdfColorCalGray)
	if !_ecfe {
		_fef.Log.Debug("\u0049n\u0070\u0075\u0074\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006eo\u0074\u0020\u0063\u0061\u006c\u0020\u0067\u0072\u0061\u0079")
		return nil, _bb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	ANorm := _aafe.Val()
	X := _eeaa.WhitePoint[0] * _bg.Pow(ANorm, _eeaa.Gamma)
	Y := _eeaa.WhitePoint[1] * _bg.Pow(ANorm, _eeaa.Gamma)
	Z := _eeaa.WhitePoint[2] * _bg.Pow(ANorm, _eeaa.Gamma)
	_fbgg := 3.240479*X + -1.537150*Y + -0.498535*Z
	_gbea := -0.969256*X + 1.875992*Y + 0.041556*Z
	_fffa := 0.055648*X + -0.204043*Y + 1.057311*Z
	_fbgg = _bg.Min(_bg.Max(_fbgg, 0), 1.0)
	_gbea = _bg.Min(_bg.Max(_gbea, 0), 1.0)
	_fffa = _bg.Min(_bg.Max(_fffa, 0), 1.0)
	return NewPdfColorDeviceRGB(_fbgg, _gbea, _fffa), nil
}

// GetColorspaces loads PdfPageResourcesColorspaces from `r.ColorSpace` and returns an error if there
// is a problem loading. Once loaded, the same object is returned on multiple calls.
func (_gggd *PdfPageResources) GetColorspaces() (*PdfPageResourcesColorspaces, error) {
	if _gggd._ebfeb != nil {
		return _gggd._ebfeb, nil
	}
	if _gggd.ColorSpace == nil {
		return nil, nil
	}
	_dgbbc, _gfebd := _gegaa(_gggd.ColorSpace)
	if _gfebd != nil {
		return nil, _gfebd
	}
	_gggd._ebfeb = _dgbbc
	return _gggd._ebfeb, nil
}

// ToPdfObject returns a PdfObject representation of PdfColorspaceDeviceNAttributes as a PdfObjectDictionary directly
// or indirectly within an indirect object container.
func (_egee *PdfColorspaceDeviceNAttributes) ToPdfObject() _fed.PdfObject {
	_bbcbe := _fed.MakeDict()
	if _egee.Subtype != nil {
		_bbcbe.Set("\u0053u\u0062\u0074\u0079\u0070\u0065", _egee.Subtype)
	}
	_bbcbe.SetIfNotNil("\u0043o\u006c\u006f\u0072\u0061\u006e\u0074s", _egee.Colorants)
	_bbcbe.SetIfNotNil("\u0050r\u006f\u0063\u0065\u0073\u0073", _egee.Process)
	_bbcbe.SetIfNotNil("M\u0069\u0078\u0069\u006e\u0067\u0048\u0069\u006e\u0074\u0073", _egee.MixingHints)
	if _egee._cfbb != nil {
		_egee._cfbb.PdfObject = _bbcbe
		return _egee._cfbb
	}
	return _bbcbe
}

// EnableChain adds the specified certificate chain and validation data (OCSP
// and CRL information) for it to the global scope of the document DSS. The
// added data is used for validating any of the signatures present in the
// document. The LTV client attempts to build the certificate chain up to a
// trusted root by downloading any missing certificates.
func (_cega *LTV) EnableChain(chain []*_fe.Certificate) error { return _cega.enable(nil, chain, "") }

// NewPdfAnnotationHighlight returns a new text highlight annotation.
func NewPdfAnnotationHighlight() *PdfAnnotationHighlight {
	_edcf := NewPdfAnnotation()
	_egd := &PdfAnnotationHighlight{}
	_egd.PdfAnnotation = _edcf
	_egd.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_edcf.SetContext(_egd)
	return _egd
}
func (_egecd *PdfReader) buildOutlineTree(_cdeba _fed.PdfObject, _eeac *PdfOutlineTreeNode, _gddd *PdfOutlineTreeNode, _cace map[_fed.PdfObject]struct{}) (*PdfOutlineTreeNode, *PdfOutlineTreeNode, error) {
	if _cace == nil {
		_cace = map[_fed.PdfObject]struct{}{}
	}
	_cace[_cdeba] = struct{}{}
	_gffdf, _aacag := _cdeba.(*_fed.PdfIndirectObject)
	if !_aacag {
		return nil, nil, _d.Errorf("\u006f\u0075\u0074\u006c\u0069\u006e\u0065 \u0063\u006f\u006et\u0061\u0069\u006e\u0065r\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0025\u0054", _cdeba)
	}
	_gcafd, _egbc := _gffdf.PdfObject.(*_fed.PdfObjectDictionary)
	if !_egbc {
		return nil, nil, _bb.New("\u006e\u006f\u0074 a\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
	}
	_fef.Log.Trace("\u0062\u0075\u0069\u006c\u0064\u0020\u006f\u0075\u0074\u006c\u0069\u006e\u0065 \u0074\u0072\u0065\u0065\u003a\u0020d\u0069\u0063\u0074\u003a\u0020\u0025\u0076\u0020\u0028\u0025\u0076\u0029\u0020p\u003a\u0020\u0025\u0070", _gcafd, _gffdf, _gffdf)
	if _abdb := _gcafd.Get("\u0054\u0069\u0074l\u0065"); _abdb != nil {
		_cbabd, _gdacb := _egecd.newPdfOutlineItemFromIndirectObject(_gffdf)
		if _gdacb != nil {
			return nil, nil, _gdacb
		}
		_cbabd.Parent = _eeac
		_cbabd.Prev = _gddd
		_dedg := _fed.ResolveReference(_gcafd.Get("\u0046\u0069\u0072s\u0074"))
		if _, _cegef := _cace[_dedg]; _dedg != nil && _dedg != _gffdf && !_cegef {
			if !_fed.IsNullObject(_dedg) {
				_abfad, _bdgdd, _gccea := _egecd.buildOutlineTree(_dedg, &_cbabd.PdfOutlineTreeNode, nil, _cace)
				if _gccea != nil {
					_fef.Log.Debug("D\u0045\u0042U\u0047\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0075\u0069\u006c\u0064\u0020\u006fu\u0074\u006c\u0069\u006e\u0065\u0020\u0069\u0074\u0065\u006d\u0020\u0074\u0072\u0065\u0065\u003a \u0025\u0076\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020n\u006f\u0064\u0065\u0020\u0063\u0068\u0069\u006c\u0064\u0072\u0065n\u002e", _gccea)
				} else {
					_cbabd.First = _abfad
					_cbabd.Last = _bdgdd
				}
			}
		}
		_cfgc := _fed.ResolveReference(_gcafd.Get("\u004e\u0065\u0078\u0074"))
		if _, _cgagd := _cace[_cfgc]; _cfgc != nil && _cfgc != _gffdf && !_cgagd {
			if !_fed.IsNullObject(_cfgc) {
				_degbc, _aeedf, _acbdd := _egecd.buildOutlineTree(_cfgc, _eeac, &_cbabd.PdfOutlineTreeNode, _cace)
				if _acbdd != nil {
					_fef.Log.Debug("D\u0045\u0042U\u0047\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0075\u0069\u006c\u0064\u0020\u006fu\u0074\u006c\u0069\u006e\u0065\u0020\u0074\u0072\u0065\u0065\u0020\u0066\u006f\u0072\u0020\u004ee\u0078\u0074\u0020\u006e\u006f\u0064\u0065\u003a\u0020\u0025\u0076\u002e\u0020S\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u006e\u006f\u0064e\u002e", _acbdd)
				} else {
					_cbabd.Next = _degbc
					return &_cbabd.PdfOutlineTreeNode, _aeedf, nil
				}
			}
		}
		return &_cbabd.PdfOutlineTreeNode, &_cbabd.PdfOutlineTreeNode, nil
	}
	_aeced, _cgee := _efaeg(_gffdf)
	if _cgee != nil {
		return nil, nil, _cgee
	}
	_aeced.Parent = _eeac
	if _gcdgg := _gcafd.Get("\u0046\u0069\u0072s\u0074"); _gcdgg != nil {
		_gcdgg = _fed.ResolveReference(_gcdgg)
		if _, _dbdb := _cace[_gcdgg]; _gcdgg != nil && _gcdgg != _gffdf && !_dbdb {
			_adabe := _fed.TraceToDirectObject(_gcdgg)
			if _, _cgbae := _adabe.(*_fed.PdfObjectNull); !_cgbae && _adabe != nil {
				_gfgdg, _dacab, _dfed := _egecd.buildOutlineTree(_gcdgg, &_aeced.PdfOutlineTreeNode, nil, _cace)
				if _dfed != nil {
					_fef.Log.Debug("\u0044\u0045\u0042\u0055\u0047\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020b\u0075\u0069\u006c\u0064\u0020\u006f\u0075\u0074\u006c\u0069n\u0065\u0020\u0074\u0072\u0065\u0065\u003a\u0020\u0025\u0076\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u0020\u006e\u006f\u0064\u0065 \u0063\u0068i\u006c\u0064r\u0065n\u002e", _dfed)
				} else {
					_aeced.First = _gfgdg
					_aeced.Last = _dacab
				}
			}
		}
	}
	return &_aeced.PdfOutlineTreeNode, &_aeced.PdfOutlineTreeNode, nil
}

// RemovePage removes a page by number.
func (_geaa *PdfAppender) RemovePage(pageNum int) {
	_fgbc := pageNum - 1
	_geaa._dce = append(_geaa._dce[0:_fgbc], _geaa._dce[pageNum:]...)
}

// SetDecode sets the decode image float slice.
func (_fcdca *Image) SetDecode(decode []float64) { _fcdca._ccdge = decode }
func (_ddac *PdfReader) newPdfActionRenditionFromDict(_gca *_fed.PdfObjectDictionary) (*PdfActionRendition, error) {
	return &PdfActionRendition{R: _gca.Get("\u0052"), AN: _gca.Get("\u0041\u004e"), OP: _gca.Get("\u004f\u0050"), JS: _gca.Get("\u004a\u0053")}, nil
}

// EnableAll LTV enables all signatures in the PDF document.
// The signing certificate chain is extracted from each signature dictionary.
// Optionally, additional certificates can be specified through the
// `extraCerts` parameter. The LTV client attempts to build the certificate
// chain up to a trusted root by downloading any missing certificates.
func (_dgdc *LTV) EnableAll(extraCerts []*_fe.Certificate) error {
	_dbgfd := _dgdc._cgbeg._ccc.AcroForm
	for _, _gcaag := range _dbgfd.AllFields() {
		_ddef, _ := _gcaag.GetContext().(*PdfFieldSignature)
		if _ddef == nil {
			continue
		}
		_fgfba := _ddef.V
		if _bafa := _dgdc.validateSig(_fgfba); _bafa != nil {
			_fef.Log.Debug("\u0057\u0041\u0052N\u003a\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020f\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u0076", _bafa)
		}
		if _cgcac := _dgdc.Enable(_fgfba, extraCerts); _cgcac != nil {
			return _cgcac
		}
	}
	return nil
}
func (_ffg *PdfReader) newPdfActionResetFormFromDict(_ddag *_fed.PdfObjectDictionary) (*PdfActionResetForm, error) {
	return &PdfActionResetForm{Fields: _ddag.Get("\u0046\u0069\u0065\u006c\u0064\u0073"), Flags: _ddag.Get("\u0046\u006c\u0061g\u0073")}, nil
}

// NewGrayImageFromGoImage creates a new grayscale unidoc Image from a golang Image.
func (_eefad DefaultImageHandler) NewGrayImageFromGoImage(goimg _ee.Image) (*Image, error) {
	_ceafa := goimg.Bounds()
	_efcda := &Image{Width: int64(_ceafa.Dx()), Height: int64(_ceafa.Dy()), ColorComponents: 1, BitsPerComponent: 8}
	switch _daeee := goimg.(type) {
	case *_ee.Gray:
		if len(_daeee.Pix) != _ceafa.Dx()*_ceafa.Dy() {
			_gaabf, _fcaee := _eede.GrayConverter.Convert(goimg)
			if _fcaee != nil {
				return nil, _fcaee
			}
			_efcda.Data = _gaabf.Pix()
		} else {
			_efcda.Data = _daeee.Pix
		}
	case *_ee.Gray16:
		_efcda.BitsPerComponent = 16
		if len(_daeee.Pix) != _ceafa.Dx()*_ceafa.Dy()*2 {
			_dedegb, _cbea := _eede.Gray16Converter.Convert(goimg)
			if _cbea != nil {
				return nil, _cbea
			}
			_efcda.Data = _dedegb.Pix()
		} else {
			_efcda.Data = _daeee.Pix
		}
	case _eede.Image:
		_fbdd := _daeee.Base()
		if _fbdd.ColorComponents == 1 {
			_efcda.BitsPerComponent = int64(_fbdd.BitsPerComponent)
			_efcda.Data = _fbdd.Data
			return _efcda, nil
		}
		_cbdbf, _cbcgb := _eede.GrayConverter.Convert(goimg)
		if _cbcgb != nil {
			return nil, _cbcgb
		}
		_efcda.Data = _cbdbf.Pix()
	default:
		_fedg, _dbgbd := _eede.GrayConverter.Convert(goimg)
		if _dbgbd != nil {
			return nil, _dbgbd
		}
		_efcda.Data = _fedg.Pix()
	}
	return _efcda, nil
}

// ToPdfObject implements interface PdfModel.
func (_geggg *PdfSignature) ToPdfObject() _fed.PdfObject {
	_bdbgc := _geggg._gccdf
	var _ebffc *_fed.PdfObjectDictionary
	if _aadb, _gaefg := _bdbgc.PdfObject.(*pdfSignDictionary); _gaefg {
		_ebffc = _aadb.PdfObjectDictionary
	} else {
		_ebffc = _bdbgc.PdfObject.(*_fed.PdfObjectDictionary)
	}
	_ebffc.SetIfNotNil("\u0054\u0079\u0070\u0065", _geggg.Type)
	_ebffc.SetIfNotNil("\u0046\u0069\u006c\u0074\u0065\u0072", _geggg.Filter)
	_ebffc.SetIfNotNil("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r", _geggg.SubFilter)
	_ebffc.SetIfNotNil("\u0042y\u0074\u0065\u0052\u0061\u006e\u0067e", _geggg.ByteRange)
	_ebffc.SetIfNotNil("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073", _geggg.Contents)
	_ebffc.SetIfNotNil("\u0043\u0065\u0072\u0074", _geggg.Cert)
	_ebffc.SetIfNotNil("\u004e\u0061\u006d\u0065", _geggg.Name)
	_ebffc.SetIfNotNil("\u0052\u0065\u0061\u0073\u006f\u006e", _geggg.Reason)
	_ebffc.SetIfNotNil("\u004d", _geggg.M)
	_ebffc.SetIfNotNil("\u0052e\u0066\u0065\u0072\u0065\u006e\u0063e", _geggg.Reference)
	_ebffc.SetIfNotNil("\u0043h\u0061\u006e\u0067\u0065\u0073", _geggg.Changes)
	_ebffc.SetIfNotNil("C\u006f\u006e\u0074\u0061\u0063\u0074\u0049\u006e\u0066\u006f", _geggg.ContactInfo)
	return _bdbgc
}

// PdfActionGoToE represents a GoToE action.
type PdfActionGoToE struct {
	*PdfAction
	F         *PdfFilespec
	D         _fed.PdfObject
	NewWindow _fed.PdfObject
	T         _fed.PdfObject
}

// NewDSS returns a new DSS dictionary.
func NewDSS() *DSS {
	return &DSS{_dcaa: _fed.MakeIndirectObject(_fed.MakeDict()), VRI: map[string]*VRI{}}
}
func (_caec *PdfReader) newPdfAnnotationScreenFromDict(_aab *_fed.PdfObjectDictionary) (*PdfAnnotationScreen, error) {
	_edae := PdfAnnotationScreen{}
	_edae.T = _aab.Get("\u0054")
	_edae.MK = _aab.Get("\u004d\u004b")
	_edae.A = _aab.Get("\u0041")
	_edae.AA = _aab.Get("\u0041\u0041")
	return &_edae, nil
}

// XObjectType represents the type of an XObject.
type XObjectType int

// Duplicate creates a duplicate page based on the current one and returns it.
func (_gcbcb *PdfPage) Duplicate() *PdfPage {
	_dgga := *_gcbcb
	_dgga._bdgge = _fed.MakeDict()
	_dgga._efbb = _fed.MakeIndirectObject(_dgga._bdgge)
	return &_dgga
}

var _ _fed.PdfObject = &pdfSignDictionary{}

// WriteString outputs the object as it is to be written to file.
func (_ddbabe *pdfSignDictionary) WriteString() string {
	_ddbabe._becf = 0
	_ddbabe._dgcbc = 0
	_ddbabe._acade = 0
	_ddbabe._aagf = 0
	_fcffe := _eb.NewBuffer(nil)
	_fcffe.WriteString("\u003c\u003c")
	for _, _baaa := range _ddbabe.Keys() {
		_bcfeg := _ddbabe.Get(_baaa)
		switch _baaa {
		case "\u0042y\u0074\u0065\u0052\u0061\u006e\u0067e":
			_fcffe.WriteString(_baaa.WriteString())
			_fcffe.WriteString("\u0020")
			_ddbabe._acade = _fcffe.Len()
			_fcffe.WriteString(_bcfeg.WriteString())
			_fcffe.WriteString("\u0020")
			_ddbabe._aagf = _fcffe.Len() - 1
		case "\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073":
			_fcffe.WriteString(_baaa.WriteString())
			_fcffe.WriteString("\u0020")
			_ddbabe._becf = _fcffe.Len()
			_fcffe.WriteString(_bcfeg.WriteString())
			_fcffe.WriteString("\u0020")
			_ddbabe._dgcbc = _fcffe.Len() - 1
		default:
			_fcffe.WriteString(_baaa.WriteString())
			_fcffe.WriteString("\u0020")
			_fcffe.WriteString(_bcfeg.WriteString())
		}
	}
	_fcffe.WriteString("\u003e\u003e")
	return _fcffe.String()
}

// AcroFormNeedsRepair returns true if the document contains widget annotations
// linked to fields which are not referenced in the AcroForm. The AcroForm can
// be repaired using the RepairAcroForm method of the reader.
func (_aagaa *PdfReader) AcroFormNeedsRepair() (bool, error) {
	var _agaff []*PdfField
	if _aagaa.AcroForm != nil {
		_agaff = _aagaa.AcroForm.AllFields()
	}
	_cbegc := make(map[*PdfField]struct{}, len(_agaff))
	for _, _aacae := range _agaff {
		_cbegc[_aacae] = struct{}{}
	}
	for _, _gffba := range _aagaa.PageList {
		_cbce, _cebad := _gffba.GetAnnotations()
		if _cebad != nil {
			return false, _cebad
		}
		for _, _ebde := range _cbce {
			_efff, _cfdf := _ebde.GetContext().(*PdfAnnotationWidget)
			if !_cfdf {
				continue
			}
			_efbda := _efff.Field()
			if _efbda == nil {
				return true, nil
			}
			if _, _cdefa := _cbegc[_efbda]; !_cdefa {
				return true, nil
			}
		}
	}
	return false, nil
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components.
func (_dgfa *PdfColorspaceSpecialPattern) ColorFromFloats(vals []float64) (PdfColor, error) {
	if _dgfa.UnderlyingCS == nil {
		return nil, _bb.New("u\u006e\u0064\u0065\u0072\u006c\u0079i\u006e\u0067\u0020\u0043\u0053\u0020\u006e\u006f\u0074 \u0073\u0070\u0065c\u0069f\u0069\u0065\u0064")
	}
	return _dgfa.UnderlyingCS.ColorFromFloats(vals)
}
func (_cabge *PdfWriter) copyObject(_cfcacd _fed.PdfObject, _cbdbee map[_fed.PdfObject]_fed.PdfObject, _cdaad map[_fed.PdfObject]struct{}, _dcdcc bool) _fed.PdfObject {
	_gebcb := !_cabge._bgeec && _cdaad != nil
	if _bagbg, _deaed := _cbdbee[_cfcacd]; _deaed {
		if _gebcb && !_dcdcc {
			delete(_cdaad, _cfcacd)
		}
		return _bagbg
	}
	_aecbc := _cfcacd
	switch _cecbg := _cfcacd.(type) {
	case *_fed.PdfObjectArray:
		_defdd := _fed.MakeArray()
		_aecbc = _defdd
		_cbdbee[_cfcacd] = _aecbc
		for _, _eefaf := range _cecbg.Elements() {
			_defdd.Append(_cabge.copyObject(_eefaf, _cbdbee, _cdaad, _dcdcc))
		}
	case *_fed.PdfObjectStreams:
		_cbfag := &_fed.PdfObjectStreams{PdfObjectReference: _cecbg.PdfObjectReference}
		_aecbc = _cbfag
		_cbdbee[_cfcacd] = _aecbc
		for _, _gaafb := range _cecbg.Elements() {
			_cbfag.Append(_cabge.copyObject(_gaafb, _cbdbee, _cdaad, _dcdcc))
		}
	case *_fed.PdfObjectStream:
		_abebg := &_fed.PdfObjectStream{Stream: _cecbg.Stream, PdfObjectReference: _cecbg.PdfObjectReference}
		_aecbc = _abebg
		_cbdbee[_cfcacd] = _aecbc
		_abebg.PdfObjectDictionary = _cabge.copyObject(_cecbg.PdfObjectDictionary, _cbdbee, _cdaad, _dcdcc).(*_fed.PdfObjectDictionary)
	case *_fed.PdfObjectDictionary:
		var _cfgga bool
		if _gebcb && !_dcdcc {
			if _deefc, _ := _fed.GetNameVal(_cecbg.Get("\u0054\u0079\u0070\u0065")); _deefc == "\u0050\u0061\u0067\u0065" {
				_, _efbad := _cabge._aadcf[_cecbg]
				_dcdcc = !_efbad
				_cfgga = _dcdcc
			}
		}
		_fedbg := _fed.MakeDict()
		_aecbc = _fedbg
		_cbdbee[_cfcacd] = _aecbc
		for _, _fdgdc := range _cecbg.Keys() {
			_fedbg.Set(_fdgdc, _cabge.copyObject(_cecbg.Get(_fdgdc), _cbdbee, _cdaad, _dcdcc))
		}
		if _cfgga {
			_aecbc = _fed.MakeNull()
			_dcdcc = false
		}
	case *_fed.PdfIndirectObject:
		_adfdcd := &_fed.PdfIndirectObject{PdfObjectReference: _cecbg.PdfObjectReference}
		_aecbc = _adfdcd
		_cbdbee[_cfcacd] = _aecbc
		_adfdcd.PdfObject = _cabge.copyObject(_cecbg.PdfObject, _cbdbee, _cdaad, _dcdcc)
	case *_fed.PdfObjectString:
		_gfca := *_cecbg
		_aecbc = &_gfca
		_cbdbee[_cfcacd] = _aecbc
	case *_fed.PdfObjectName:
		_gadf := *_cecbg
		_aecbc = &_gadf
		_cbdbee[_cfcacd] = _aecbc
	case *_fed.PdfObjectNull:
		_aecbc = _fed.MakeNull()
		_cbdbee[_cfcacd] = _aecbc
	case *_fed.PdfObjectInteger:
		_gbeba := *_cecbg
		_aecbc = &_gbeba
		_cbdbee[_cfcacd] = _aecbc
	case *_fed.PdfObjectReference:
		_ffee := *_cecbg
		_aecbc = &_ffee
		_cbdbee[_cfcacd] = _aecbc
	case *_fed.PdfObjectFloat:
		_cbdgd := *_cecbg
		_aecbc = &_cbdgd
		_cbdbee[_cfcacd] = _aecbc
	case *_fed.PdfObjectBool:
		_cdegf := *_cecbg
		_aecbc = &_cdegf
		_cbdbee[_cfcacd] = _aecbc
	case *pdfSignDictionary:
		_adca := &pdfSignDictionary{PdfObjectDictionary: _fed.MakeDict(), _gdgfa: _cecbg._gdgfa, _agafa: _cecbg._agafa}
		_aecbc = _adca
		_cbdbee[_cfcacd] = _aecbc
		for _, _eedce := range _cecbg.Keys() {
			_adca.Set(_eedce, _cabge.copyObject(_cecbg.Get(_eedce), _cbdbee, _cdaad, _dcdcc))
		}
	default:
		_fef.Log.Info("\u0054\u004f\u0044\u004f\u0028\u0061\u0035\u0069\u0029\u003a\u0020\u0069\u006dp\u006c\u0065\u006d\u0065\u006e\u0074 \u0063\u006f\u0070\u0079\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0066\u006fr\u0020\u0025\u002b\u0076", _cfcacd)
	}
	if _gebcb && _dcdcc {
		_cdaad[_cfcacd] = struct{}{}
	}
	return _aecbc
}

// ImageToRGB converts an Image in a given PdfColorspace to an RGB image.
func (_efaad *PdfColorspaceDeviceN) ImageToRGB(img Image) (Image, error) {
	_ccda := _bba.NewReader(img.getBase())
	_dgba := _eede.NewImageBase(int(img.Width), int(img.Height), int(img.BitsPerComponent), img.ColorComponents, nil, img._caeaf, img._ccdge)
	_babg := _bba.NewWriter(_dgba)
	_faeb := _bg.Pow(2, float64(img.BitsPerComponent)) - 1
	_eadfa := _efaad.GetNumComponents()
	_baea := make([]uint32, _eadfa)
	_edda := make([]float64, _eadfa)
	for {
		_efde := _ccda.ReadSamples(_baea)
		if _efde == _ge.EOF {
			break
		} else if _efde != nil {
			return img, _efde
		}
		for _babea := 0; _babea < _eadfa; _babea++ {
			_fbbg := float64(_baea[_babea]) / _faeb
			_edda[_babea] = _fbbg
		}
		_cfgd, _efde := _efaad.TintTransform.Evaluate(_edda)
		if _efde != nil {
			return img, _efde
		}
		for _, _eefa := range _cfgd {
			_eefa = _bg.Min(_bg.Max(0, _eefa), 1.0)
			if _efde = _babg.WriteSample(uint32(_eefa * _faeb)); _efde != nil {
				return img, _efde
			}
		}
	}
	return _efaad.AlternateSpace.ImageToRGB(_ddbab(&_dgba))
}
func _gegaa(_ggfea _fed.PdfObject) (*PdfPageResourcesColorspaces, error) {
	_baeb := &PdfPageResourcesColorspaces{}
	if _agcaf, _dbbga := _ggfea.(*_fed.PdfIndirectObject); _dbbga {
		_baeb._bdbfa = _agcaf
		_ggfea = _agcaf.PdfObject
	}
	_cfga, _fcgcc := _fed.GetDict(_ggfea)
	if !_fcgcc {
		return nil, _bb.New("\u0043\u0053\u0020at\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_baeb.Names = []string{}
	_baeb.Colorspaces = map[string]PdfColorspace{}
	for _, _caece := range _cfga.Keys() {
		_dadge := _cfga.Get(_caece)
		_baeb.Names = append(_baeb.Names, string(_caece))
		_cbbec, _geafa := NewPdfColorspaceFromPdfObject(_dadge)
		if _geafa != nil {
			return nil, _geafa
		}
		_baeb.Colorspaces[string(_caece)] = _cbbec
	}
	return _baeb, nil
}

// ToPdfObject returns the PDF representation of the colorspace.
func (_bbfd *PdfColorspaceSpecialPattern) ToPdfObject() _fed.PdfObject {
	if _bbfd.UnderlyingCS == nil {
		return _fed.MakeName("\u0050a\u0074\u0074\u0065\u0072\u006e")
	}
	_efdc := _fed.MakeArray(_fed.MakeName("\u0050a\u0074\u0074\u0065\u0072\u006e"))
	_efdc.Append(_bbfd.UnderlyingCS.ToPdfObject())
	if _bbfd._afff != nil {
		_bbfd._afff.PdfObject = _efdc
		return _bbfd._afff
	}
	return _efdc
}
func (_badgfd *PdfReader) newPdfFieldSignatureFromDict(_effc *_fed.PdfObjectDictionary) (*PdfFieldSignature, error) {
	_cdgde := &PdfFieldSignature{}
	_fdbag, _dbbffg := _fed.GetIndirect(_effc.Get("\u0056"))
	if _dbbffg {
		var _dddea error
		_cdgde.V, _dddea = _badgfd.newPdfSignatureFromIndirect(_fdbag)
		if _dddea != nil {
			return nil, _dddea
		}
	}
	_cdgde.Lock, _ = _fed.GetIndirect(_effc.Get("\u004c\u006f\u0063\u006b"))
	_cdgde.SV, _ = _fed.GetIndirect(_effc.Get("\u0053\u0056"))
	return _cdgde, nil
}
func _ffadd(_bfdc *_fed.PdfObjectDictionary) (*PdfFieldText, error) {
	_fffdf := &PdfFieldText{}
	_fffdf.DA, _ = _fed.GetString(_bfdc.Get("\u0044\u0041"))
	_fffdf.Q, _ = _fed.GetInt(_bfdc.Get("\u0051"))
	_fffdf.DS, _ = _fed.GetString(_bfdc.Get("\u0044\u0053"))
	_fffdf.RV = _bfdc.Get("\u0052\u0056")
	_fffdf.MaxLen, _ = _fed.GetInt(_bfdc.Get("\u004d\u0061\u0078\u004c\u0065\u006e"))
	return _fffdf, nil
}

// ToPdfObject returns the PDF representation of the colorspace.
func (_agfb *PdfColorspaceDeviceRGB) ToPdfObject() _fed.PdfObject {
	return _fed.MakeName("\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B")
}
func _febfa(_aged *_fed.PdfObjectDictionary, _bcee *fontCommon) (*pdfFontType3, error) {
	_dgfda := _ggfg(_bcee)
	_efgc := _aged.Get("\u0046i\u0072\u0073\u0074\u0043\u0068\u0061r")
	if _efgc == nil {
		_efgc = _fed.MakeInteger(0)
	}
	_dgfda.FirstChar = _efgc
	_bbgg, _gcee := _fed.GetIntVal(_efgc)
	if !_gcee {
		_fef.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u0046i\u0072s\u0074C\u0068\u0061\u0072\u0020\u0074\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029", _efgc)
		return nil, _fed.ErrTypeError
	}
	_bddba := _dg.CharCode(_bbgg)
	_efgc = _aged.Get("\u004c\u0061\u0073\u0074\u0043\u0068\u0061\u0072")
	if _efgc == nil {
		_efgc = _fed.MakeInteger(255)
	}
	_dgfda.LastChar = _efgc
	_bbgg, _gcee = _fed.GetIntVal(_efgc)
	if !_gcee {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004c\u0061\u0073\u0074\u0043h\u0061\u0072\u0020\u0074\u0079\u0070\u0065 \u0028\u0025\u0054\u0029", _efgc)
		return nil, _fed.ErrTypeError
	}
	_adgce := _dg.CharCode(_bbgg)
	_efgc = _aged.Get("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s")
	if _efgc != nil {
		_dgfda.Resources = _efgc
	}
	_efgc = _aged.Get("\u0043h\u0061\u0072\u0050\u0072\u006f\u0063s")
	if _efgc == nil {
		_fef.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0068\u0061\u0072\u0050\u0072\u006f\u0063\u0073\u0020(%\u0076\u0029", _efgc)
		return nil, _fed.ErrNotSupported
	}
	_dgfda.CharProcs = _efgc
	_efgc = _aged.Get("\u0046\u006f\u006e\u0074\u004d\u0061\u0074\u0072\u0069\u0078")
	if _efgc == nil {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0046\u006f\u006et\u004d\u0061\u0074\u0072\u0069\u0078\u0020\u0028\u0025\u0076\u0029", _efgc)
		return nil, _fed.ErrNotSupported
	}
	_dgfda.FontMatrix = _efgc
	_dgfda._cadbe = make(map[_dg.CharCode]float64)
	_efgc = _aged.Get("\u0057\u0069\u0064\u0074\u0068\u0073")
	if _efgc != nil {
		_dgfda.Widths = _efgc
		_agcce, _ddeg := _fed.GetArray(_efgc)
		if !_ddeg {
			_fef.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020W\u0069\u0064t\u0068\u0073\u0020\u0061\u0074\u0074\u0072\u0069b\u0075\u0074\u0065\u0020\u0021\u003d\u0020\u0061\u0072\u0072\u0061\u0079 \u0028\u0025\u0054\u0029", _efgc)
			return nil, _fed.ErrTypeError
		}
		_abbee, _gebb := _agcce.ToFloat64Array()
		if _gebb != nil {
			_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0077\u0069d\u0074\u0068\u0073\u0020\u0074\u006f\u0020a\u0072\u0072\u0061\u0079")
			return nil, _gebb
		}
		if len(_abbee) != int(_adgce-_bddba+1) {
			_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0077\u0069\u0064\u0074\u0068s\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0025\u0064 \u0028\u0025\u0064\u0029", _adgce-_bddba+1, len(_abbee))
			return nil, _fed.ErrRangeError
		}
		_gdecb, _ddeg := _fed.GetArray(_dgfda.FontMatrix)
		if !_ddeg {
			_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0046\u006f\u006e\u0074\u004d\u0061\u0074\u0072\u0069\u0078\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0021\u003d\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0028\u0025\u0054\u0029", _gdecb)
			return nil, _gebb
		}
		_efgfc, _gebb := _gdecb.ToFloat64Array()
		if _gebb != nil {
			_fef.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020c\u006f\u006ev\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0046o\u006e\u0074\u004d\u0061\u0074\u0072\u0069\u0078\u0020\u0074\u006f\u0020a\u0072\u0072\u0061\u0079")
			return nil, _gebb
		}
		_gdbaf := _ce.NewMatrix(_efgfc[0], _efgfc[1], _efgfc[2], _efgfc[3], _efgfc[4], _efgfc[5])
		for _gagb, _faefa := range _abbee {
			_bbegg, _ := _gdbaf.Transform(_faefa, _faefa)
			_dgfda._cadbe[_bddba+_dg.CharCode(_gagb)] = _bbegg
		}
	}
	_dgfda.Encoding = _fed.TraceToDirectObject(_aged.Get("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067"))
	_abbga := _aged.Get("\u0054o\u0055\u006e\u0069\u0063\u006f\u0064e")
	if _abbga != nil {
		_dgfda._bbfbc = _fed.TraceToDirectObject(_abbga)
		_bgfdad, _cefda := _ddfcf(_dgfda._bbfbc, &_dgfda.fontCommon)
		if _cefda != nil {
			return nil, _cefda
		}
		_dgfda._ecfd = _bgfdad
	}
	if _gbdfd := _dgfda._ecfd; _gbdfd != nil {
		_dgfda._gefc = _dg.NewCMapEncoder("", nil, _gbdfd)
	} else {
		_dgfda._gefc = _dg.NewPdfDocEncoder()
	}
	return _dgfda, nil
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain a single element between 0 and 1.
func (_gfdcb *PdfColorspaceDeviceGray) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 1 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_dad := vals[0]
	if _dad < 0.0 || _dad > 1.0 {
		_fef.Log.Debug("\u0049\u006eco\u006d\u0070\u0061t\u0069\u0062\u0069\u006city\u003a R\u0061\u006e\u0067\u0065\u0020\u006f\u0075ts\u0069\u0064\u0065\u0020\u005b\u0030\u002c1\u005d")
	}
	if _dad < 0.0 {
		_dad = 0.0
	} else if _dad > 1.0 {
		_dad = 1.0
	}
	return NewPdfColorDeviceGray(_dad), nil
}

// GetRuneMetrics returns the character metrics for the specified rune.
// A bool flag is returned to indicate whether or not the entry was found.
func (_cbcfe pdfFontType0) GetRuneMetrics(r rune) (_geg.CharMetrics, bool) {
	if _cbcfe.DescendantFont == nil {
		_fef.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u004e\u006f\u0020\u0064\u0065\u0073\u0063\u0065\u006e\u0064\u0061\u006e\u0074\u002e\u0020\u0066\u006f\u006et=\u0025\u0073", _cbcfe)
		return _geg.CharMetrics{}, false
	}
	return _cbcfe.DescendantFont.GetRuneMetrics(r)
}

// DefaultFont returns the default font, which is currently the built in Helvetica.
func DefaultFont() *PdfFont {
	_ggbba, _aeab := _geg.NewStdFontByName(HelveticaName)
	if !_aeab {
		panic("\u0048\u0065lv\u0065\u0074\u0069c\u0061\u0020\u0073\u0068oul\u0064 a\u006c\u0077\u0061\u0079\u0073\u0020\u0062e \u0061\u0076\u0061\u0069\u006c\u0061\u0062l\u0065")
	}
	_ggaef := _edec(_ggbba)
	return &PdfFont{_gdaa: &_ggaef}
}

// ToPdfObject returns the PdfFontDescriptor as a PDF dictionary inside an indirect object.
func (_ceee *PdfFontDescriptor) ToPdfObject() _fed.PdfObject {
	_cagf := _fed.MakeDict()
	if _ceee._eafa == nil {
		_ceee._eafa = &_fed.PdfIndirectObject{}
	}
	_ceee._eafa.PdfObject = _cagf
	_cagf.Set("\u0054\u0079\u0070\u0065", _fed.MakeName("\u0046\u006f\u006e\u0074\u0044\u0065\u0073\u0063\u0072i\u0070\u0074\u006f\u0072"))
	if _ceee.FontName != nil {
		_cagf.Set("\u0046\u006f\u006e\u0074\u004e\u0061\u006d\u0065", _ceee.FontName)
	}
	if _ceee.FontFamily != nil {
		_cagf.Set("\u0046\u006f\u006e\u0074\u0046\u0061\u006d\u0069\u006c\u0079", _ceee.FontFamily)
	}
	if _ceee.FontStretch != nil {
		_cagf.Set("F\u006f\u006e\u0074\u0053\u0074\u0072\u0065\u0074\u0063\u0068", _ceee.FontStretch)
	}
	if _ceee.FontWeight != nil {
		_cagf.Set("\u0046\u006f\u006e\u0074\u0057\u0065\u0069\u0067\u0068\u0074", _ceee.FontWeight)
	}
	if _ceee.Flags != nil {
		_cagf.Set("\u0046\u006c\u0061g\u0073", _ceee.Flags)
	}
	if _ceee.FontBBox != nil {
		_cagf.Set("\u0046\u006f\u006e\u0074\u0042\u0042\u006f\u0078", _ceee.FontBBox)
	}
	if _ceee.ItalicAngle != nil {
		_cagf.Set("I\u0074\u0061\u006c\u0069\u0063\u0041\u006e\u0067\u006c\u0065", _ceee.ItalicAngle)
	}
	if _ceee.Ascent != nil {
		_cagf.Set("\u0041\u0073\u0063\u0065\u006e\u0074", _ceee.Ascent)
	}
	if _ceee.Descent != nil {
		_cagf.Set("\u0044e\u0073\u0063\u0065\u006e\u0074", _ceee.Descent)
	}
	if _ceee.Leading != nil {
		_cagf.Set("\u004ce\u0061\u0064\u0069\u006e\u0067", _ceee.Leading)
	}
	if _ceee.CapHeight != nil {
		_cagf.Set("\u0043a\u0070\u0048\u0065\u0069\u0067\u0068t", _ceee.CapHeight)
	}
	if _ceee.XHeight != nil {
		_cagf.Set("\u0058H\u0065\u0069\u0067\u0068\u0074", _ceee.XHeight)
	}
	if _ceee.StemV != nil {
		_cagf.Set("\u0053\u0074\u0065m\u0056", _ceee.StemV)
	}
	if _ceee.StemH != nil {
		_cagf.Set("\u0053\u0074\u0065m\u0048", _ceee.StemH)
	}
	if _ceee.AvgWidth != nil {
		_cagf.Set("\u0041\u0076\u0067\u0057\u0069\u0064\u0074\u0068", _ceee.AvgWidth)
	}
	if _ceee.MaxWidth != nil {
		_cagf.Set("\u004d\u0061\u0078\u0057\u0069\u0064\u0074\u0068", _ceee.MaxWidth)
	}
	if _ceee.MissingWidth != nil {
		_cagf.Set("\u004d\u0069\u0073s\u0069\u006e\u0067\u0057\u0069\u0064\u0074\u0068", _ceee.MissingWidth)
	}
	if _ceee.FontFile != nil {
		_cagf.Set("\u0046\u006f\u006e\u0074\u0046\u0069\u006c\u0065", _ceee.FontFile)
	}
	if _ceee.FontFile2 != nil {
		_cagf.Set("\u0046o\u006e\u0074\u0046\u0069\u006c\u00652", _ceee.FontFile2)
	}
	if _ceee.FontFile3 != nil {
		_cagf.Set("\u0046o\u006e\u0074\u0046\u0069\u006c\u00653", _ceee.FontFile3)
	}
	if _ceee.CharSet != nil {
		_cagf.Set("\u0043h\u0061\u0072\u0053\u0065\u0074", _ceee.CharSet)
	}
	if _ceee.Style != nil {
		_cagf.Set("\u0046\u006f\u006e\u0074\u004e\u0061\u006d\u0065", _ceee.FontName)
	}
	if _ceee.Lang != nil {
		_cagf.Set("\u004c\u0061\u006e\u0067", _ceee.Lang)
	}
	if _ceee.FD != nil {
		_cagf.Set("\u0046\u0044", _ceee.FD)
	}
	if _ceee.CIDSet != nil {
		_cagf.Set("\u0043\u0049\u0044\u0053\u0065\u0074", _ceee.CIDSet)
	}
	return _ceee._eafa
}
func _ddade() string {
	_gcac := "\u0051\u0057\u0045\u0052\u0054\u0059\u0055\u0049\u004f\u0050\u0041S\u0044\u0046\u0047\u0048\u004a\u004b\u004c\u005a\u0058\u0043V\u0042\u004e\u004d"
	var _bfdb _eb.Buffer
	for _dbcfc := 0; _dbcfc < 6; _dbcfc++ {
		_bfdb.WriteRune(rune(_gcac[_cdf.Intn(len(_gcac))]))
	}
	return _bfdb.String()
}

// Set applies flag fl to the flag's bitmask and returns the combined flag.
func (_cggg FieldFlag) Set(fl FieldFlag) FieldFlag { return FieldFlag(_cggg.Mask() | fl.Mask()) }

// PdfActionNamed represents a named action.
type PdfActionNamed struct {
	*PdfAction
	N _fed.PdfObject
}

func (_defbc *PdfReader) buildPageList(_ccfe *_fed.PdfIndirectObject, _fbfde *_fed.PdfIndirectObject, _gfcde map[_fed.PdfObject]struct{}) error {
	if _ccfe == nil {
		return nil
	}
	if _, _aafd := _gfcde[_ccfe]; _aafd {
		_fef.Log.Debug("\u0043\u0079\u0063l\u0069\u0063\u0020\u0072e\u0063\u0075\u0072\u0073\u0069\u006f\u006e,\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u0028\u0025\u0076\u0029", _ccfe.ObjectNumber)
		return nil
	}
	_gfcde[_ccfe] = struct{}{}
	_ceedg, _edccd := _ccfe.PdfObject.(*_fed.PdfObjectDictionary)
	if !_edccd {
		return _bb.New("n\u006f\u0064\u0065\u0020no\u0074 \u0061\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	_fadgf, _edccd := (*_ceedg).Get("\u0054\u0079\u0070\u0065").(*_fed.PdfObjectName)
	if !_edccd {
		if _ceedg.Get("\u004b\u0069\u0064\u0073") == nil {
			return _bb.New("\u006e\u006f\u0064\u0065 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0054\u0079p\u0065 \u0028\u0052\u0065\u0071\u0075\u0069\u0072e\u0064\u0029")
		}
		_fef.Log.Debug("ER\u0052\u004fR\u003a\u0020\u006e\u006f\u0064\u0065\u0020\u006d\u0069s\u0073\u0069\u006e\u0067\u0020\u0054\u0079\u0070\u0065\u002c\u0020\u0062\u0075\u0074\u0020\u0068\u0061\u0073\u0020\u004b\u0069\u0064\u0073\u002e\u0020\u0041\u0073\u0073u\u006di\u006e\u0067\u0020\u0050\u0061\u0067\u0065\u0073 \u006eo\u0064\u0065.")
		_fadgf = _fed.MakeName("\u0050\u0061\u0067e\u0073")
		_ceedg.Set("\u0054\u0079\u0070\u0065", _fadgf)
	}
	_fef.Log.Trace("\u0062\u0075\u0069\u006c\u0064\u0050a\u0067\u0065\u004c\u0069\u0073\u0074\u0020\u006e\u006f\u0064\u0065\u0020\u0074y\u0070\u0065\u003a\u0020\u0025\u0073\u0020(\u0025\u002b\u0076\u0029", *_fadgf, _ccfe)
	if *_fadgf == "\u0050\u0061\u0067\u0065" {
		_ccfb, _gcccd := _defbc.newPdfPageFromDict(_ceedg)
		if _gcccd != nil {
			return _gcccd
		}
		_ccfb.setContainer(_ccfe)
		if _fbfde != nil {
			_ceedg.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _fbfde)
		}
		_defbc._gdac = append(_defbc._gdac, _ccfe)
		_defbc.PageList = append(_defbc.PageList, _ccfb)
		return nil
	}
	if *_fadgf != "\u0050\u0061\u0067e\u0073" {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0063\u006fnt\u0065n\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067 \u006e\u006f\u006e\u0020\u0050\u0061\u0067\u0065\u002f\u0050\u0061\u0067\u0065\u0073\u0020\u006f\u0062j\u0065\u0063\u0074\u0021\u0020\u0028\u0025\u0073\u0029", _fadgf)
		return _bb.New("\u0074\u0061\u0062\u006c\u0065\u0020o\u0066\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067 \u006e\u006f\u006e\u0020\u0050\u0061\u0067\u0065\u002f\u0050\u0061\u0067\u0065\u0073 \u006fb\u006a\u0065\u0063\u0074")
	}
	if _fbfde != nil {
		_ceedg.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _fbfde)
	}
	if !_defbc._bgbff {
		_ggfa := _defbc.traverseObjectData(_ccfe)
		if _ggfa != nil {
			return _ggfa
		}
	}
	_bcbfdd, _afdca := _defbc._cdfggf.Resolve(_ceedg.Get("\u004b\u0069\u0064\u0073"))
	if _afdca != nil {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069\u006eg\u0020\u004b\u0069\u0064\u0073\u0020\u006fb\u006a\u0065\u0063\u0074")
		return _afdca
	}
	var _fcbae *_fed.PdfObjectArray
	_fcbae, _edccd = _bcbfdd.(*_fed.PdfObjectArray)
	if !_edccd {
		_ggdgb, _gdgag := _bcbfdd.(*_fed.PdfIndirectObject)
		if !_gdgag {
			return _bb.New("\u0069\u006e\u0076\u0061li\u0064\u0020\u004b\u0069\u0064\u0073\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
		}
		_fcbae, _edccd = _ggdgb.PdfObject.(*_fed.PdfObjectArray)
		if !_edccd {
			return _bb.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u004b\u0069\u0064\u0073\u0020\u0069\u006ed\u0069r\u0065\u0063\u0074\u0020\u006f\u0062\u006ae\u0063\u0074")
		}
	}
	_fef.Log.Trace("\u004b\u0069\u0064\u0073\u003a\u0020\u0025\u0073", _fcbae)
	for _gefa, _gaee := range _fcbae.Elements() {
		_fcgd, _dgcf := _fed.GetIndirect(_gaee)
		if !_dgcf {
			_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067\u0065\u0020\u006e\u006f\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074 \u006f\u0062\u006a\u0065\u0063t\u0020\u002d \u0028\u0025\u0073\u0029", _fcgd)
			return _bb.New("\u0070a\u0067\u0065\u0020\u006e\u006f\u0074\u0020\u0069\u006e\u0064\u0069r\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
		}
		_fcbae.Set(_gefa, _fcgd)
		_afdca = _defbc.buildPageList(_fcgd, _ccfe, _gfcde)
		if _afdca != nil {
			return _afdca
		}
	}
	return nil
}
func (_ddfa *PdfAcroForm) fill(_daaff FieldValueProvider, _bddcd FieldAppearanceGenerator) error {
	if _ddfa == nil {
		return nil
	}
	_dfdfg, _abgde := _daaff.FieldValues()
	if _abgde != nil {
		return _abgde
	}
	for _, _beed := range _ddfa.AllFields() {
		_dffb := _beed.PartialName()
		_bebd, _fbgaf := _dfdfg[_dffb]
		if !_fbgaf {
			if _gfgd, _fgacg := _beed.FullName(); _fgacg == nil {
				_bebd, _fbgaf = _dfdfg[_gfgd]
			}
		}
		if !_fbgaf {
			_fef.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020f\u006f\u0072\u006d \u0066\u0069\u0065l\u0064\u0020\u0025\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u0020\u0069n \u0074\u0068\u0065\u0020\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e", _dffb)
			continue
		}
		if _cdae := _abfg(_beed, _bebd); _cdae != nil {
			return _cdae
		}
		if _bddcd == nil {
			continue
		}
		for _, _acgf := range _beed.Annotations {
			_fadg, _bcfd := _bddcd.GenerateAppearanceDict(_ddfa, _beed, _acgf)
			if _bcfd != nil {
				return _bcfd
			}
			_acgf.AP = _fadg
			_acgf.ToPdfObject()
		}
	}
	return nil
}
func (_adbe *PdfColorspaceDeviceRGB) String() string {
	return "\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B"
}
func (_ebga *pdfFontType0) bytesToCharcodes(_eaga []byte) ([]_dg.CharCode, bool) {
	if _ebga._adgcc == nil {
		return nil, false
	}
	_acgabb, _dddd := _ebga._adgcc.BytesToCharcodes(_eaga)
	if !_dddd {
		return nil, false
	}
	_abga := make([]_dg.CharCode, len(_acgabb))
	for _adddc, _ebaa := range _acgabb {
		_abga[_adddc] = _dg.CharCode(_ebaa)
	}
	return _abga, true
}

// RunesToCharcodeBytes maps the provided runes to charcode bytes and it
// returns the resulting slice of bytes, along with the number of runes which
// could not be converted. If the number of misses is 0, all runes were
// successfully converted.
func (_gcff *PdfFont) RunesToCharcodeBytes(data []rune) ([]byte, int) {
	var _bfgg []_dg.TextEncoder
	var _feag _dg.CMapEncoder
	if _baad := _gcff.baseFields()._ecfd; _baad != nil {
		_feag = _dg.NewCMapEncoder("", nil, _baad)
	}
	_bgeaf := _gcff.Encoder()
	if _bgeaf != nil {
		switch _cgec := _bgeaf.(type) {
		case _dg.SimpleEncoder:
			_gggcb := _cgec.BaseName()
			if _, _afac := _edfa[_gggcb]; _afac {
				_bfgg = append(_bfgg, _bgeaf)
			}
		}
	}
	if len(_bfgg) == 0 {
		if _gcff.baseFields()._ecfd != nil {
			_bfgg = append(_bfgg, _feag)
		}
		if _bgeaf != nil {
			_bfgg = append(_bfgg, _bgeaf)
		}
	}
	var _gefd _eb.Buffer
	var _ebefe int
	for _, _gecb := range data {
		var _fcddc bool
		for _, _cdafe := range _bfgg {
			if _cegbb := _cdafe.Encode(string(_gecb)); len(_cegbb) > 0 {
				_gefd.Write(_cegbb)
				_fcddc = true
				break
			}
		}
		if !_fcddc {
			_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020f\u0061\u0069\u006ce\u0064\u0020\u0074\u006f \u006d\u0061\u0070\u0020\u0072\u0075\u006e\u0065\u0020\u0060\u0025\u002b\u0071\u0060\u0020\u0074\u006f\u0020\u0063\u0068\u0061\u0072\u0063\u006f\u0064\u0065", _gecb)
			_ebefe++
		}
	}
	if _ebefe != 0 {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0061\u006cl\u0020\u0072\u0075\u006e\u0065\u0073\u0020\u0074\u006f\u0020\u0063\u0068\u0061\u0072c\u006fd\u0065\u0073\u002e\u000a"+"\u0009\u006e\u0075\u006d\u0052\u0075\u006e\u0065\u0073\u003d\u0025d\u0020\u006e\u0075\u006d\u004d\u0069\u0073\u0073\u0065\u0073=\u0025\u0064\u000a"+"\t\u0066\u006f\u006e\u0074=%\u0073 \u0065\u006e\u0063\u006f\u0064e\u0072\u0073\u003d\u0025\u002b\u0076", len(data), _ebefe, _gcff, _bfgg)
	}
	return _gefd.Bytes(), _ebefe
}

// NewPdfAnnotationFreeText returns a new free text annotation.
func NewPdfAnnotationFreeText() *PdfAnnotationFreeText {
	_dgd := NewPdfAnnotation()
	_bab := &PdfAnnotationFreeText{}
	_bab.PdfAnnotation = _dgd
	_bab.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_dgd.SetContext(_bab)
	return _bab
}

// String returns a human readable description of `fontfile`.
func (_cebc *fontFile) String() string {
	_eaba := "\u005b\u004e\u006f\u006e\u0065\u005d"
	if _cebc._dddff != nil {
		_eaba = _cebc._dddff.String()
	}
	return _d.Sprintf("\u0046O\u004e\u0054\u0046\u0049\u004c\u0045\u007b\u0025\u0023\u0071\u0020e\u006e\u0063\u006f\u0064\u0065\u0072\u003d\u0025\u0073\u007d", _cebc._gaag, _eaba)
}

var _ pdfFont = (*pdfFontSimple)(nil)

func _bdgb() *modelManager {
	_gggf := modelManager{}
	_gggf._efad = map[PdfModel]_fed.PdfObject{}
	_gggf._dded = map[_fed.PdfObject]PdfModel{}
	return &_gggf
}

// ToOutlineTree returns a low level PdfOutlineTreeNode object, based on
// the current instance.
func (_aabfc *Outline) ToOutlineTree() *PdfOutlineTreeNode {
	return &_aabfc.ToPdfOutline().PdfOutlineTreeNode
}

// OutlineItem represents a PDF outline item dictionary (Table 153 - pp. 376 - 377).
type OutlineItem struct {
	Title   string         `json:"title"`
	Dest    OutlineDest    `json:"dest"`
	Entries []*OutlineItem `json:"entries,omitempty"`
}

// PdfInfoTrapped specifies pdf trapped information.
type PdfInfoTrapped string

func _bgdaa(_fbab string) (string, error) {
	var _dfdfc _eb.Buffer
	_dfdfc.WriteString(_fbab)
	_abgcd := make([]byte, 8+16)
	_gdfad := _e.Now().UTC().UnixNano()
	_f.BigEndian.PutUint64(_abgcd, uint64(_gdfad))
	_, _dcdfd := _fc.Read(_abgcd[8:])
	if _dcdfd != nil {
		return "", _dcdfd
	}
	_dfdfc.WriteString(_gf.EncodeToString(_abgcd))
	return _dfdfc.String(), nil
}
func (_bdacg *PdfField) inherit(_efaf func(*PdfField) bool) (bool, error) {
	_edgf := map[*PdfField]bool{}
	_gcce := false
	_aadd := _bdacg
	for _aadd != nil {
		if _, _gcfb := _edgf[_aadd]; _gcfb {
			return false, _bb.New("\u0072\u0065\u0063\u0075rs\u0069\u0076\u0065\u0020\u0074\u0072\u0061\u0076\u0065\u0072\u0073\u0061\u006c")
		}
		_bfdfb := _efaf(_aadd)
		if _bfdfb {
			_gcce = true
			break
		}
		_edgf[_aadd] = true
		_aadd = _aadd.Parent
	}
	return _gcce, nil
}

// GetAsShadingPattern returns a shading pattern. Check with IsShading() prior to using this.
func (_ddfab *PdfPattern) GetAsShadingPattern() *PdfShadingPattern {
	return _ddfab._ggadg.(*PdfShadingPattern)
}

// NewImageFromGoImage creates a new NRGBA32 unidoc Image from a golang Image.
// If `goimg` is grayscale (*goimage.Gray8) then calls NewGrayImageFromGoImage instead.
func (_aagb DefaultImageHandler) NewImageFromGoImage(goimg _ee.Image) (*Image, error) {
	_dfceb, _ddacg := _eede.FromGoImage(goimg)
	if _ddacg != nil {
		return nil, _ddacg
	}
	_gaefc := _ddbab(_dfceb.Base())
	return &_gaefc, nil
}

// AlphaMapFunc represents a alpha mapping function: byte -> byte. Can be used for
// thresholding the alpha channel, i.e. setting all alpha values below threshold to transparent.
type AlphaMapFunc func(_cadd byte) byte

func _cebbd(_adfg _fed.PdfObject) (*_fed.PdfObjectDictionary, *fontCommon, error) {
	_gaafc := &fontCommon{}
	if _fgac, _fbdb := _adfg.(*_fed.PdfIndirectObject); _fbdb {
		_gaafc._edfcd = _fgac.ObjectNumber
	}
	_acdb, _fgge := _fed.GetDict(_adfg)
	if !_fgge {
		_fef.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0046\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0067\u0069\u0076\u0065\u006e\u0020\u0062\u0079\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006fn\u0061\u0072\u0079\u0020\u0028\u0025\u0054\u0029", _adfg)
		return nil, nil, ErrFontNotSupported
	}
	_gbbg, _fgge := _fed.GetNameVal(_acdb.Get("\u0054\u0079\u0070\u0065"))
	if !_fgge {
		_fef.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0046o\u006e\u0074\u0020\u0049\u006ec\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069\u0074\u0079\u002e\u0020\u0054\u0079\u0070\u0065\u0020\u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, nil, ErrRequiredAttributeMissing
	}
	if _gbbg != "\u0046\u006f\u006e\u0074" {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0046\u006f\u006e\u0074\u0020\u0049\u006e\u0063\u006f\u006d\u0070\u0061t\u0069\u0062\u0069\u006c\u0069\u0074\u0079\u002e\u0020\u0054\u0079\u0070\u0065\u003d\u0025\u0071\u002e\u0020\u0053\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0025\u0071.", _gbbg, "\u0046\u006f\u006e\u0074")
		return nil, nil, _fed.ErrTypeError
	}
	_dbfa, _fgge := _fed.GetNameVal(_acdb.Get("\u0053u\u0062\u0074\u0079\u0070\u0065"))
	if !_fgge {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020F\u006f\u006e\u0074 \u0049\u006e\u0063o\u006d\u0070a\u0074\u0069\u0062\u0069\u006c\u0069t\u0079. \u0053\u0075\u0062\u0074\u0079\u0070\u0065\u0020\u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
		return nil, nil, ErrRequiredAttributeMissing
	}
	_gaafc._afge = _dbfa
	_bbfg, _fgge := _fed.GetNameVal(_acdb.Get("\u004e\u0061\u006d\u0065"))
	if _fgge {
		_gaafc._ceab = _bbfg
	}
	_fdffg := _acdb.Get("\u0054o\u0055\u006e\u0069\u0063\u006f\u0064e")
	if _fdffg != nil {
		_gaafc._bbfbc = _fed.TraceToDirectObject(_fdffg)
		_dcbdd, _gfab := _ddfcf(_gaafc._bbfbc, _gaafc)
		if _gfab != nil {
			return _acdb, _gaafc, _gfab
		}
		_gaafc._ecfd = _dcbdd
	} else if _dbfa == "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0030" || _dbfa == "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0032" {
		_ddadb, _aegdb := _edf.NewCIDSystemInfo(_acdb.Get("\u0043\u0049\u0044\u0053\u0079\u0073\u0074\u0065\u006d\u0049\u006e\u0066\u006f"))
		if _aegdb != nil {
			return _acdb, _gaafc, _aegdb
		}
		_fdac := _d.Sprintf("\u0025\u0073\u002d\u0025\u0073\u002d\u0055\u0043\u0053\u0032", _ddadb.Registry, _ddadb.Ordering)
		if _edf.IsPredefinedCMap(_fdac) {
			_gaafc._ecfd, _aegdb = _edf.LoadPredefinedCMap(_fdac)
			if _aegdb != nil {
				_fef.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0063o\u0075\u006c\u0064 \u006e\u006f\u0074\u0020l\u006f\u0061\u0064\u0020\u0070\u0072\u0065\u0064\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0043\u004d\u0061\u0070\u0020\u0025\u0073\u003a\u0020\u0025\u0076", _fdac, _aegdb)
			}
		}
	}
	_fdbaaf := _acdb.Get("\u0046\u006f\u006e\u0074\u0044\u0065\u0073\u0063\u0072i\u0070\u0074\u006f\u0072")
	if _fdbaaf != nil {
		_cbfab, _fgad := _aaee(_fdbaaf)
		if _fgad != nil {
			_fef.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0042\u0061\u0064\u0020\u0066\u006f\u006et\u0020d\u0065s\u0063r\u0069\u0070\u0074\u006f\u0072\u002e\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _fgad)
			return _acdb, _gaafc, _fgad
		}
		_gaafc._bgdgb = _cbfab
	}
	if _dbfa != "\u0054\u0079\u0070e\u0033" {
		_aecbd, _fgff := _fed.GetNameVal(_acdb.Get("\u0042\u0061\u0073\u0065\u0046\u006f\u006e\u0074"))
		if !_fgff {
			_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u006f\u006et\u0020\u0049\u006ec\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069t\u0079\u002e\u0020\u0042\u0061se\u0046\u006f\u006e\u0074\u0020\u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
			return _acdb, _gaafc, ErrRequiredAttributeMissing
		}
		_gaafc._daac = _aecbd
	}
	return _acdb, _gaafc, nil
}

// PdfColor interface represents a generic color in PDF.
type PdfColor interface{}

// Y returns the value of the yellow component of the color.
func (_gbgfg *PdfColorDeviceCMYK) Y() float64 { return _gbgfg[2] }
func _bggad(_gebcd _fed.PdfObject) (PdfFunction, error) {
	_gebcd = _fed.ResolveReference(_gebcd)
	if _gagac, _geafc := _gebcd.(*_fed.PdfObjectStream); _geafc {
		_acdfa := _gagac.PdfObjectDictionary
		_abbcg, _gbcfe := _acdfa.Get("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065").(*_fed.PdfObjectInteger)
		if !_gbcfe {
			_fef.Log.Error("F\u0075\u006e\u0063\u0074\u0069\u006fn\u0054\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u006di\u0073s\u0069\u006e\u0067")
			return nil, _bb.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074e\u0072 \u006f\u0072\u0020\u006d\u0069\u0073\u0073i\u006e\u0067")
		}
		if *_abbcg == 0 {
			return _abgc(_gagac)
		} else if *_abbcg == 4 {
			return _efbdb(_gagac)
		} else {
			return nil, _bb.New("i\u006e\u0076\u0061\u006cid\u0020f\u0075\u006e\u0063\u0074\u0069o\u006e\u0020\u0074\u0079\u0070\u0065")
		}
	} else if _cbaf, _gbbc := _gebcd.(*_fed.PdfIndirectObject); _gbbc {
		_beaca, _efbf := _cbaf.PdfObject.(*_fed.PdfObjectDictionary)
		if !_efbf {
			_fef.Log.Error("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e\u0020\u0049\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006eg\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
			return nil, _bb.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074e\u0072 \u006f\u0072\u0020\u006d\u0069\u0073\u0073i\u006e\u0067")
		}
		_deaf, _efbf := _beaca.Get("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065").(*_fed.PdfObjectInteger)
		if !_efbf {
			_fef.Log.Error("F\u0075\u006e\u0063\u0074\u0069\u006fn\u0054\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u006di\u0073s\u0069\u006e\u0067")
			return nil, _bb.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074e\u0072 \u006f\u0072\u0020\u006d\u0069\u0073\u0073i\u006e\u0067")
		}
		if *_deaf == 2 {
			return _eefba(_cbaf)
		} else if *_deaf == 3 {
			return _bgdab(_cbaf)
		} else {
			return nil, _bb.New("i\u006e\u0076\u0061\u006cid\u0020f\u0075\u006e\u0063\u0074\u0069o\u006e\u0020\u0074\u0079\u0070\u0065")
		}
	} else if _gadd, _afcca := _gebcd.(*_fed.PdfObjectDictionary); _afcca {
		_gfbc, _cbdf := _gadd.Get("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065").(*_fed.PdfObjectInteger)
		if !_cbdf {
			_fef.Log.Error("F\u0075\u006e\u0063\u0074\u0069\u006fn\u0054\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u006di\u0073s\u0069\u006e\u0067")
			return nil, _bb.New("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074e\u0072 \u006f\u0072\u0020\u006d\u0069\u0073\u0073i\u006e\u0067")
		}
		if *_gfbc == 2 {
			return _eefba(_gadd)
		} else if *_gfbc == 3 {
			return _bgdab(_gadd)
		} else {
			return nil, _bb.New("i\u006e\u0076\u0061\u006cid\u0020f\u0075\u006e\u0063\u0074\u0069o\u006e\u0020\u0074\u0079\u0070\u0065")
		}
	} else {
		_fef.Log.Debug("\u0046u\u006e\u0063\u0074\u0069\u006f\u006e\u0020\u0054\u0079\u0070\u0065 \u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0023\u0076", _gebcd)
		return nil, _bb.New("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
}

// Val returns the value of the color.
func (_ccdc *PdfColorCalGray) Val() float64 { return float64(*_ccdc) }

// ToPdfObject implements interface PdfModel.
func (_baa *PdfActionJavaScript) ToPdfObject() _fed.PdfObject {
	_baa.PdfAction.ToPdfObject()
	_dgb := _baa._fa
	_ffa := _dgb.PdfObject.(*_fed.PdfObjectDictionary)
	_ffa.SetIfNotNil("\u0053", _fed.MakeName(string(ActionTypeJavaScript)))
	_ffa.SetIfNotNil("\u004a\u0053", _baa.JS)
	return _dgb
}

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// components. The slice should contain a single PdfObjectFloat element in
// range 0-1.
func (_dgaf *PdfColorspaceCalGray) ColorFromPdfObjects(objects []_fed.PdfObject) (PdfColor, error) {
	if len(objects) != 1 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_cbcfd, _gdfb := _fed.GetNumbersAsFloat(objects)
	if _gdfb != nil {
		return nil, _gdfb
	}
	return _dgaf.ColorFromFloats(_cbcfd)
}

// ToPdfObject implements interface PdfModel.
func (_dcb *PdfAnnotationStamp) ToPdfObject() _fed.PdfObject {
	_dcb.PdfAnnotation.ToPdfObject()
	_aaccd := _dcb._ffaab
	_fcdd := _aaccd.PdfObject.(*_fed.PdfObjectDictionary)
	_dcb.PdfAnnotationMarkup.appendToPdfDictionary(_fcdd)
	_fcdd.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u0053\u0074\u0061m\u0070"))
	_fcdd.SetIfNotNil("\u004e\u0061\u006d\u0065", _dcb.Name)
	return _aaccd
}

// GetContainingPdfObject returns the container of the shading object (indirect object).
func (_gggdc *PdfShading) GetContainingPdfObject() _fed.PdfObject { return _gggdc._cdcge }

// PdfActionImportData represents a importData action.
type PdfActionImportData struct {
	*PdfAction
	F *PdfFilespec
}

// NewPdfAnnotation returns an initialized generic PDF annotation model.
func NewPdfAnnotation() *PdfAnnotation {
	_abab := &PdfAnnotation{}
	_abab._ffaab = _fed.MakeIndirectObject(_fed.MakeDict())
	return _abab
}

// Items returns all children outline items.
func (_ccca *Outline) Items() []*OutlineItem { return _ccca.Entries }

// GetCerts returns the signature certificate chain.
func (_cdafd *PdfSignature) GetCerts() ([]*_fe.Certificate, error) {
	var _deafd []func() ([]*_fe.Certificate, error)
	switch _ecgbf, _ := _fed.GetNameVal(_cdafd.SubFilter); _ecgbf {
	case "\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064", "\u0045\u0054\u0053\u0049.C\u0041\u0064\u0045\u0053\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064":
		_deafd = append(_deafd, _cdafd.extractChainFromPKCS7, _cdafd.extractChainFromCert)
	case "\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031":
		_deafd = append(_deafd, _cdafd.extractChainFromCert)
	case "\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031":
		_deafd = append(_deafd, _cdafd.extractChainFromPKCS7)
	default:
		return nil, _d.Errorf("\u0075n\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020S\u0075b\u0046i\u006c\u0074\u0065\u0072\u003a\u0020\u0025s", _ecgbf)
	}
	for _, _ddbcg := range _deafd {
		_effdc, _ecfaf := _ddbcg()
		if _ecfaf != nil {
			return nil, _ecfaf
		}
		if len(_effdc) > 0 {
			return _effdc, nil
		}
	}
	return nil, ErrSignNoCertificates
}
func (_deff *PdfShading) getShadingDict() (*_fed.PdfObjectDictionary, error) {
	_agaef := _deff._cdcge
	if _bbaf, _gbdccd := _agaef.(*_fed.PdfIndirectObject); _gbdccd {
		_aeggd, _egege := _bbaf.PdfObject.(*_fed.PdfObjectDictionary)
		if !_egege {
			return nil, _fed.ErrTypeError
		}
		return _aeggd, nil
	} else if _faedg, _fdead := _agaef.(*_fed.PdfObjectStream); _fdead {
		return _faedg.PdfObjectDictionary, nil
	} else if _gffbe, _eddef := _agaef.(*_fed.PdfObjectDictionary); _eddef {
		return _gffbe, nil
	} else {
		_fef.Log.Debug("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0061\u0063\u0063\u0065s\u0073\u0020\u0073\u0068\u0061\u0064\u0069n\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079")
		return nil, _fed.ErrTypeError
	}
}

// AppendContentBytes creates a PDF stream from `cs` and appends it to the
// array of streams specified by the pages's Contents entry.
// If `wrapContents` is true, the content stream of the page is wrapped using
// a `q/Q` operator pair, so that its state does not affect the appended
// content stream.
func (_ecde *PdfPage) AppendContentBytes(cs []byte, wrapContents bool) error {
	_ebbg := _ecde.GetContentStreamObjs()
	wrapContents = wrapContents && len(_ebbg) > 0
	_daebb := _fed.NewFlateEncoder()
	_fedee := _fed.MakeArray()
	if wrapContents {
		_dcbbb, _bffga := _fed.MakeStream([]byte("\u0071\u000a"), _daebb)
		if _bffga != nil {
			return _bffga
		}
		_fedee.Append(_dcbbb)
	}
	_fedee.Append(_ebbg...)
	if wrapContents {
		_aadebb, _cdee := _fed.MakeStream([]byte("\u000a\u0051\u000a"), _daebb)
		if _cdee != nil {
			return _cdee
		}
		_fedee.Append(_aadebb)
	}
	_bfgfd, _dfdfd := _fed.MakeStream(cs, _daebb)
	if _dfdfd != nil {
		return _dfdfd
	}
	_fedee.Append(_bfgfd)
	_ecde.Contents = _fedee
	return nil
}

// GetPageAsIndirectObject returns the page as a dictionary within an PdfIndirectObject.
func (_eafee *PdfPage) GetPageAsIndirectObject() *_fed.PdfIndirectObject { return _eafee._efbb }

// FieldFlag represents form field flags. Some of the flags can apply to all types of fields whereas other
// flags are specific.
type FieldFlag uint32

// PdfColorspaceLab is a L*, a*, b* 3 component colorspace.
type PdfColorspaceLab struct {
	WhitePoint []float64
	BlackPoint []float64
	Range      []float64
	_dfbd      *_fed.PdfIndirectObject
}

func (_ceabc *PdfReader) newPdfOutlineItemFromIndirectObject(_cbaeg *_fed.PdfIndirectObject) (*PdfOutlineItem, error) {
	_cfcf, _bdfde := _cbaeg.PdfObject.(*_fed.PdfObjectDictionary)
	if !_bdfde {
		return nil, _d.Errorf("\u006f\u0075\u0074l\u0069\u006e\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	_eceea := NewPdfOutlineItem()
	_fggb := _cfcf.Get("\u0054\u0069\u0074l\u0065")
	if _fggb == nil {
		return nil, _d.Errorf("\u006d\u0069\u0073s\u0069\u006e\u0067\u0020\u0054\u0069\u0074\u006c\u0065\u0020\u0066\u0072\u006f\u006d\u0020\u004f\u0075\u0074\u006c\u0069\u006e\u0065\u0020\u0049\u0074\u0065\u006d\u0020\u0028r\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029")
	}
	_dffbg, _gacbd := _fed.GetString(_fggb)
	if !_gacbd {
		return nil, _d.Errorf("\u0074\u0069\u0074le\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0028\u0025\u0054\u0029", _fggb)
	}
	_eceea.Title = _dffbg
	if _agdde := _cfcf.Get("\u0043\u006f\u0075n\u0074"); _agdde != nil {
		_gbee, _ffacf := _agdde.(*_fed.PdfObjectInteger)
		if !_ffacf {
			return nil, _d.Errorf("\u0063o\u0075\u006e\u0074\u0020n\u006f\u0074\u0020\u0061\u006e \u0069n\u0074e\u0067\u0065\u0072\u0020\u0028\u0025\u0054)", _agdde)
		}
		_eeeda := int64(*_gbee)
		_eceea.Count = &_eeeda
	}
	if _bgcd := _cfcf.Get("\u0044\u0065\u0073\u0074"); _bgcd != nil {
		_eceea.Dest = _fed.ResolveReference(_bgcd)
		if !_ceabc._bgbff {
			_dcag := _ceabc.traverseObjectData(_eceea.Dest)
			if _dcag != nil {
				return nil, _dcag
			}
		}
	}
	if _agada := _cfcf.Get("\u0041"); _agada != nil {
		_eceea.A = _fed.ResolveReference(_agada)
		if !_ceabc._bgbff {
			_edeb := _ceabc.traverseObjectData(_eceea.A)
			if _edeb != nil {
				return nil, _edeb
			}
		}
	}
	if _cgecc := _cfcf.Get("\u0053\u0045"); _cgecc != nil {
		_eceea.SE = nil
	}
	if _dgeea := _cfcf.Get("\u0043"); _dgeea != nil {
		_eceea.C = _fed.ResolveReference(_dgeea)
	}
	if _ffae := _cfcf.Get("\u0046"); _ffae != nil {
		_eceea.F = _fed.ResolveReference(_ffae)
	}
	return _eceea, nil
}
func (_adeaf *PdfWriter) addObjects(_ebcfa _fed.PdfObject) error {
	_fef.Log.Trace("\u0041d\u0064i\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0073\u0021")
	if _cagcc, _gacde := _ebcfa.(*_fed.PdfIndirectObject); _gacde {
		_fef.Log.Trace("\u0049\u006e\u0064\u0069\u0072\u0065\u0063\u0074")
		_fef.Log.Trace("\u002d \u0025\u0073\u0020\u0028\u0025\u0070)", _ebcfa, _cagcc)
		_fef.Log.Trace("\u002d\u0020\u0025\u0073", _cagcc.PdfObject)
		if _adeaf.addObject(_cagcc) {
			_dgdgf := _adeaf.addObjects(_cagcc.PdfObject)
			if _dgdgf != nil {
				return _dgdgf
			}
		}
		return nil
	}
	if _efaec, _cbfb := _ebcfa.(*_fed.PdfObjectStream); _cbfb {
		_fef.Log.Trace("\u0053\u0074\u0072\u0065\u0061\u006d")
		_fef.Log.Trace("\u002d \u0025\u0073\u0020\u0025\u0070", _ebcfa, _ebcfa)
		if _adeaf.addObject(_efaec) {
			_baade := _adeaf.addObjects(_efaec.PdfObjectDictionary)
			if _baade != nil {
				return _baade
			}
		}
		return nil
	}
	if _dggbce, _agdbd := _ebcfa.(*_fed.PdfObjectDictionary); _agdbd {
		_fef.Log.Trace("\u0044\u0069\u0063\u0074")
		_fef.Log.Trace("\u002d\u0020\u0025\u0073", _ebcfa)
		for _, _edfb := range _dggbce.Keys() {
			_gbgc := _dggbce.Get(_edfb)
			if _cdfac, _bgce := _gbgc.(*_fed.PdfObjectReference); _bgce {
				_gbgc = _cdfac.Resolve()
				_dggbce.Set(_edfb, _gbgc)
			}
			if _edfb != "\u0050\u0061\u0072\u0065\u006e\u0074" {
				if _fddcc := _adeaf.addObjects(_gbgc); _fddcc != nil {
					return _fddcc
				}
			} else {
				if _, _fgeac := _gbgc.(*_fed.PdfObjectNull); _fgeac {
					continue
				}
				if _aeggb := _adeaf.hasObject(_gbgc); !_aeggb {
					_fef.Log.Debug("P\u0061\u0072\u0065\u006e\u0074\u0020o\u0062\u006a\u0020\u006e\u006f\u0074 \u0061\u0064\u0064\u0065\u0064\u0020\u0079e\u0074\u0021\u0021\u0020\u0025\u0054\u0020\u0025\u0070\u0020%\u0076", _gbgc, _gbgc, _gbgc)
					_adeaf._affff[_gbgc] = append(_adeaf._affff[_gbgc], _dggbce)
				}
			}
		}
		return nil
	}
	if _ecbf, _bfba := _ebcfa.(*_fed.PdfObjectArray); _bfba {
		_fef.Log.Trace("\u0041\u0072\u0072a\u0079")
		_fef.Log.Trace("\u002d\u0020\u0025\u0073", _ebcfa)
		if _ecbf == nil {
			return _bb.New("\u0061\u0072\u0072a\u0079\u0020\u0069\u0073\u0020\u006e\u0069\u006c")
		}
		for _fdgfa, _egadeg := range _ecbf.Elements() {
			if _fbbbb, _gdbbcc := _egadeg.(*_fed.PdfObjectReference); _gdbbcc {
				_egadeg = _fbbbb.Resolve()
				_ecbf.Set(_fdgfa, _egadeg)
			}
			if _cgbgf := _adeaf.addObjects(_egadeg); _cgbgf != nil {
				return _cgbgf
			}
		}
		return nil
	}
	if _, _adcbgc := _ebcfa.(*_fed.PdfObjectReference); _adcbgc {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0062\u0065\u0020\u0061\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u002d\u0020\u0067\u006f\u0074 \u0025\u0023\u0076\u0021", _ebcfa)
		return _bb.New("r\u0065\u0066\u0065\u0072en\u0063e\u0020\u006e\u006f\u0074\u0020a\u006c\u006c\u006f\u0077\u0065\u0064")
	}
	return nil
}
func (_fdbaaa *Image) samplesAddPadding(_gaae []uint32) []uint32 {
	_bfggf := _eede.BytesPerLine(int(_fdbaaa.Width), int(_fdbaaa.BitsPerComponent), _fdbaaa.ColorComponents) * (8 / int(_fdbaaa.BitsPerComponent))
	_cead := _bfggf * int(_fdbaaa.Height)
	if len(_gaae) == _cead {
		return _gaae
	}
	_bcdbe := make([]uint32, _cead)
	_acee := int(_fdbaaa.Width) * _fdbaaa.ColorComponents
	for _abaae := 0; _abaae < int(_fdbaaa.Height); _abaae++ {
		_feaed := _abaae * int(_fdbaaa.Width)
		_adcbb := _abaae * _bfggf
		for _eadce := 0; _eadce < _acee; _eadce++ {
			_bcdbe[_adcbb+_eadce] = _gaae[_feaed+_eadce]
		}
	}
	return _bcdbe
}

// AddContentStreamByString adds content stream by string. Puts the content
// string into a stream object and points the content stream towards it.
func (_fabad *PdfPage) AddContentStreamByString(contentStr string) error {
	_egcb, _fagde := _fed.MakeStream([]byte(contentStr), _fed.NewFlateEncoder())
	if _fagde != nil {
		return _fagde
	}
	if _fabad.Contents == nil {
		_fabad.Contents = _egcb
	} else {
		_cecda := _fed.TraceToDirectObject(_fabad.Contents)
		_addaa, _aeadac := _cecda.(*_fed.PdfObjectArray)
		if !_aeadac {
			_addaa = _fed.MakeArray(_cecda)
		}
		_addaa.Append(_egcb)
		_fabad.Contents = _addaa
	}
	return nil
}

// PdfAnnotationCaret represents Caret annotations.
// (Section 12.5.6.11).
type PdfAnnotationCaret struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	RD _fed.PdfObject
	Sy _fed.PdfObject
}

func _gbbe() string                                { _abadca.Lock(); defer _abadca.Unlock(); return _eeffe }
func (_faaf *PdfColorspaceCalGray) String() string { return "\u0043a\u006c\u0047\u0072\u0061\u0079" }

// IsColored specifies if the pattern is colored.
func (_gfcd *PdfTilingPattern) IsColored() bool {
	if _gfcd.PaintType != nil && *_gfcd.PaintType == 1 {
		return true
	}
	return false
}
func _fgdbf(_gedb _fed.PdfObject) (*PdfColorspaceCalGray, error) {
	_gded := NewPdfColorspaceCalGray()
	if _dbbcg, _affb := _gedb.(*_fed.PdfIndirectObject); _affb {
		_gded._cdab = _dbbcg
	}
	_gedb = _fed.TraceToDirectObject(_gedb)
	_fbfe, _edgg := _gedb.(*_fed.PdfObjectArray)
	if !_edgg {
		return nil, _d.Errorf("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _fbfe.Len() != 2 {
		return nil, _d.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0061\u006cG\u0072\u0061\u0079\u0020\u0063\u006f\u006c\u006f\u0072\u0073p\u0061\u0063\u0065")
	}
	_gedb = _fed.TraceToDirectObject(_fbfe.Get(0))
	_fabg, _edgg := _gedb.(*_fed.PdfObjectName)
	if !_edgg {
		return nil, _d.Errorf("\u0043\u0061\u006c\u0047\u0072\u0061\u0079\u0020\u006e\u0061m\u0065\u0020\u006e\u006f\u0074\u0020\u0061 \u004e\u0061\u006d\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
	}
	if *_fabg != "\u0043a\u006c\u0047\u0072\u0061\u0079" {
		return nil, _d.Errorf("\u006eo\u0074\u0020\u0061\u0020\u0043\u0061\u006c\u0047\u0072\u0061\u0079 \u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065")
	}
	_gedb = _fed.TraceToDirectObject(_fbfe.Get(1))
	_bfbb, _edgg := _gedb.(*_fed.PdfObjectDictionary)
	if !_edgg {
		return nil, _d.Errorf("\u0043\u0061lG\u0072\u0061\u0079 \u0064\u0069\u0063\u0074 no\u0074 a\u0020\u0044\u0069\u0063\u0074\u0069\u006fna\u0072\u0079\u0020\u006f\u0062\u006a\u0065c\u0074")
	}
	_gedb = _bfbb.Get("\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074")
	_gedb = _fed.TraceToDirectObject(_gedb)
	_acfd, _edgg := _gedb.(*_fed.PdfObjectArray)
	if !_edgg {
		return nil, _d.Errorf("C\u0061\u006c\u0047\u0072\u0061\u0079:\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020W\u0068\u0069\u0074e\u0050o\u0069\u006e\u0074")
	}
	if _acfd.Len() != 3 {
		return nil, _d.Errorf("\u0043\u0061\u006c\u0047\u0072\u0061y\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0068\u0069t\u0065\u0050\u006f\u0069\u006e\u0074\u0020a\u0072\u0072\u0061\u0079")
	}
	_ccbaf, _cgag := _acfd.GetAsFloat64Slice()
	if _cgag != nil {
		return nil, _cgag
	}
	_gded.WhitePoint = _ccbaf
	_gedb = _bfbb.Get("\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074")
	if _gedb != nil {
		_gedb = _fed.TraceToDirectObject(_gedb)
		_eefd, _bffec := _gedb.(*_fed.PdfObjectArray)
		if !_bffec {
			return nil, _d.Errorf("C\u0061\u006c\u0047\u0072\u0061\u0079:\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020B\u006c\u0061\u0063k\u0050o\u0069\u006e\u0074")
		}
		if _eefd.Len() != 3 {
			return nil, _d.Errorf("\u0043\u0061\u006c\u0047\u0072\u0061y\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u006c\u0061c\u006b\u0050\u006f\u0069\u006e\u0074\u0020a\u0072\u0072\u0061\u0079")
		}
		_bddbe, _efgea := _eefd.GetAsFloat64Slice()
		if _efgea != nil {
			return nil, _efgea
		}
		_gded.BlackPoint = _bddbe
	}
	_gedb = _bfbb.Get("\u0047\u0061\u006dm\u0061")
	if _gedb != nil {
		_gedb = _fed.TraceToDirectObject(_gedb)
		_fgdba, _fdebg := _fed.GetNumberAsFloat(_gedb)
		if _fdebg != nil {
			return nil, _d.Errorf("C\u0061\u006c\u0047\u0072\u0061\u0079:\u0020\u0067\u0061\u006d\u006d\u0061\u0020\u006e\u006ft\u0020\u0061\u0020n\u0075m\u0062\u0065\u0072")
		}
		_gded.Gamma = _fgdba
	}
	return _gded, nil
}

// NewPdfColorspaceDeviceRGB returns a new RGB colorspace object.
func NewPdfColorspaceDeviceRGB() *PdfColorspaceDeviceRGB { return &PdfColorspaceDeviceRGB{} }

// GetRuneMetrics returns the character metrics for the specified rune.
// A bool flag is returned to indicate whether or not the entry was found.
func (_dcff pdfCIDFontType0) GetRuneMetrics(r rune) (_geg.CharMetrics, bool) {
	return _geg.CharMetrics{Wx: _dcff._fabb}, true
}

// PdfActionURI represents an URI action.
type PdfActionURI struct {
	*PdfAction
	URI   _fed.PdfObject
	IsMap _fed.PdfObject
}

func (_caca *PdfReader) newPdfAnnotationMarkupFromDict(_aaf *_fed.PdfObjectDictionary) (*PdfAnnotationMarkup, error) {
	_adac := &PdfAnnotationMarkup{}
	if _fefd := _aaf.Get("\u0054"); _fefd != nil {
		_adac.T = _fefd
	}
	if _cca := _aaf.Get("\u0050\u006f\u0070u\u0070"); _cca != nil {
		_fcbf, _gdee := _cca.(*_fed.PdfIndirectObject)
		if !_gdee {
			if _, _gfeb := _cca.(*_fed.PdfObjectNull); !_gfeb {
				return nil, _bb.New("p\u006f\u0070\u0075\u0070\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0070\u006f\u0069\u006e\u0074\u0020t\u006f\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074")
			}
		} else {
			_efd, _cddc := _caca.newPdfAnnotationFromIndirectObject(_fcbf)
			if _cddc != nil {
				return nil, _cddc
			}
			if _efd != nil {
				_agae, _ggdg := _efd._adc.(*PdfAnnotationPopup)
				if !_ggdg {
					return nil, _bb.New("\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0072\u0065\u0066\u0065\u0072\u0072\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0020\u0070\u006f\u0070\u0075\u0070\u0020\u0061n\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e")
				}
				_adac.Popup = _agae
			}
		}
	}
	if _fdgg := _aaf.Get("\u0043\u0041"); _fdgg != nil {
		_adac.CA = _fdgg
	}
	if _fac := _aaf.Get("\u0052\u0043"); _fac != nil {
		_adac.RC = _fac
	}
	if _gdg := _aaf.Get("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065"); _gdg != nil {
		_adac.CreationDate = _gdg
	}
	if _bcgc := _aaf.Get("\u0049\u0052\u0054"); _bcgc != nil {
		_adac.IRT = _bcgc
	}
	if _ecff := _aaf.Get("\u0053\u0075\u0062\u006a"); _ecff != nil {
		_adac.Subj = _ecff
	}
	if _gaeg := _aaf.Get("\u0052\u0054"); _gaeg != nil {
		_adac.RT = _gaeg
	}
	if _ccg := _aaf.Get("\u0049\u0054"); _ccg != nil {
		_adac.IT = _ccg
	}
	if _cebb := _aaf.Get("\u0045\u0078\u0044\u0061\u0074\u0061"); _cebb != nil {
		_adac.ExData = _cebb
	}
	return _adac, nil
}
func (_fdb *PdfReader) newPdfActionTransFromDict(_deda *_fed.PdfObjectDictionary) (*PdfActionTrans, error) {
	return &PdfActionTrans{Trans: _deda.Get("\u0054\u0072\u0061n\u0073")}, nil
}

// PdfColorLab represents a color in the L*, a*, b* 3 component colorspace.
// Each component is defined in the range 0.0 - 1.0 where 1.0 is the primary intensity.
type PdfColorLab [3]float64

func (_gdf *PdfReader) newPdfActionImportDataFromDict(_gaaf *_fed.PdfObjectDictionary) (*PdfActionImportData, error) {
	_bfec, _fage := _eec(_gaaf.Get("\u0046"))
	if _fage != nil {
		return nil, _fage
	}
	return &PdfActionImportData{F: _bfec}, nil
}
func _geaac(_cbfc map[_geg.GID]int, _gfeae uint16) *_fed.PdfObjectArray {
	_ggdb := &_fed.PdfObjectArray{}
	_gggb := _geg.GID(_gfeae)
	for _daec := _geg.GID(0); _daec < _gggb; {
		_cgcg, _bffecg := _cbfc[_daec]
		if !_bffecg {
			_daec++
			continue
		}
		_cbdgg := _daec
		for _degb := _cbdgg + 1; _degb < _gggb; _degb++ {
			if _faed, _cgfaa := _cbfc[_degb]; !_cgfaa || _cgcg != _faed {
				break
			}
			_cbdgg = _degb
		}
		_ggdb.Append(_fed.MakeInteger(int64(_daec)))
		_ggdb.Append(_fed.MakeInteger(int64(_cbdgg)))
		_ggdb.Append(_fed.MakeInteger(int64(_cgcg)))
		_daec = _cbdgg + 1
	}
	return _ggdb
}

// Read reads an image and loads into a new Image object with an RGB
// colormap and 8 bits per component.
func (_aacg DefaultImageHandler) Read(reader _ge.Reader) (*Image, error) {
	_bcbf, _, _adce := _ee.Decode(reader)
	if _adce != nil {
		_fef.Log.Debug("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073", _adce)
		return nil, _adce
	}
	return _aacg.NewImageFromGoImage(_bcbf)
}

// B returns the value of the blue component of the color.
func (_faaa *PdfColorDeviceRGB) B() float64 { return _faaa[2] }

type fontCommon struct {
	_daac  string
	_afge  string
	_ceab  string
	_bbfbc _fed.PdfObject
	_ecfd  *_edf.CMap
	_bgdgb *PdfFontDescriptor
	_edfcd int64
}

// NewOutlineDest returns a new outline destination which can be used
// with outline items.
func NewOutlineDest(page int64, x, y float64) OutlineDest {
	return OutlineDest{Page: page, Mode: "\u0058\u0059\u005a", X: x, Y: y}
}

type pdfSignDictionary struct {
	*_fed.PdfObjectDictionary
	_gdgfa *SignatureHandler
	_agafa *PdfSignature
	_baaf  int64
	_becf  int
	_dgcbc int
	_acade int
	_aagf  int
}

// Image interface is a basic representation of an image used in PDF.
// The colorspace is not specified, but must be known when handling the image.
type Image struct {
	Width            int64
	Height           int64
	BitsPerComponent int64
	ColorComponents  int
	Data             []byte
	_caeaf           []byte
	_ccdge           []float64
}

// AddPages adds pages to be appended to the end of the source PDF.
func (_ageb *PdfAppender) AddPages(pages ...*PdfPage) {
	for _, _gecc := range pages {
		_gecc = _gecc.Duplicate()
		_daadc(_gecc)
		_ageb._dce = append(_ageb._dce, _gecc)
	}
}

// ToGray returns a PdfColorDeviceGray color based on the current RGB color.
func (_cfgf *PdfColorDeviceRGB) ToGray() *PdfColorDeviceGray {
	_babeg := 0.3*_cfgf.R() + 0.59*_cfgf.G() + 0.11*_cfgf.B()
	_babeg = _bg.Min(_bg.Max(_babeg, 0.0), 1.0)
	return NewPdfColorDeviceGray(_babeg)
}

// Has checks if flag fl is set in flag and returns true if so, false otherwise.
func (_gbabd FieldFlag) Has(fl FieldFlag) bool { return (_gbabd.Mask() & fl.Mask()) > 0 }
func _abba(_dfaf StdFontName) (pdfFontSimple, error) {
	_dbga, _cfae := _geg.NewStdFontByName(_dfaf)
	if !_cfae {
		return pdfFontSimple{}, ErrFontNotSupported
	}
	_fdfe := _edec(_dbga)
	return _fdfe, nil
}

// PdfBorderStyle represents a border style dictionary (12.5.4 Border Styles p. 394).
type PdfBorderStyle struct {
	W    *float64
	S    *BorderStyle
	D    *[]int
	_dfa _fed.PdfObject
}

// NewPdfActionJavaScript returns a new "javaScript" action.
func NewPdfActionJavaScript() *PdfActionJavaScript {
	_cdc := NewPdfAction()
	_ab := &PdfActionJavaScript{}
	_ab.PdfAction = _cdc
	_cdc.SetContext(_ab)
	return _ab
}

// AddImageResource adds an image to the XObject resources.
func (_dcdfag *PdfPage) AddImageResource(name _fed.PdfObjectName, ximg *XObjectImage) error {
	var _cgdec *_fed.PdfObjectDictionary
	if _dcdfag.Resources.XObject == nil {
		_cgdec = _fed.MakeDict()
		_dcdfag.Resources.XObject = _cgdec
	} else {
		var _adef bool
		_cgdec, _adef = (_dcdfag.Resources.XObject).(*_fed.PdfObjectDictionary)
		if !_adef {
			return _bb.New("\u0069\u006e\u0076\u0061li\u0064\u0020\u0078\u0072\u0065\u0073\u0020\u0064\u0069\u0063\u0074\u0020\u0074\u0079p\u0065")
		}
	}
	_cgdec.Set(name, ximg.ToPdfObject())
	return nil
}

// AcroFormRepairOptions contains options for rebuilding the AcroForm.
type AcroFormRepairOptions struct{}

// ToPdfObject implements interface PdfModel.
func (_dafc *PdfAnnotationSquare) ToPdfObject() _fed.PdfObject {
	_dafc.PdfAnnotation.ToPdfObject()
	_cafe := _dafc._ffaab
	_bgad := _cafe.PdfObject.(*_fed.PdfObjectDictionary)
	if _dafc.PdfAnnotationMarkup != nil {
		_dafc.PdfAnnotationMarkup.appendToPdfDictionary(_bgad)
	}
	_bgad.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u0053\u0071\u0075\u0061\u0072\u0065"))
	_bgad.SetIfNotNil("\u0042\u0053", _dafc.BS)
	_bgad.SetIfNotNil("\u0049\u0043", _dafc.IC)
	_bgad.SetIfNotNil("\u0042\u0045", _dafc.BE)
	_bgad.SetIfNotNil("\u0052\u0044", _dafc.RD)
	return _cafe
}

// ToPdfObject sets the common field elements.
// Note: Call the more field context's ToPdfObject to set both the generic and
// non-generic information.
func (_fafdg *PdfField) ToPdfObject() _fed.PdfObject {
	_dbge := _fafdg._cbaae
	_egeg := _dbge.PdfObject.(*_fed.PdfObjectDictionary)
	_aafg := _fed.MakeArray()
	for _, _aega := range _fafdg.Kids {
		_aafg.Append(_aega.ToPdfObject())
	}
	for _, _eggbb := range _fafdg.Annotations {
		if _eggbb._ffaab != _fafdg._cbaae {
			_aafg.Append(_eggbb.GetContext().ToPdfObject())
		}
	}
	if _fafdg.Parent != nil {
		_egeg.SetIfNotNil("\u0050\u0061\u0072\u0065\u006e\u0074", _fafdg.Parent.GetContainingPdfObject())
	}
	if _aafg.Len() > 0 {
		_egeg.Set("\u004b\u0069\u0064\u0073", _aafg)
	}
	_egeg.SetIfNotNil("\u0046\u0054", _fafdg.FT)
	_egeg.SetIfNotNil("\u0054", _fafdg.T)
	_egeg.SetIfNotNil("\u0054\u0055", _fafdg.TU)
	_egeg.SetIfNotNil("\u0054\u004d", _fafdg.TM)
	_egeg.SetIfNotNil("\u0046\u0066", _fafdg.Ff)
	_egeg.SetIfNotNil("\u0056", _fafdg.V)
	_egeg.SetIfNotNil("\u0044\u0056", _fafdg.DV)
	_egeg.SetIfNotNil("\u0041\u0041", _fafdg.AA)
	return _dbge
}
func (_gfg *PdfReader) newPdfAnnotationLinkFromDict(_cad *_fed.PdfObjectDictionary) (*PdfAnnotationLink, error) {
	_fcg := PdfAnnotationLink{}
	_fcg.A = _cad.Get("\u0041")
	_fcg.Dest = _cad.Get("\u0044\u0065\u0073\u0074")
	_fcg.H = _cad.Get("\u0048")
	_fcg.PA = _cad.Get("\u0050\u0041")
	_fcg.QuadPoints = _cad.Get("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073")
	_fcg.BS = _cad.Get("\u0042\u0053")
	return &_fcg, nil
}

// ToPdfObject converts rectangle to a PDF object.
func (_cbbd *PdfRectangle) ToPdfObject() _fed.PdfObject {
	return _fed.MakeArray(_fed.MakeFloat(_cbbd.Llx), _fed.MakeFloat(_cbbd.Lly), _fed.MakeFloat(_cbbd.Urx), _fed.MakeFloat(_cbbd.Ury))
}
func (_gbeca *LTV) getCerts(_debcee []*_fe.Certificate) ([][]byte, error) {
	_fdedb := make([][]byte, 0, len(_debcee))
	for _, _bbfdf := range _debcee {
		_fdedb = append(_fdedb, _bbfdf.Raw)
	}
	return _fdedb, nil
}

// ToPdfObject implements interface PdfModel.
func (_bede *PdfAnnotationSquiggly) ToPdfObject() _fed.PdfObject {
	_bede.PdfAnnotation.ToPdfObject()
	_bae := _bede._ffaab
	_cbfa := _bae.PdfObject.(*_fed.PdfObjectDictionary)
	_bede.PdfAnnotationMarkup.appendToPdfDictionary(_cbfa)
	_cbfa.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u0053\u0071\u0075\u0069\u0067\u0067\u006c\u0079"))
	_cbfa.SetIfNotNil("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073", _bede.QuadPoints)
	return _bae
}

// PdfColorDeviceRGB represents a color in DeviceRGB colorspace with R, G, B components, where component is
// defined in the range 0.0 - 1.0 where 1.0 is the primary intensity.
type PdfColorDeviceRGB [3]float64

func (_aegf *PdfReader) newPdfAnnotation3DFromDict(_cfbf *_fed.PdfObjectDictionary) (*PdfAnnotation3D, error) {
	_bbeg := PdfAnnotation3D{}
	_bbeg.T3DD = _cfbf.Get("\u0033\u0044\u0044")
	_bbeg.T3DV = _cfbf.Get("\u0033\u0044\u0056")
	_bbeg.T3DA = _cfbf.Get("\u0033\u0044\u0041")
	_bbeg.T3DI = _cfbf.Get("\u0033\u0044\u0049")
	_bbeg.T3DB = _cfbf.Get("\u0033\u0044\u0042")
	return &_bbeg, nil
}
func (_bgaaa *pdfFontType0) getFontDescriptor() *PdfFontDescriptor {
	if _bgaaa._bgdgb == nil && _bgaaa.DescendantFont != nil {
		return _bgaaa.DescendantFont.FontDescriptor()
	}
	return _bgaaa._bgdgb
}

// AddCustomInfo adds a custom info into document info dictionary.
func (_adbg *PdfInfo) AddCustomInfo(name string, value string) error {
	if _adbg._debc == nil {
		_adbg._debc = _fed.MakeDict()
	}
	if _, _gbca := _edfca[name]; _gbca {
		return _d.Errorf("\u0063\u0061\u006e\u006e\u006ft\u0020\u0075\u0073\u0065\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u0072\u0064 \u0069\u006e\u0066\u006f\u0020\u006b\u0065\u0079\u0020\u0025\u0073\u0020\u0061\u0073\u0020\u0063\u0075\u0073\u0074\u006f\u006d\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u006b\u0065y", name)
	}
	_adbg._debc.SetIfNotNil(*_fed.MakeName(name), _fed.MakeString(value))
	return nil
}

// ImageToRGB converts ICCBased colorspace image to RGB and returns the result.
func (_cecd *PdfColorspaceICCBased) ImageToRGB(img Image) (Image, error) {
	if _cecd.Alternate == nil {
		_fef.Log.Debug("I\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061lt\u0065\u0072\u006ea\u0074i\u0076\u0065")
		if _cecd.N == 1 {
			_fef.Log.Debug("\u0049\u0043\u0043\u0020\u0042a\u0073\u0065\u0064\u0020\u0063o\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061\u006c\u0074\u0065r\u006e\u0061\u0074\u0069\u0076\u0065\u0020\u002d\u0020\u0075\u0073\u0069\u006e\u0067\u0020\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061y\u0020\u0028\u004e\u003d\u0031\u0029")
			_bbcfg := NewPdfColorspaceDeviceGray()
			return _bbcfg.ImageToRGB(img)
		} else if _cecd.N == 3 {
			_fef.Log.Debug("\u0049\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070a\u0063\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0061\u006c\u0074\u0065\u0072\u006e\u0061\u0074\u0069\u0076\u0065\u0020\u002d\u0020\u0075\u0073\u0069\u006eg\u0020\u0044\u0065\u0076\u0069\u0063e\u0052\u0047B\u0020\u0028N\u003d3\u0029")
			return img, nil
		} else if _cecd.N == 4 {
			_fef.Log.Debug("\u0049\u0043\u0043\u0020\u0042a\u0073\u0065\u0064\u0020\u0063o\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061\u006c\u0074\u0065r\u006e\u0061\u0074\u0069\u0076\u0065\u0020\u002d\u0020\u0075\u0073\u0069\u006e\u0067\u0020\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059K\u0020\u0028\u004e\u003d\u0034\u0029")
			_efda := NewPdfColorspaceDeviceCMYK()
			return _efda.ImageToRGB(img)
		} else {
			return img, _bb.New("I\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061lt\u0065\u0072\u006ea\u0074i\u0076\u0065")
		}
	}
	_fef.Log.Trace("\u0049\u0043\u0043 \u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u0077\u0069\u0074\u0068\u0020\u0061\u006c\u0074\u0065\u0072\u006e\u0061t\u0069\u0076\u0065\u003a\u0020\u0025\u0023\u0076", _cecd)
	_ecfae, _dbdg := _cecd.Alternate.ImageToRGB(img)
	_fef.Log.Trace("I\u0043C\u0020\u0049\u006e\u0070\u0075\u0074\u0020\u0069m\u0061\u0067\u0065\u003a %\u002b\u0076", img)
	_fef.Log.Trace("I\u0043\u0043\u0020\u004fut\u0070u\u0074\u0020\u0069\u006d\u0061g\u0065\u003a\u0020\u0025\u002b\u0076", _ecfae)
	return _ecfae, _dbdg
}

// SetPageLabels sets the PageLabels entry in the PDF catalog.
// See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
func (_dcbddb *PdfWriter) SetPageLabels(pageLabels _fed.PdfObject) error {
	if pageLabels == nil {
		return nil
	}
	_fef.Log.Trace("\u0053\u0065t\u0074\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u0020\u0050\u0061\u0067\u0065\u004c\u0061\u0062\u0065\u006cs.\u002e\u002e")
	_dcbddb._cdefg.Set("\u0050\u0061\u0067\u0065\u004c\u0061\u0062\u0065\u006c\u0073", pageLabels)
	return _dcbddb.addObjects(pageLabels)
}

// A PdfPattern can represent a Pattern, either a tiling pattern or a shading pattern.
// Note that all patterns shall be treated as colours; a Pattern colour space shall be established with the CS or cs
// operator just like other colour spaces, and a particular pattern shall be installed as the current colour with the
// SCN or scn operator.
type PdfPattern struct {

	// Type: Pattern
	PatternType int64
	_ggadg      PdfModel
	_fbefb      _fed.PdfObject
}

// ToPdfObject returns the PDF representation of the DSS dictionary.
func (_fagd *DSS) ToPdfObject() _fed.PdfObject {
	_dfbea := _fagd._dcaa.PdfObject.(*_fed.PdfObjectDictionary)
	_dfbea.Clear()
	_ddbbf := _fed.MakeDict()
	for _cccdb, _eafe := range _fagd.VRI {
		_ddbbf.Set(*_fed.MakeName(_cccdb), _eafe.ToPdfObject())
	}
	_dfbea.SetIfNotNil("\u0043\u0065\u0072t\u0073", _ggfga(_fagd.Certs))
	_dfbea.SetIfNotNil("\u004f\u0043\u0053P\u0073", _ggfga(_fagd.OCSPs))
	_dfbea.SetIfNotNil("\u0043\u0052\u004c\u0073", _ggfga(_fagd.CRLs))
	_dfbea.Set("\u0056\u0052\u0049", _ddbbf)
	return _fagd._dcaa
}

// Items returns all children outline items.
func (_cegdg *OutlineItem) Items() []*OutlineItem { return _cegdg.Entries }

// GetPrimitiveFromModel returns the primitive object corresponding to the input `model`.
func (_bedb *modelManager) GetPrimitiveFromModel(model PdfModel) _fed.PdfObject {
	_fbega, _aacd := _bedb._efad[model]
	if !_aacd {
		return nil
	}
	return _fbega
}

// Evaluate runs the function. Input is [x1 x2 x3].
func (_ebfa *PdfFunctionType4) Evaluate(xVec []float64) ([]float64, error) {
	if _ebfa._dcga == nil {
		_ebfa._dcga = _ed.NewPSExecutor(_ebfa.Program)
	}
	var _ecbcc []_ed.PSObject
	for _, _dgcef := range xVec {
		_ecbcc = append(_ecbcc, _ed.MakeReal(_dgcef))
	}
	_adaga, _cfcbb := _ebfa._dcga.Execute(_ecbcc)
	if _cfcbb != nil {
		return nil, _cfcbb
	}
	_cfag, _cfcbb := _ed.PSObjectArrayToFloat64Array(_adaga)
	if _cfcbb != nil {
		return nil, _cfcbb
	}
	return _cfag, nil
}
func _ddbab(_eeaaa *_eede.ImageBase) (_cabg Image) {
	_cabg.Width = int64(_eeaaa.Width)
	_cabg.Height = int64(_eeaaa.Height)
	_cabg.BitsPerComponent = int64(_eeaaa.BitsPerComponent)
	_cabg.ColorComponents = _eeaaa.ColorComponents
	_cabg.Data = _eeaaa.Data
	_cabg._ccdge = _eeaaa.Decode
	_cabg._caeaf = _eeaaa.Alpha
	return _cabg
}
func (_fbde *PdfAnnotationMarkup) appendToPdfDictionary(_gbfd *_fed.PdfObjectDictionary) {
	_gbfd.SetIfNotNil("\u0054", _fbde.T)
	if _fbde.Popup != nil {
		_gbfd.Set("\u0050\u006f\u0070u\u0070", _fbde.Popup.ToPdfObject())
	}
	_gbfd.SetIfNotNil("\u0043\u0041", _fbde.CA)
	_gbfd.SetIfNotNil("\u0052\u0043", _fbde.RC)
	_gbfd.SetIfNotNil("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065", _fbde.CreationDate)
	_gbfd.SetIfNotNil("\u0049\u0052\u0054", _fbde.IRT)
	_gbfd.SetIfNotNil("\u0053\u0075\u0062\u006a", _fbde.Subj)
	_gbfd.SetIfNotNil("\u0052\u0054", _fbde.RT)
	_gbfd.SetIfNotNil("\u0049\u0054", _fbde.IT)
	_gbfd.SetIfNotNil("\u0045\u0078\u0044\u0061\u0074\u0061", _fbde.ExData)
}

// Mask returns the uin32 bitmask for the specific flag.
func (_dgbag FieldFlag) Mask() uint32 { return uint32(_dgbag) }

// GetContentStreamWithEncoder returns the pattern cell's content stream and its encoder
func (_agcaa *PdfTilingPattern) GetContentStreamWithEncoder() ([]byte, _fed.StreamEncoder, error) {
	_beef, _cedbeb := _agcaa._fbefb.(*_fed.PdfObjectStream)
	if !_cedbeb {
		_fef.Log.Debug("\u0054\u0069l\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _agcaa._fbefb)
		return nil, nil, _fed.ErrTypeError
	}
	_abfda, _eebg := _fed.DecodeStream(_beef)
	if _eebg != nil {
		_fef.Log.Debug("\u0046\u0061\u0069l\u0065\u0064\u0020\u0064e\u0063\u006f\u0064\u0069\u006e\u0067\u0020s\u0074\u0072\u0065\u0061\u006d\u002c\u0020\u0065\u0072\u0072\u003a\u0020\u0025\u0076", _eebg)
		return nil, nil, _eebg
	}
	_fggf, _eebg := _fed.NewEncoderFromStream(_beef)
	if _eebg != nil {
		_fef.Log.Debug("F\u0061\u0069\u006c\u0065\u0064\u0020f\u0069\u006e\u0064\u0069\u006e\u0067 \u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0065\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020%\u0076", _eebg)
		return nil, nil, _eebg
	}
	return _abfda, _fggf, nil
}

// SetAlpha sets the alpha layer for the image.
func (_aebc *Image) SetAlpha(alpha []byte) { _aebc._caeaf = alpha }

// MergePageWith appends page content to source Pdf file page content.
func (_bdgd *PdfAppender) MergePageWith(pageNum int, page *PdfPage) error {
	_ggbd := pageNum - 1
	var _adbf *PdfPage
	for _ecbe, _add := range _bdgd._dce {
		if _ecbe == _ggbd {
			_adbf = _add
		}
	}
	if _adbf == nil {
		return _d.Errorf("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067\u0065\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079\u0020\u0025\u0064\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064\u0020\u0069\u006e\u0020\u0074\u0068\u0065\u0020\u0073o\u0075\u0072\u0063\u0065\u0020\u0064o\u0063\u0075\u006de\u006e\u0074", pageNum)
	}
	if _adbf._efbb != nil && _adbf._efbb.GetParser() == _bdgd._ccc._cdfggf {
		_adbf = _adbf.Duplicate()
		_bdgd._dce[_ggbd] = _adbf
	}
	page = page.Duplicate()
	_daadc(page)
	_gafa := _bbbce(_adbf)
	_ggae := _bbbce(page)
	_cgcbdc := make(map[_fed.PdfObjectName]_fed.PdfObjectName)
	for _bgge := range _ggae {
		if _, _eef := _gafa[_bgge]; _eef {
			for _bgdg := 1; true; _bgdg++ {
				_gad := _fed.PdfObjectName(string(_bgge) + _ba.Itoa(_bgdg))
				if _, _gaegb := _gafa[_gad]; !_gaegb {
					_cgcbdc[_bgge] = _gad
					break
				}
			}
		}
	}
	_efgec, _dace := page.GetContentStreams()
	if _dace != nil {
		return _dace
	}
	_fgda, _dace := _adbf.GetContentStreams()
	if _dace != nil {
		return _dace
	}
	for _ccedd, _ggbf := range _efgec {
		for _cgddc, _gcea := range _cgcbdc {
			_ggbf = _eed.Replace(_ggbf, "\u002f"+string(_cgddc), "\u002f"+string(_gcea), -1)
		}
		_efgec[_ccedd] = _ggbf
	}
	_fgda = append(_fgda, _efgec...)
	if _dfcf := _adbf.SetContentStreams(_fgda, _fed.NewFlateEncoder()); _dfcf != nil {
		return _dfcf
	}
	_adbf._abcb = append(_adbf._abcb, page._abcb...)
	if _adbf.Resources == nil {
		_adbf.Resources = NewPdfPageResources()
	}
	if page.Resources != nil {
		_adbf.Resources.Font = _bdgd.mergeResources(_adbf.Resources.Font, page.Resources.Font, _cgcbdc)
		_adbf.Resources.XObject = _bdgd.mergeResources(_adbf.Resources.XObject, page.Resources.XObject, _cgcbdc)
		_adbf.Resources.Properties = _bdgd.mergeResources(_adbf.Resources.Properties, page.Resources.Properties, _cgcbdc)
		if _adbf.Resources.ProcSet == nil {
			_adbf.Resources.ProcSet = page.Resources.ProcSet
		}
		_adbf.Resources.Shading = _bdgd.mergeResources(_adbf.Resources.Shading, page.Resources.Shading, _cgcbdc)
		_adbf.Resources.ExtGState = _bdgd.mergeResources(_adbf.Resources.ExtGState, page.Resources.ExtGState, _cgcbdc)
	}
	_edd, _dace := _adbf.GetMediaBox()
	if _dace != nil {
		return _dace
	}
	_fcaf, _dace := page.GetMediaBox()
	if _dace != nil {
		return _dace
	}
	var _afcc bool
	if _edd.Llx > _fcaf.Llx {
		_edd.Llx = _fcaf.Llx
		_afcc = true
	}
	if _edd.Lly > _fcaf.Lly {
		_edd.Lly = _fcaf.Lly
		_afcc = true
	}
	if _edd.Urx < _fcaf.Urx {
		_edd.Urx = _fcaf.Urx
		_afcc = true
	}
	if _edd.Ury < _fcaf.Ury {
		_edd.Ury = _fcaf.Ury
		_afcc = true
	}
	if _afcc {
		_adbf.MediaBox = _edd
	}
	return nil
}

// ToWriter creates a new writer from the current reader, based on the specified options.
// If no options are provided, all reader properties are copied to the writer.
func (_bcedc *PdfReader) ToWriter(opts *ReaderToWriterOpts) (*PdfWriter, error) {
	_deef := NewPdfWriter()
	if opts == nil {
		opts = &ReaderToWriterOpts{}
	}
	_bbbga, _agafb := _bcedc.GetNumPages()
	if _agafb != nil {
		_fef.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _agafb)
		return nil, _agafb
	}
	for _eaebc := 1; _eaebc <= _bbbga; _eaebc++ {
		_bfgca, _adgfd := _bcedc.GetPage(_eaebc)
		if _adgfd != nil {
			_fef.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _adgfd)
			return nil, _adgfd
		}
		if opts.PageProcessCallback != nil {
			_adgfd = opts.PageProcessCallback(_eaebc, _bfgca)
			if _adgfd != nil {
				_fef.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _adgfd)
				return nil, _adgfd
			}
		} else if opts.PageCallback != nil {
			opts.PageCallback(_eaebc, _bfgca)
		}
		_adgfd = _deef.AddPage(_bfgca)
		if _adgfd != nil {
			_fef.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _adgfd)
			return nil, _adgfd
		}
	}
	_deef._gbgag = _bcedc.PdfVersion().Major
	_deef._cccf = _bcedc.PdfVersion().Minor
	if !opts.SkipInfo {
		_baac, _bddgg := _bcedc.GetPdfInfo()
		if _bddgg != nil {
			_fef.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _bddgg)
		} else {
			_deef._egbgf.PdfObject = _baac.ToPdfObject()
		}
	}
	if !opts.SkipAcroForm {
		_agefda := _deef.SetForms(_bcedc.AcroForm)
		if _agefda != nil {
			_fef.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _agefda)
			return nil, _agefda
		}
	}
	if !opts.SkipOutlines {
		_deef.AddOutlineTree(_bcedc.GetOutlineTree())
	}
	if !opts.SkipOCProperties {
		_geeff, _gced := _bcedc.GetOCProperties()
		if _gced != nil {
			_fef.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _gced)
		} else {
			_gced = _deef.SetOCProperties(_geeff)
			if _gced != nil {
				_fef.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _gced)
			}
		}
	}
	if !opts.SkipPageLabels {
		_dcfg, _cecdg := _bcedc.GetPageLabels()
		if _cecdg != nil {
			_fef.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _cecdg)
		} else {
			_cecdg = _deef.SetPageLabels(_dcfg)
			if _cecdg != nil {
				_fef.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _cecdg)
			}
		}
	}
	if !opts.SkipNamedDests {
		_ggbgc, _bedab := _bcedc.GetNamedDestinations()
		if _bedab != nil {
			_fef.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _bedab)
		} else {
			_bedab = _deef.SetNamedDestinations(_ggbgc)
			if _bedab != nil {
				_fef.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _bedab)
			}
		}
	}
	if !opts.SkipNameDictionary {
		_fggg, _eaaa := _bcedc.GetNameDictionary()
		if _eaaa != nil {
			_fef.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _eaaa)
		} else {
			_eaaa = _deef.SetNameDictionary(_fggg)
			if _eaaa != nil {
				_fef.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _eaaa)
			}
		}
	}
	if !opts.SkipRotation && _bcedc.Rotate != nil {
		if _edcaf := _deef.SetRotation(*_bcedc.Rotate); _edcaf != nil {
			_fef.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _edcaf)
		}
	}
	return &_deef, nil
}

// NewReaderForText makes a new PdfReader for an input PDF content string. For use in testing.
func NewReaderForText(txt string) *PdfReader {
	return &PdfReader{_aaebc: map[_fed.PdfObject]struct{}{}, _dcfcd: _bdgb(), _cdfggf: _fed.NewParserFromString(txt)}
}

// NewPdfColorspaceCalRGB returns a new CalRGB colorspace object.
func NewPdfColorspaceCalRGB() *PdfColorspaceCalRGB {
	_dbag := &PdfColorspaceCalRGB{}
	_dbag.BlackPoint = []float64{0.0, 0.0, 0.0}
	_dbag.Gamma = []float64{1.0, 1.0, 1.0}
	_dbag.Matrix = []float64{1, 0, 0, 0, 1, 0, 0, 0, 1}
	return _dbag
}

// NewPdfColorCalGray returns a new CalGray color.
func NewPdfColorCalGray(grayVal float64) *PdfColorCalGray {
	_cfda := PdfColorCalGray(grayVal)
	return &_cfda
}
func (_cgeaf *LTV) enable(_ccae, _beded []*_fe.Certificate, _geefe string) error {
	_effeae, _eccdg, _cafag := _cgeaf.buildCertChain(_ccae, _beded)
	if _cafag != nil {
		return _cafag
	}
	_bbdg, _cafag := _cgeaf.getCerts(_effeae)
	if _cafag != nil {
		return _cafag
	}
	_cgcd, _cafag := _cgeaf.getOCSPs(_effeae, _eccdg)
	if _cafag != nil {
		return _cafag
	}
	_afgf, _cafag := _cgeaf.getCRLs(_effeae)
	if _cafag != nil {
		return _cafag
	}
	_dggbc := _cgeaf._aageb
	_fgde, _cafag := _dggbc.addCerts(_bbdg)
	if _cafag != nil {
		return _cafag
	}
	_gcba, _cafag := _dggbc.addOCSPs(_cgcd)
	if _cafag != nil {
		return _cafag
	}
	_fcegg, _cafag := _dggbc.addCRLs(_afgf)
	if _cafag != nil {
		return _cafag
	}
	if _geefe != "" {
		_dggbc.VRI[_geefe] = &VRI{Cert: _fgde, OCSP: _gcba, CRL: _fcegg}
	}
	_cgeaf._cgbeg.SetDSS(_dggbc)
	return nil
}

// GetContainingPdfObject returns the container of the outline item (indirect object).
func (_fafe *PdfOutlineItem) GetContainingPdfObject() _fed.PdfObject { return _fafe._gafcc }

var _cefe = map[string]struct{}{"\u0046\u0054": {}, "\u004b\u0069\u0064\u0073": {}, "\u0054": {}, "\u0054\u0055": {}, "\u0054\u004d": {}, "\u0046\u0066": {}, "\u0056": {}, "\u0044\u0056": {}, "\u0041\u0041": {}, "\u0044\u0041": {}, "\u0051": {}, "\u0044\u0053": {}, "\u0052\u0056": {}}

func (_ggab *fontFile) parseASCIIPart(_fbggb []byte) error {
	if len(_fbggb) < 2 || string(_fbggb[:2]) != "\u0025\u0021" {
		return _bb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0074a\u0072\u0074\u0020\u006f\u0066\u0020\u0041S\u0043\u0049\u0049\u0020\u0073\u0065\u0067\u006d\u0065\u006e\u0074")
	}
	_becd, _bbeeef, _cagagb := _baca(_fbggb)
	if _cagagb != nil {
		return _cagagb
	}
	_fcge := _aagd(_becd)
	_ggab._gaag = _fcge["\u0046\u006f\u006e\u0074\u004e\u0061\u006d\u0065"]
	if _ggab._gaag == "" {
		_fef.Log.Debug("\u0020\u0046\u006f\u006e\u0074\u0046\u0069\u006c\u0065\u0020\u0068a\u0073\u0020\u006e\u006f\u0020\u002f\u0046\u006f\u006e\u0074N\u0061\u006d\u0065")
	}
	if _bbeeef != "" {
		_cdcg, _dedad := _bcba(_bbeeef)
		if _dedad != nil {
			return _dedad
		}
		_aggf, _dedad := _dg.NewCustomSimpleTextEncoder(_cdcg, nil)
		if _dedad != nil {
			_fef.Log.Debug("\u0045\u0052\u0052\u004fR\u0020\u003a\u0055\u004e\u004b\u004e\u004f\u0057\u004e\u0020G\u004cY\u0050\u0048\u003a\u0020\u0065\u0072\u0072=\u0025\u0076", _dedad)
			return nil
		}
		_ggab._dddff = _aggf
	}
	return nil
}
func (_dee *PdfReader) newPdfAnnotationSquigglyFromDict(_cfaa *_fed.PdfObjectDictionary) (*PdfAnnotationSquiggly, error) {
	_fgg := PdfAnnotationSquiggly{}
	_cae, _gfbb := _dee.newPdfAnnotationMarkupFromDict(_cfaa)
	if _gfbb != nil {
		return nil, _gfbb
	}
	_fgg.PdfAnnotationMarkup = _cae
	_fgg.QuadPoints = _cfaa.Get("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073")
	return &_fgg, nil
}
func _faab(_eafea _fed.PdfObject, _aafa bool) (*PdfFont, error) {
	_bfgcb, _dada, _dfggg := _cebbd(_eafea)
	if _dfggg != nil {
		if _dfggg == ErrType1CFontNotSupported {
			_dfgf, _bagb := _cabef(_bfgcb, _dada, nil)
			if _bagb != nil {
				_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0057h\u0069\u006c\u0065 l\u006f\u0061\u0064\u0069\u006e\u0067 \u0073\u0069\u006d\u0070\u006c\u0065\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0066\u006fn\u0074\u003d\u0025\u0073\u0020\u0065\u0072\u0072=\u0025\u0076", _dada, _bagb)
				return nil, _dfggg
			}
			return &PdfFont{_gdaa: _dfgf}, _dfggg
		}
		return nil, _dfggg
	}
	_adcga := &PdfFont{}
	switch _dada._afge {
	case "\u0054\u0079\u0070e\u0030":
		if !_aafa {
			_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u004c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0079\u0070\u00650\u0020\u006e\u006f\u0074\u0020\u0061\u006c\u006c\u006f\u0077\u0065\u0064\u002e\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _dada)
			return nil, _bb.New("\u0063\u0079\u0063\u006cic\u0061\u006c\u0020\u0074\u0079\u0070\u0065\u0030\u0020\u006c\u006f\u0061\u0064\u0069n\u0067")
		}
		_ggef, _acbdb := _gcfc(_bfgcb, _dada)
		if _acbdb != nil {
			_fef.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020\u0057\u0068\u0069l\u0065\u0020\u006c\u006f\u0061\u0064\u0069ng\u0020\u0054\u0079\u0070e\u0030\u0020\u0066\u006f\u006e\u0074\u002e\u0020\u0066on\u0074\u003d%\u0073\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _dada, _acbdb)
			return nil, _acbdb
		}
		_adcga._gdaa = _ggef
	case "\u0054\u0079\u0070e\u0031", "\u004dM\u0054\u0079\u0070\u0065\u0031", "\u0054\u0072\u0075\u0065\u0054\u0079\u0070\u0065":
		var _dfdf *pdfFontSimple
		_defg, _bdgdb := _geg.NewStdFontByName(_geg.StdFontName(_dada._daac))
		if _bdgdb {
			_fcdab := _edec(_defg)
			_adcga._gdaa = &_fcdab
			_ecdb := _fed.TraceToDirectObject(_fcdab.ToPdfObject())
			_eccgd, _ggce, _cfbbd := _cebbd(_ecdb)
			if _cfbbd != nil {
				_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0042\u0061\u0064\u0020\u0053\u0074a\u006e\u0064\u0061\u0072\u0064\u00314\u000a\u0009\u0066\u006f\u006e\u0074\u003d\u0025\u0073\u000a\u0009\u0073\u0074d\u003d\u0025\u002b\u0076", _dada, _fcdab)
				return nil, _cfbbd
			}
			for _, _debb := range _bfgcb.Keys() {
				_eccgd.Set(_debb, _bfgcb.Get(_debb))
			}
			_dfdf, _cfbbd = _cabef(_eccgd, _ggce, _fcdab._cffd)
			if _cfbbd != nil {
				_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0042\u0061\u0064\u0020\u0053\u0074a\u006e\u0064\u0061\u0072\u0064\u00314\u000a\u0009\u0066\u006f\u006e\u0074\u003d\u0025\u0073\u000a\u0009\u0073\u0074d\u003d\u0025\u002b\u0076", _dada, _fcdab)
				return nil, _cfbbd
			}
			_dfdf._dadc = _fcdab._dadc
			_dfdf._abef = _fcdab._abef
		} else {
			_dfdf, _dfggg = _cabef(_bfgcb, _dada, nil)
			if _dfggg != nil {
				_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0057h\u0069\u006c\u0065 l\u006f\u0061\u0064\u0069\u006e\u0067 \u0073\u0069\u006d\u0070\u006c\u0065\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0066\u006fn\u0074\u003d\u0025\u0073\u0020\u0065\u0072\u0072=\u0025\u0076", _dada, _dfggg)
				return nil, _dfggg
			}
		}
		_dfggg = _dfdf.addEncoding()
		if _dfggg != nil {
			return nil, _dfggg
		}
		if _bdgdb {
			_dfdf.updateStandard14Font()
		}
		if _bdgdb && _dfdf._ebcbf == nil && _dfdf._cffd == nil {
			_fef.Log.Error("\u0073\u0069\u006d\u0070\u006c\u0065\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _dfdf)
			_fef.Log.Error("\u0066n\u0074\u003d\u0025\u002b\u0076", _defg)
		}
		if len(_dfdf._dadc) == 0 {
			_fef.Log.Debug("\u0045R\u0052\u004f\u0052\u003a \u004e\u006f\u0020\u0077\u0069d\u0074h\u0073.\u0020\u0066\u006f\u006e\u0074\u003d\u0025s", _dfdf)
		}
		_adcga._gdaa = _dfdf
	case "\u0054\u0079\u0070e\u0033":
		_fgdg, _ggdf := _febfa(_bfgcb, _dada)
		if _ggdf != nil {
			_fef.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020W\u0068\u0069\u006c\u0065\u0020\u006co\u0061\u0064\u0069\u006e\u0067\u0020\u0074y\u0070\u0065\u0033\u0020\u0066\u006f\u006e\u0074\u003a\u0020%\u0076", _ggdf)
			return nil, _ggdf
		}
		_adcga._gdaa = _fgdg
	case "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0030":
		_fbeb, _afag := _dgfdb(_bfgcb, _dada)
		if _afag != nil {
			_fef.Log.Debug("\u0045R\u0052\u004fR\u003a\u0020\u0057\u0068i\u006c\u0065\u0020l\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0063\u0069d \u0066\u006f\u006et\u0020\u0074y\u0070\u0065\u0030\u0020\u0066\u006fn\u0074\u003a \u0025\u0076", _afag)
			return nil, _afag
		}
		_adcga._gdaa = _fbeb
	case "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0032":
		_edcg, _gfcfa := _effa(_bfgcb, _dada)
		if _gfcfa != nil {
			_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0057\u0068\u0069l\u0065\u0020\u006co\u0061\u0064\u0069\u006e\u0067\u0020\u0063\u0069\u0064\u0020f\u006f\u006e\u0074\u0020\u0074yp\u0065\u0032\u0020\u0066\u006f\u006e\u0074\u002e\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073\u0020\u0065\u0072\u0072\u003d\u0025\u0076", _dada, _gfcfa)
			return nil, _gfcfa
		}
		_adcga._gdaa = _edcg
	default:
		_fef.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020U\u006e\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020f\u006f\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0066\u006fn\u0074\u003d\u0025\u0073", _dada)
		return nil, _d.Errorf("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0066\u006f\u006e\u0074\u0020\u0074y\u0070\u0065\u003a\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _dada)
	}
	return _adcga, nil
}

// NewPdfActionSubmitForm returns a new "submit form" action.
func NewPdfActionSubmitForm() *PdfActionSubmitForm {
	_dbfe := NewPdfAction()
	_adg := &PdfActionSubmitForm{}
	_adg.PdfAction = _dbfe
	_dbfe.SetContext(_adg)
	return _adg
}

// GetContainingPdfObject returns the container of the outline (indirect object).
func (_cbbed *PdfOutline) GetContainingPdfObject() _fed.PdfObject { return _cbbed._cbad }

// ToPdfObject recursively builds the Outline tree PDF object.
func (_cgggg *PdfOutlineItem) ToPdfObject() _fed.PdfObject {
	_caeeea := _cgggg._gafcc
	_debe := _caeeea.PdfObject.(*_fed.PdfObjectDictionary)
	_debe.Set("\u0054\u0069\u0074l\u0065", _cgggg.Title)
	if _cgggg.A != nil {
		_debe.Set("\u0041", _cgggg.A)
	}
	if _eaadg := _debe.Get("\u0053\u0045"); _eaadg != nil {
		_debe.Remove("\u0053\u0045")
	}
	if _cgggg.C != nil {
		_debe.Set("\u0043", _cgggg.C)
	}
	if _cgggg.Dest != nil {
		_debe.Set("\u0044\u0065\u0073\u0074", _cgggg.Dest)
	}
	if _cgggg.F != nil {
		_debe.Set("\u0046", _cgggg.F)
	}
	if _cgggg.Count != nil {
		_debe.Set("\u0043\u006f\u0075n\u0074", _fed.MakeInteger(*_cgggg.Count))
	}
	if _cgggg.Next != nil {
		_debe.Set("\u004e\u0065\u0078\u0074", _cgggg.Next.ToPdfObject())
	}
	if _cgggg.First != nil {
		_debe.Set("\u0046\u0069\u0072s\u0074", _cgggg.First.ToPdfObject())
	}
	if _cgggg.Prev != nil {
		_debe.Set("\u0050\u0072\u0065\u0076", _cgggg.Prev.GetContext().GetContainingPdfObject())
	}
	if _cgggg.Last != nil {
		_debe.Set("\u004c\u0061\u0073\u0074", _cgggg.Last.GetContext().GetContainingPdfObject())
	}
	if _cgggg.Parent != nil {
		_debe.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _cgggg.Parent.GetContext().GetContainingPdfObject())
	}
	return _caeeea
}

// Insert adds a top level outline item in the outline,
// at the specified index.
func (_bdca *Outline) Insert(index uint, item *OutlineItem) {
	_fgdfc := uint(len(_bdca.Entries))
	if index > _fgdfc {
		index = _fgdfc
	}
	_bdca.Entries = append(_bdca.Entries[:index], append([]*OutlineItem{item}, _bdca.Entries[index:]...)...)
}

// GetEncryptionMethod returns a descriptive information string about the encryption method used.
func (_dfddd *PdfReader) GetEncryptionMethod() string {
	_fgfe := _dfddd._cdfggf.GetCrypter()
	return _fgfe.String()
}
func _effa(_gadcd *_fed.PdfObjectDictionary, _bfdd *fontCommon) (*pdfCIDFontType2, error) {
	if _bfdd._afge != "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0032" {
		_fef.Log.Debug("\u0045R\u0052\u004fR\u003a\u0020\u0046\u006fn\u0074\u0020\u0053u\u0062\u0054\u0079\u0070\u0065\u0020\u0021\u003d\u0020CI\u0044\u0046\u006fn\u0074\u0054y\u0070\u0065\u0032\u002e\u0020\u0066o\u006e\u0074=\u0025\u0073", _bfdd)
		return nil, _fed.ErrRangeError
	}
	_fdfc := _aedaf(_bfdd)
	_becgd, _ebgeb := _fed.GetDict(_gadcd.Get("\u0043\u0049\u0044\u0053\u0079\u0073\u0074\u0065\u006d\u0049\u006e\u0066\u006f"))
	if !_ebgeb {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043I\u0044\u0053\u0079st\u0065\u006d\u0049\u006e\u0066\u006f \u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029\u0020\u006d\u0069\u0073\u0073i\u006e\u0067\u002e\u0020\u0066\u006f\u006e\u0074=\u0025\u0073", _bfdd)
		return nil, ErrRequiredAttributeMissing
	}
	_fdfc.CIDSystemInfo = _becgd
	_fdfc.DW = _gadcd.Get("\u0044\u0057")
	_fdfc.W = _gadcd.Get("\u0057")
	_fdfc.DW2 = _gadcd.Get("\u0044\u0057\u0032")
	_fdfc.W2 = _gadcd.Get("\u0057\u0032")
	_fdfc.CIDToGIDMap = _gadcd.Get("C\u0049\u0044\u0054\u006f\u0047\u0049\u0044\u004d\u0061\u0070")
	_fdfc._bcedd = 1000.0
	if _geee, _aacba := _fed.GetNumberAsFloat(_fdfc.DW); _aacba == nil {
		_fdfc._bcedd = _geee
	}
	_dbaa, _bcge := _bfag(_fdfc.W)
	if _bcge != nil {
		return nil, _bcge
	}
	if _dbaa == nil {
		_dbaa = map[_dg.CharCode]float64{}
	}
	_fdfc._faabg = _dbaa
	return _fdfc, nil
}

// DecodeArray returns the component range values for the Indexed colorspace.
func (_fdad *PdfColorspaceSpecialIndexed) DecodeArray() []float64 {
	return []float64{0, float64(_fdad.HiVal)}
}
func _bcegf(_daed *_fed.PdfObjectDictionary) bool {
	for _, _afab := range _daed.Keys() {
		if _, _aebb := _cefe[_afab.String()]; _aebb {
			return true
		}
	}
	return false
}

// HasFontByName checks if has font resource by name.
func (_agaf *PdfPage) HasFontByName(name _fed.PdfObjectName) bool {
	_befdd, _bfcfb := _agaf.Resources.Font.(*_fed.PdfObjectDictionary)
	if !_bfcfb {
		return false
	}
	if _debad := _befdd.Get(name); _debad != nil {
		return true
	}
	return false
}

// NewPdfActionGoToR returns a new "go to remote" action.
func NewPdfActionGoToR() *PdfActionGoToR {
	_dbf := NewPdfAction()
	_fcf := &PdfActionGoToR{}
	_fcf.PdfAction = _dbf
	_dbf.SetContext(_fcf)
	return _fcf
}
func (_afa *PdfReader) newPdfAnnotationSoundFromDict(_bbef *_fed.PdfObjectDictionary) (*PdfAnnotationSound, error) {
	_aeb := PdfAnnotationSound{}
	_dbeb, _bcbb := _afa.newPdfAnnotationMarkupFromDict(_bbef)
	if _bcbb != nil {
		return nil, _bcbb
	}
	_aeb.PdfAnnotationMarkup = _dbeb
	_aeb.Name = _bbef.Get("\u004e\u0061\u006d\u0065")
	_aeb.Sound = _bbef.Get("\u0053\u006f\u0075n\u0064")
	return &_aeb, nil
}

// ToPdfObject returns a *PdfIndirectObject containing a *PdfObjectArray representation of the DeviceN colorspace.
// Format: [/DeviceN names alternateSpace tintTransform]
//     or: [/DeviceN names alternateSpace tintTransform attributes]
func (_affe *PdfColorspaceDeviceN) ToPdfObject() _fed.PdfObject {
	_bdcb := _fed.MakeArray(_fed.MakeName("\u0044e\u0076\u0069\u0063\u0065\u004e"))
	_bdcb.Append(_affe.ColorantNames)
	_bdcb.Append(_affe.AlternateSpace.ToPdfObject())
	_bdcb.Append(_affe.TintTransform.ToPdfObject())
	if _affe.Attributes != nil {
		_bdcb.Append(_affe.Attributes.ToPdfObject())
	}
	if _affe._dfgaa != nil {
		_affe._dfgaa.PdfObject = _bdcb
		return _affe._dfgaa
	}
	return _bdcb
}
func (_gbeb *PdfReader) newPdfAnnotationUnderlineFromDict(_cced *_fed.PdfObjectDictionary) (*PdfAnnotationUnderline, error) {
	_ffabb := PdfAnnotationUnderline{}
	_cffb, _afga := _gbeb.newPdfAnnotationMarkupFromDict(_cced)
	if _afga != nil {
		return nil, _afga
	}
	_ffabb.PdfAnnotationMarkup = _cffb
	_ffabb.QuadPoints = _cced.Get("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073")
	return &_ffabb, nil
}

const (
	RC4_128bit = EncryptionAlgorithm(iota)
	AES_128bit
	AES_256bit
)

// NewOutline returns a new outline instance.
func NewOutline() *Outline { return &Outline{} }

// NewXObjectImageFromStream builds the image xobject from a stream object.
// An image dictionary is the dictionary portion of a stream object representing an image XObject.
func NewXObjectImageFromStream(stream *_fed.PdfObjectStream) (*XObjectImage, error) {
	_cgbce := &XObjectImage{}
	_cgbce._agffg = stream
	_geeed := *(stream.PdfObjectDictionary)
	_ddbea, _bfga := _fed.NewEncoderFromStream(stream)
	if _bfga != nil {
		return nil, _bfga
	}
	_cgbce.Filter = _ddbea
	if _ccgg := _fed.TraceToDirectObject(_geeed.Get("\u0057\u0069\u0064t\u0068")); _ccgg != nil {
		_bfbbb, _adagb := _ccgg.(*_fed.PdfObjectInteger)
		if !_adagb {
			return nil, _bb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006d\u0061g\u0065\u0020\u0077\u0069\u0064\u0074\u0068\u0020\u006f\u0062j\u0065\u0063\u0074")
		}
		_cecfd := int64(*_bfbbb)
		_cgbce.Width = &_cecfd
	} else {
		return nil, _bb.New("\u0077\u0069\u0064\u0074\u0068\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
	}
	if _fgdgb := _fed.TraceToDirectObject(_geeed.Get("\u0048\u0065\u0069\u0067\u0068\u0074")); _fgdgb != nil {
		_cbced, _dcbe := _fgdgb.(*_fed.PdfObjectInteger)
		if !_dcbe {
			return nil, _bb.New("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0069\u006d\u0061\u0067\u0065\u0020\u0068\u0065\u0069g\u0068\u0074\u0020o\u0062j\u0065\u0063\u0074")
		}
		_gaaa := int64(*_cbced)
		_cgbce.Height = &_gaaa
	} else {
		return nil, _bb.New("\u0068\u0065\u0069\u0067\u0068\u0074\u0020\u006d\u0069s\u0073\u0069\u006e\u0067")
	}
	if _ebagd := _fed.TraceToDirectObject(_geeed.Get("\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065")); _ebagd != nil {
		_gfef, _deacb := NewPdfColorspaceFromPdfObject(_ebagd)
		if _deacb != nil {
			return nil, _deacb
		}
		_cgbce.ColorSpace = _gfef
	} else {
		_fef.Log.Debug("\u0058\u004f\u0062\u006a\u0065\u0063t\u0020\u0049\u006d\u0061\u0067e\u0020\u0063\u006f\u006c\u006f\u0072s\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 \u002d\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u0031\u0020\u0063\u006fl\u006f\u0072\u0020\u0063\u006f\u006d\u0070\u006fn\u0065\u006e\u0074")
		_cgbce.ColorSpace = NewPdfColorspaceDeviceGray()
	}
	if _ebgcc := _fed.TraceToDirectObject(_geeed.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074")); _ebgcc != nil {
		_bgbbb, _ddfde := _ebgcc.(*_fed.PdfObjectInteger)
		if !_ddfde {
			return nil, _bb.New("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0069\u006d\u0061\u0067\u0065\u0020\u0068\u0065\u0069g\u0068\u0074\u0020o\u0062j\u0065\u0063\u0074")
		}
		_afcgc := int64(*_bgbbb)
		_cgbce.BitsPerComponent = &_afcgc
	}
	_cgbce.Intent = _geeed.Get("\u0049\u006e\u0074\u0065\u006e\u0074")
	_cgbce.ImageMask = _geeed.Get("\u0049m\u0061\u0067\u0065\u004d\u0061\u0073k")
	_cgbce.Mask = _geeed.Get("\u004d\u0061\u0073\u006b")
	_cgbce.Decode = _geeed.Get("\u0044\u0065\u0063\u006f\u0064\u0065")
	_cgbce.Interpolate = _geeed.Get("I\u006e\u0074\u0065\u0072\u0070\u006f\u006c\u0061\u0074\u0065")
	_cgbce.Alternatives = _geeed.Get("\u0041\u006c\u0074e\u0072\u006e\u0061\u0074\u0069\u0076\u0065\u0073")
	_cgbce.SMask = _geeed.Get("\u0053\u004d\u0061s\u006b")
	_cgbce.SMaskInData = _geeed.Get("S\u004d\u0061\u0073\u006b\u0049\u006e\u0044\u0061\u0074\u0061")
	_cgbce.Matte = _geeed.Get("\u004d\u0061\u0074t\u0065")
	_cgbce.Name = _geeed.Get("\u004e\u0061\u006d\u0065")
	_cgbce.StructParent = _geeed.Get("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074")
	_cgbce.ID = _geeed.Get("\u0049\u0044")
	_cgbce.OPI = _geeed.Get("\u004f\u0050\u0049")
	_cgbce.Metadata = _geeed.Get("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061")
	_cgbce.OC = _geeed.Get("\u004f\u0043")
	_cgbce.Stream = stream.Stream
	return _cgbce, nil
}

// C returns the value of the cyan component of the color.
func (_dggb *PdfColorDeviceCMYK) C() float64 { return _dggb[0] }

// GetOutlines returns a high-level Outline object, based on the outline tree
// of the reader.
func (_fcbff *PdfReader) GetOutlines() (*Outline, error) {
	if _fcbff == nil {
		return nil, _bb.New("\u0063\u0061n\u006e\u006f\u0074\u0020c\u0072\u0065a\u0074\u0065\u0020\u006f\u0075\u0074\u006c\u0069n\u0065\u0020\u0066\u0072\u006f\u006d\u0020\u006e\u0069\u006c\u0020\u0072e\u0061\u0064\u0065\u0072")
	}
	_eceaca := _fcbff.GetOutlineTree()
	if _eceaca == nil {
		return nil, _bb.New("\u0074\u0068\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u0064\u006f\u0065\u0073\u0020n\u006f\u0074\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u006e\u0020o\u0075\u0074\u006c\u0069\u006e\u0065\u0020\u0074\u0072\u0065\u0065")
	}
	var _daacg func(_agdcf *PdfOutlineTreeNode, _fcbfe *[]*OutlineItem)
	_daacg = func(_cggcg *PdfOutlineTreeNode, _bfdfbd *[]*OutlineItem) {
		if _cggcg == nil {
			return
		}
		if _cggcg._ffgd == nil {
			_fef.Log.Debug("\u0045\u0052RO\u0052\u003a\u0020m\u0069\u0073\u0073\u0069ng \u006fut\u006c\u0069\u006e\u0065\u0020\u0065\u006etr\u0079\u0020\u0063\u006f\u006e\u0074\u0065x\u0074")
			return
		}
		var _ababb *OutlineItem
		if _gbgac, _bebcg := _cggcg._ffgd.(*PdfOutlineItem); _bebcg {
			_bagg := _gbgac.Dest
			if (_bagg == nil || _fed.IsNullObject(_bagg)) && _gbgac.A != nil {
				if _caad, _fedab := _fed.GetDict(_gbgac.A); _fedab {
					_bagg, _ = _fed.GetArray(_caad.Get("\u0044"))
				}
			}
			var _bbdgf OutlineDest
			if _bagg != nil && !_fed.IsNullObject(_bagg) {
				if _eebeb, _eegd := _abbfgf(_bagg, _fcbff); _eegd == nil {
					_bbdgf = *_eebeb
				} else {
					_fef.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0063o\u0075\u006c\u0064 \u006e\u006f\u0074\u0020p\u0061\u0072\u0073\u0065\u0020\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u0020\u0064\u0065\u0073\u0074\u0020\u0028\u0025\u0076\u0029\u003a\u0020\u0025\u0076", _bagg, _eegd)
				}
			}
			_ababb = NewOutlineItem(_gbgac.Title.Decoded(), _bbdgf)
			*_bfdfbd = append(*_bfdfbd, _ababb)
			if _gbgac.Next != nil {
				_daacg(_gbgac.Next, _bfdfbd)
			}
		}
		if _cggcg.First != nil {
			if _ababb != nil {
				_bfdfbd = &_ababb.Entries
			}
			_daacg(_cggcg.First, _bfdfbd)
		}
	}
	_ebdf := NewOutline()
	_daacg(_eceaca, &_ebdf.Entries)
	return _ebdf, nil
}

// NewPdfAcroForm returns a new PdfAcroForm with an intialized container (indirect object).
func NewPdfAcroForm() *PdfAcroForm {
	return &PdfAcroForm{Fields: &[]*PdfField{}, _ceed: _fed.MakeIndirectObject(_fed.MakeDict())}
}

// SetLocation sets the `Location` field of the signature.
func (_bfed *PdfSignature) SetLocation(location string) { _bfed.Location = _fed.MakeString(location) }

// ToPdfObject implements interface PdfModel.
func (_acc *PdfActionGoTo3DView) ToPdfObject() _fed.PdfObject {
	_acc.PdfAction.ToPdfObject()
	_ccd := _acc._fa
	_aeg := _ccd.PdfObject.(*_fed.PdfObjectDictionary)
	_aeg.SetIfNotNil("\u0053", _fed.MakeName(string(ActionTypeGoTo3DView)))
	_aeg.SetIfNotNil("\u0054\u0041", _acc.TA)
	_aeg.SetIfNotNil("\u0056", _acc.V)
	return _ccd
}
func _efbdb(_aeeeb *_fed.PdfObjectStream) (*PdfFunctionType4, error) {
	_fddd := &PdfFunctionType4{}
	_fddd._ebcf = _aeeeb
	_fadfd := _aeeeb.PdfObjectDictionary
	_fafaf, _agbg := _fed.TraceToDirectObject(_fadfd.Get("\u0044\u006f\u006d\u0061\u0069\u006e")).(*_fed.PdfObjectArray)
	if !_agbg {
		_fef.Log.Error("D\u006fm\u0061\u0069\u006e\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063\u0069fi\u0065\u0064")
		return nil, _bb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if _fafaf.Len()%2 != 0 {
		_fef.Log.Error("\u0044\u006f\u006d\u0061\u0069\u006e\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
		return nil, _bb.New("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0064\u006f\u006da\u0069\u006e\u0020\u0072an\u0067\u0065")
	}
	_ceegg, _eabf := _fafaf.ToFloat64Array()
	if _eabf != nil {
		return nil, _eabf
	}
	_fddd.Domain = _ceegg
	_fafaf, _agbg = _fed.TraceToDirectObject(_fadfd.Get("\u0052\u0061\u006eg\u0065")).(*_fed.PdfObjectArray)
	if _agbg {
		if _fafaf.Len() < 0 || _fafaf.Len()%2 != 0 {
			return nil, _bb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0061\u006e\u0067\u0065")
		}
		_abbdg, _fgeb := _fafaf.ToFloat64Array()
		if _fgeb != nil {
			return nil, _fgeb
		}
		_fddd.Range = _abbdg
	}
	_geffb, _eabf := _fed.DecodeStream(_aeeeb)
	if _eabf != nil {
		return nil, _eabf
	}
	_fddd._gcdfd = _geffb
	_bbea := _ed.NewPSParser(_geffb)
	_bgfg, _eabf := _bbea.Parse()
	if _eabf != nil {
		return nil, _eabf
	}
	_fddd.Program = _bgfg
	return _fddd, nil
}

// NewPdfFieldSignature returns an initialized signature field.
func NewPdfFieldSignature(signature *PdfSignature) *PdfFieldSignature {
	_geeac := &PdfFieldSignature{}
	_geeac.PdfField = NewPdfField()
	_geeac.PdfField.SetContext(_geeac)
	_geeac.PdfAnnotationWidget = NewPdfAnnotationWidget()
	_geeac.PdfAnnotationWidget.SetContext(_geeac)
	_geeac.PdfAnnotationWidget._ffaab = _geeac.PdfField._cbaae
	_geeac.T = _fed.MakeString("")
	_geeac.F = _fed.MakeInteger(132)
	_geeac.V = signature
	return _geeac
}

// WriteToFile writes the output PDF to file.
func (_bdeeb *PdfWriter) WriteToFile(outputFilePath string) error {
	_cecc, _fgcdg := _da.Create(outputFilePath)
	if _fgcdg != nil {
		return _fgcdg
	}
	defer _cecc.Close()
	return _bdeeb.Write(_cecc)
}

// GetNumComponents returns the number of color components (1 for Indexed).
func (_ecbec *PdfColorspaceSpecialIndexed) GetNumComponents() int { return 1 }

// ImageToRGB converts an image in CMYK32 colorspace to an RGB image.
func (_ccff *PdfColorspaceDeviceCMYK) ImageToRGB(img Image) (Image, error) {
	_fef.Log.Trace("\u0043\u004d\u0059\u004b\u0033\u0032\u0020\u002d\u003e\u0020\u0052\u0047\u0042")
	_fef.Log.Trace("I\u006d\u0061\u0067\u0065\u0020\u0042P\u0043\u003a\u0020\u0025\u0064\u002c \u0043\u006f\u006c\u006f\u0072\u0020\u0063o\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073\u003a\u0020%\u0064", img.BitsPerComponent, img.ColorComponents)
	_fef.Log.Trace("\u004c\u0065\u006e \u0064\u0061\u0074\u0061\u003a\u0020\u0025\u0064", len(img.Data))
	_fef.Log.Trace("H\u0065\u0069\u0067\u0068t:\u0020%\u0064\u002c\u0020\u0057\u0069d\u0074\u0068\u003a\u0020\u0025\u0064", img.Height, img.Width)
	_bacf, _debg := _eede.NewImage(int(img.Width), int(img.Height), int(img.BitsPerComponent), img.ColorComponents, img.Data, img._caeaf, img._ccdge)
	if _debg != nil {
		return Image{}, _debg
	}
	_eage, _debg := _eede.NRGBAConverter.Convert(_bacf)
	if _debg != nil {
		return Image{}, _debg
	}
	return _ddbab(_eage.Base()), nil
}

// HasFontByName checks whether a font is defined by the specified keyName.
func (_eggdd *PdfPageResources) HasFontByName(keyName _fed.PdfObjectName) bool {
	_, _efdd := _eggdd.GetFontByName(keyName)
	return _efdd
}
func _acadg(_cdefb *fontCommon) *pdfFontSimple { return &pdfFontSimple{fontCommon: *_cdefb} }

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain a single element.
func (_deac *PdfColorspaceSpecialSeparation) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 1 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_fgdag := vals[0]
	_bcgbb := []float64{_fgdag}
	_abdd, _gbef := _deac.TintTransform.Evaluate(_bcgbb)
	if _gbef != nil {
		_fef.Log.Debug("\u0045\u0072r\u006f\u0072\u002c\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0065\u0076\u0061\u006c\u0075\u0061\u0074\u0065: \u0025\u0076", _gbef)
		_fef.Log.Trace("\u0054\u0069\u006e\u0074 t\u0072\u0061\u006e\u0073\u0066\u006f\u0072\u006d\u003a\u0020\u0025\u002b\u0076", _deac.TintTransform)
		return nil, _gbef
	}
	_fef.Log.Trace("\u0050\u0072\u006f\u0063\u0065\u0073\u0073\u0069\u006e\u0067\u0020\u0043\u006f\u006c\u006fr\u0046\u0072\u006f\u006d\u0046\u006c\u006f\u0061\u0074\u0073\u0028\u0025\u002bv\u0029\u0020\u006f\u006e\u0020\u0041\u006c\u0074\u0065\u0072\u006e\u0061te\u0053\u0070\u0061\u0063\u0065\u003a\u0020\u0025\u0023\u0076", _abdd, _deac.AlternateSpace)
	_cebfa, _gbef := _deac.AlternateSpace.ColorFromFloats(_abdd)
	if _gbef != nil {
		_fef.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u002c\u0020\u0066a\u0069\u006c\u0065d \u0074\u006f\u0020\u0065\u0076\u0061l\u0075\u0061\u0074\u0065\u0020\u0069\u006e\u0020\u0061\u006c\u0074\u0065\u0072\u006e\u0061t\u0065\u0020\u0073\u0070\u0061\u0063\u0065\u003a \u0025\u0076", _gbef)
		return nil, _gbef
	}
	return _cebfa, nil
}

const (
	XObjectTypeUndefined XObjectType = iota
	XObjectTypeImage
	XObjectTypeForm
	XObjectTypePS
	XObjectTypeUnknown
)

// FieldFilterFunc represents a PDF field filtering function. If the function
// returns true, the PDF field is kept, otherwise it is discarded.
type FieldFilterFunc func(*PdfField) bool

func (_cdge *PdfReader) newPdfAnnotationStampFromDict(_cdef *_fed.PdfObjectDictionary) (*PdfAnnotationStamp, error) {
	_aecb := PdfAnnotationStamp{}
	_gef, _bcfg := _cdge.newPdfAnnotationMarkupFromDict(_cdef)
	if _bcfg != nil {
		return nil, _bcfg
	}
	_aecb.PdfAnnotationMarkup = _gef
	_aecb.Name = _cdef.Get("\u004e\u0061\u006d\u0065")
	return &_aecb, nil
}

// PdfAnnotationLink represents Link annotations.
// (Section 12.5.6.5 p. 403).
type PdfAnnotationLink struct {
	*PdfAnnotation
	A          _fed.PdfObject
	Dest       _fed.PdfObject
	H          _fed.PdfObject
	PA         _fed.PdfObject
	QuadPoints _fed.PdfObject
	BS         _fed.PdfObject
	_cge       *PdfAction
	_dfbb      *PdfReader
}

// FieldFlattenOpts defines a set of options which can be used to configure
// the field flattening process.
type FieldFlattenOpts struct {

	// FilterFunc allows filtering the form fields used in the flattening
	// process. If the filter function returns true, the field is flattened,
	// otherwise it is skipped.
	// If a non-terminal field is discarded, all of its children (the fields
	// present in the Kids array) are discarded as well.
	// Non-terminal fields are kept in the AcroForm if one or more of their
	// child fields have not been selected for flattening.
	// If a filter function is not provided, all form fields are flattened.
	FilterFunc FieldFilterFunc

	// AnnotFilterFunc allows filtering the annotations in the flattening
	// process. If the filter function returns true, the annotation is flattened,
	// otherwise it is skipped.
	AnnotFilterFunc AnnotFilterFunc
}

// GetCharMetrics returns the char metrics for character code `code`.
// How it works:
//  1) It calls the GetCharMetrics function for the underlying font, either a simple font or
//     a Type0 font. The underlying font GetCharMetrics() functions do direct charcode ➞  metrics
//     mappings.
//  2) If the underlying font's GetCharMetrics() doesn't have a CharMetrics for `code` then a
//     a CharMetrics with the FontDescriptor's /MissingWidth is returned.
//  3) If there is no /MissingWidth then a failure is returned.
// TODO(peterwilliams97) There is nothing callers can do if no CharMetrics are found so we might as
//                       well give them 0 width. There is no need for the bool return.
// TODO(gunnsth): Reconsider whether needed or if can map via GlyphName.
func (_gffcb *PdfFont) GetCharMetrics(code _dg.CharCode) (CharMetrics, bool) {
	var _babec _geg.CharMetrics
	switch _acae := _gffcb._gdaa.(type) {
	case *pdfFontSimple:
		if _dgcb, _feae := _acae.GetCharMetrics(code); _feae {
			return _dgcb, _feae
		}
	case *pdfFontType0:
		if _fafde, _fbbc := _acae.GetCharMetrics(code); _fbbc {
			return _fafde, _fbbc
		}
	case *pdfCIDFontType0:
		if _ecge, _gaea := _acae.GetCharMetrics(code); _gaea {
			return _ecge, _gaea
		}
	case *pdfCIDFontType2:
		if _bcgbf, _ccagf := _acae.GetCharMetrics(code); _ccagf {
			return _bcgbf, _ccagf
		}
	case *pdfFontType3:
		if _eaceg, _bbec := _acae.GetCharMetrics(code); _bbec {
			return _eaceg, _bbec
		}
	default:
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020G\u0065\u0074\u0043h\u0061\u0072\u004de\u0074\u0072i\u0063\u0073\u0020\u006e\u006f\u0074 \u0069mp\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0066\u006f\u0072\u0020\u0066\u006f\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u003d\u0025\u0054\u002e", _gffcb._gdaa)
		return _babec, false
	}
	if _eadaaa, _ccfd := _gffcb.GetFontDescriptor(); _ccfd == nil && _eadaaa != nil {
		return _geg.CharMetrics{Wx: _eadaaa._ffegc}, true
	}
	_fef.Log.Debug("\u0047\u0065\u0074\u0043\u0068\u0061\u0072\u004d\u0065\u0074\u0072\u0069\u0063\u0073\u003a\u0020\u004e\u006f\u0020\u006d\u0065\u0074\u0072\u0069c\u0073\u0020\u0066\u006f\u0072 \u0066\u006fn\u0074\u003d\u0025\u0073", _gffcb)
	return _babec, false
}

// ToPdfObject converts the pdfCIDFontType2 to a PDF representation.
func (_gfac *pdfCIDFontType2) ToPdfObject() _fed.PdfObject {
	if _gfac._fdec == nil {
		_gfac._fdec = &_fed.PdfIndirectObject{}
	}
	_aadeb := _gfac.baseFields().asPdfObjectDictionary("\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0032")
	_gfac._fdec.PdfObject = _aadeb
	if _gfac.CIDSystemInfo != nil {
		_aadeb.Set("\u0043\u0049\u0044\u0053\u0079\u0073\u0074\u0065\u006d\u0049\u006e\u0066\u006f", _gfac.CIDSystemInfo)
	}
	if _gfac.DW != nil {
		_aadeb.Set("\u0044\u0057", _gfac.DW)
	}
	if _gfac.DW2 != nil {
		_aadeb.Set("\u0044\u0057\u0032", _gfac.DW2)
	}
	if _gfac.W != nil {
		_aadeb.Set("\u0057", _gfac.W)
	}
	if _gfac.W2 != nil {
		_aadeb.Set("\u0057\u0032", _gfac.W2)
	}
	if _gfac.CIDToGIDMap != nil {
		_aadeb.Set("C\u0049\u0044\u0054\u006f\u0047\u0049\u0044\u004d\u0061\u0070", _gfac.CIDToGIDMap)
	}
	return _gfac._fdec
}
func (_fdbfa SignatureValidationResult) String() string {
	var _gcaac _eb.Buffer
	_gcaac.WriteString(_d.Sprintf("\u004ea\u006d\u0065\u003a\u0020\u0025\u0073\n", _fdbfa.Name))
	if _fdbfa.Date._abaff > 0 {
		_gcaac.WriteString(_d.Sprintf("\u0044a\u0074\u0065\u003a\u0020\u0025\u0073\n", _fdbfa.Date.ToGoTime().String()))
	} else {
		_gcaac.WriteString("\u0044\u0061\u0074\u0065 n\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u000a")
	}
	if len(_fdbfa.Reason) > 0 {
		_gcaac.WriteString(_d.Sprintf("R\u0065\u0061\u0073\u006f\u006e\u003a\u0020\u0025\u0073\u000a", _fdbfa.Reason))
	} else {
		_gcaac.WriteString("N\u006f \u0072\u0065\u0061\u0073\u006f\u006e\u0020\u0073p\u0065\u0063\u0069\u0066ie\u0064\u000a")
	}
	if len(_fdbfa.Location) > 0 {
		_gcaac.WriteString(_d.Sprintf("\u004c\u006f\u0063\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0073\u000a", _fdbfa.Location))
	} else {
		_gcaac.WriteString("\u004c\u006f\u0063at\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u000a")
	}
	if len(_fdbfa.ContactInfo) > 0 {
		_gcaac.WriteString(_d.Sprintf("\u0043\u006f\u006e\u0074\u0061\u0063\u0074\u0020\u0049\u006e\u0066\u006f:\u0020\u0025\u0073\u000a", _fdbfa.ContactInfo))
	} else {
		_gcaac.WriteString("C\u006f\u006e\u0074\u0061\u0063\u0074 \u0069\u006e\u0066\u006f\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063i\u0066i\u0065\u0064\u000a")
	}
	_gcaac.WriteString(_d.Sprintf("F\u0069\u0065\u006c\u0064\u0073\u003a\u0020\u0025\u0064\u000a", len(_fdbfa.Fields)))
	if _fdbfa.IsSigned {
		_gcaac.WriteString("S\u0069\u0067\u006e\u0065\u0064\u003a \u0044\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073\u0020\u0073i\u0067n\u0065\u0064\u000a")
	} else {
		_gcaac.WriteString("\u0053\u0069\u0067\u006eed\u003a\u0020\u004e\u006f\u0074\u0020\u0073\u0069\u0067\u006e\u0065\u0064\u000a")
	}
	if _fdbfa.IsVerified {
		_gcaac.WriteString("\u0053\u0069\u0067n\u0061\u0074\u0075\u0072e\u0020\u0076\u0061\u006c\u0069\u0064\u0061t\u0069\u006f\u006e\u003a\u0020\u0049\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u000a")
	} else {
		_gcaac.WriteString("\u0053\u0069\u0067\u006e\u0061\u0074u\u0072\u0065\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e:\u0020\u0049\u0073\u0020\u0069\u006e\u0076a\u006c\u0069\u0064\u000a")
	}
	if _fdbfa.IsTrusted {
		_gcaac.WriteString("\u0054\u0072\u0075\u0073\u0074\u0065\u0064\u003a\u0020\u0043\u0065\u0072\u0074\u0069\u0066i\u0063a\u0074\u0065\u0020\u0069\u0073\u0020\u0074\u0072\u0075\u0073\u0074\u0065\u0064\u000a")
	} else {
		_gcaac.WriteString("\u0054\u0072\u0075s\u0074\u0065\u0064\u003a \u0055\u006e\u0074\u0072\u0075\u0073\u0074e\u0064\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u000a")
	}
	if !_fdbfa.GeneralizedTime.IsZero() {
		_gcaac.WriteString(_d.Sprintf("G\u0065n\u0065\u0072\u0061\u006c\u0069\u007a\u0065\u0064T\u0069\u006d\u0065\u003a %\u0073\u000a", _fdbfa.GeneralizedTime.String()))
	}
	return _gcaac.String()
}

// ToPdfOutlineItem returns a low level PdfOutlineItem object,
// based on the current instance.
func (_aedda *OutlineItem) ToPdfOutlineItem() (*PdfOutlineItem, int64) {
	_dbgbg := NewPdfOutlineItem()
	_dbgbg.Title = _fed.MakeEncodedString(_aedda.Title, true)
	_dbgbg.Dest = _aedda.Dest.ToPdfObject()
	var _cbbg []*PdfOutlineItem
	var _adaaeg int64
	var _acgg *PdfOutlineItem
	for _, _fdbac := range _aedda.Entries {
		_cacb, _addde := _fdbac.ToPdfOutlineItem()
		_cacb.Parent = &_dbgbg.PdfOutlineTreeNode
		if _acgg != nil {
			_acgg.Next = &_cacb.PdfOutlineTreeNode
			_cacb.Prev = &_acgg.PdfOutlineTreeNode
		}
		_cbbg = append(_cbbg, _cacb)
		_adaaeg += _addde
		_acgg = _cacb
	}
	_ddedg := len(_cbbg)
	_adaaeg += int64(_ddedg)
	if _ddedg > 0 {
		_dbgbg.First = &_cbbg[0].PdfOutlineTreeNode
		_dbgbg.Last = &_cbbg[_ddedg-1].PdfOutlineTreeNode
		_dbgbg.Count = &_adaaeg
	}
	return _dbgbg, _adaaeg
}

// NewPdfAnnotationProjection returns a new projection annotation.
func NewPdfAnnotationProjection() *PdfAnnotationProjection {
	_eea := NewPdfAnnotation()
	_abgb := &PdfAnnotationProjection{}
	_abgb.PdfAnnotation = _eea
	_abgb.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_eea.SetContext(_abgb)
	return _abgb
}
func (_aedg *PdfReader) newPdfAnnotationLineFromDict(_dfbec *_fed.PdfObjectDictionary) (*PdfAnnotationLine, error) {
	_ecee := PdfAnnotationLine{}
	_gceg, _gaf := _aedg.newPdfAnnotationMarkupFromDict(_dfbec)
	if _gaf != nil {
		return nil, _gaf
	}
	_ecee.PdfAnnotationMarkup = _gceg
	_ecee.L = _dfbec.Get("\u004c")
	_ecee.BS = _dfbec.Get("\u0042\u0053")
	_ecee.LE = _dfbec.Get("\u004c\u0045")
	_ecee.IC = _dfbec.Get("\u0049\u0043")
	_ecee.LL = _dfbec.Get("\u004c\u004c")
	_ecee.LLE = _dfbec.Get("\u004c\u004c\u0045")
	_ecee.Cap = _dfbec.Get("\u0043\u0061\u0070")
	_ecee.IT = _dfbec.Get("\u0049\u0054")
	_ecee.LLO = _dfbec.Get("\u004c\u004c\u004f")
	_ecee.CP = _dfbec.Get("\u0043\u0050")
	_ecee.Measure = _dfbec.Get("\u004de\u0061\u0073\u0075\u0072\u0065")
	_ecee.CO = _dfbec.Get("\u0043\u004f")
	return &_ecee, nil
}

// NewPdfPageResourcesFromDict creates and returns a new PdfPageResources object
// from the input dictionary.
func NewPdfPageResourcesFromDict(dict *_fed.PdfObjectDictionary) (*PdfPageResources, error) {
	_dbccf := NewPdfPageResources()
	if _acac := dict.Get("\u0045x\u0074\u0047\u0053\u0074\u0061\u0074e"); _acac != nil {
		_dbccf.ExtGState = _acac
	}
	if _fdgb := dict.Get("\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065"); _fdgb != nil && !_fed.IsNullObject(_fdgb) {
		_dbccf.ColorSpace = _fdgb
	}
	if _fgada := dict.Get("\u0050a\u0074\u0074\u0065\u0072\u006e"); _fgada != nil {
		_dbccf.Pattern = _fgada
	}
	if _beff := dict.Get("\u0053h\u0061\u0064\u0069\u006e\u0067"); _beff != nil {
		_dbccf.Shading = _beff
	}
	if _edagf := dict.Get("\u0058O\u0062\u006a\u0065\u0063\u0074"); _edagf != nil {
		_dbccf.XObject = _edagf
	}
	if _agcae := _fed.ResolveReference(dict.Get("\u0046\u006f\u006e\u0074")); _agcae != nil {
		_dbccf.Font = _agcae
	}
	if _dbdbd := dict.Get("\u0050r\u006f\u0063\u0053\u0065\u0074"); _dbdbd != nil {
		_dbccf.ProcSet = _dbdbd
	}
	if _babc := dict.Get("\u0050\u0072\u006f\u0070\u0065\u0072\u0074\u0069\u0065\u0073"); _babc != nil {
		_dbccf.Properties = _babc
	}
	return _dbccf, nil
}
func _eagd(_eedc *fontCommon) *pdfFontType0 { return &pdfFontType0{fontCommon: *_eedc} }

// FullName returns the full name of the field as in rootname.parentname.partialname.
func (_fdcb *PdfField) FullName() (string, error) {
	var _begd _eb.Buffer
	_bbbfa := []string{}
	if _fdcb.T != nil {
		_bbbfa = append(_bbbfa, _fdcb.T.Decoded())
	}
	_edega := map[*PdfField]bool{}
	_edega[_fdcb] = true
	_caeb := _fdcb.Parent
	for _caeb != nil {
		if _, _debce := _edega[_caeb]; _debce {
			return _begd.String(), _bb.New("\u0072\u0065\u0063\u0075rs\u0069\u0076\u0065\u0020\u0074\u0072\u0061\u0076\u0065\u0072\u0073\u0061\u006c")
		}
		if _caeb.T == nil {
			return _begd.String(), _bb.New("\u0066\u0069el\u0064\u0020\u0070a\u0072\u0074\u0069\u0061l n\u0061me\u0020\u0028\u0054\u0029\u0020\u006e\u006ft \u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064")
		}
		_bbbfa = append(_bbbfa, _caeb.T.Decoded())
		_edega[_caeb] = true
		_caeb = _caeb.Parent
	}
	for _beae := len(_bbbfa) - 1; _beae >= 0; _beae-- {
		_begd.WriteString(_bbbfa[_beae])
		if _beae > 0 {
			_begd.WriteString("\u002e")
		}
	}
	return _begd.String(), nil
}

// Enable LTV enables the specified signature. The signing certificate
// chain is extracted from the signature dictionary. Optionally, additional
// certificates can be specified through the `extraCerts` parameter.
// The LTV client attempts to build the certificate chain up to a trusted root
// by downloading any missing certificates.
func (_acfgf *LTV) Enable(sig *PdfSignature, extraCerts []*_fe.Certificate) error {
	if _edadf := _acfgf.validateSig(sig); _edadf != nil {
		return _edadf
	}
	_egcg, _caac := _acfgf.generateVRIKey(sig)
	if _caac != nil {
		return _caac
	}
	if _, _aadfcg := _acfgf._aageb.VRI[_egcg]; _aadfcg && _acfgf.SkipExisting {
		return nil
	}
	_caba, _caac := sig.GetCerts()
	if _caac != nil {
		return _caac
	}
	return _acfgf.enable(_caba, extraCerts, _egcg)
}

// GetFontDescriptor returns the font descriptor for `font`.
func (_edbec PdfFont) GetFontDescriptor() (*PdfFontDescriptor, error) {
	return _edbec._gdaa.getFontDescriptor(), nil
}
func (_ffcc fontCommon) coreString() string {
	_eddd := ""
	if _ffcc._bgdgb != nil {
		_eddd = _ffcc._bgdgb.String()
	}
	return _d.Sprintf("\u0025#\u0071\u0020%\u0023\u0071\u0020%\u0071\u0020\u006f\u0062\u006a\u003d\u0025d\u0020\u0054\u006f\u0055\u006e\u0069c\u006f\u0064\u0065\u003d\u0025\u0074\u0020\u0066\u006c\u0061\u0067s\u003d\u0030\u0078\u0025\u0030\u0078\u0020\u0025\u0073", _ffcc._afge, _ffcc._daac, _ffcc._ceab, _ffcc._edfcd, _ffcc._bbfbc != nil, _ffcc.fontFlags(), _eddd)
}
func (_gecd *PdfReader) newPdfActionHideFromDict(_eedea *_fed.PdfObjectDictionary) (*PdfActionHide, error) {
	return &PdfActionHide{T: _eedea.Get("\u0054"), H: _eedea.Get("\u0048")}, nil
}

// PdfColorCalGray represents a CalGray colorspace.
type PdfColorCalGray float64

// PdfAnnotationWidget represents Widget annotations.
// Note: Widget annotations are used to display form fields.
// (Section 12.5.6.19).
type PdfAnnotationWidget struct {
	*PdfAnnotation
	H      _fed.PdfObject
	MK     _fed.PdfObject
	A      _fed.PdfObject
	AA     _fed.PdfObject
	BS     _fed.PdfObject
	Parent _fed.PdfObject
	_eagb  *PdfField
	_dff   bool
}

func _aagd(_bcgcb string) map[string]string {
	_acbbd := _edadd.Split(_bcgcb, -1)
	_gdcg := map[string]string{}
	for _, _ceff := range _acbbd {
		_dgdg := _ddcc.FindStringSubmatch(_ceff)
		if _dgdg == nil {
			continue
		}
		_eabdg, _dgbegc := _dgdg[1], _dgdg[2]
		_gdcg[_eabdg] = _dgbegc
	}
	return _gdcg
}

// GetNumComponents returns the number of color components (1 for CalGray).
func (_dbcf *PdfColorCalGray) GetNumComponents() int { return 1 }
func _dcdfad(_gdcfc _fed.PdfObject) (string, error) {
	_gdcfc = _fed.TraceToDirectObject(_gdcfc)
	switch _ebea := _gdcfc.(type) {
	case *_fed.PdfObjectString:
		return _ebea.Str(), nil
	case *_fed.PdfObjectStream:
		_cebe, _gbaec := _fed.DecodeStream(_ebea)
		if _gbaec != nil {
			return "", _gbaec
		}
		return string(_cebe), nil
	}
	return "", _d.Errorf("\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0073\u0074\u0072e\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0068\u006f\u006c\u0064\u0065\u0072\u0020\u0028\u0025\u0054\u0029", _gdcfc)
}

// ToPdfObject return the CalGray colorspace as a PDF object (name dictionary).
func (_daee *PdfColorspaceCalGray) ToPdfObject() _fed.PdfObject {
	_fbcga := &_fed.PdfObjectArray{}
	_fbcga.Append(_fed.MakeName("\u0043a\u006c\u0047\u0072\u0061\u0079"))
	_fgcg := _fed.MakeDict()
	if _daee.WhitePoint != nil {
		_fgcg.Set("\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074", _fed.MakeArray(_fed.MakeFloat(_daee.WhitePoint[0]), _fed.MakeFloat(_daee.WhitePoint[1]), _fed.MakeFloat(_daee.WhitePoint[2])))
	} else {
		_fef.Log.Error("\u0043\u0061\u006c\u0047\u0072\u0061\u0079\u003a\u0020\u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0057\u0068\u0069\u0074\u0065\u0050\u006fi\u006e\u0074\u0020\u0028\u0052e\u0071\u0075i\u0072\u0065\u0064\u0029")
	}
	if _daee.BlackPoint != nil {
		_fgcg.Set("\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074", _fed.MakeArray(_fed.MakeFloat(_daee.BlackPoint[0]), _fed.MakeFloat(_daee.BlackPoint[1]), _fed.MakeFloat(_daee.BlackPoint[2])))
	}
	_fgcg.Set("\u0047\u0061\u006dm\u0061", _fed.MakeFloat(_daee.Gamma))
	_fbcga.Append(_fgcg)
	if _daee._cdab != nil {
		_daee._cdab.PdfObject = _fbcga
		return _daee._cdab
	}
	return _fbcga
}

// GetContainingPdfObject returns the XObject Form's containing object (indirect object).
func (_fedea *XObjectForm) GetContainingPdfObject() _fed.PdfObject { return _fedea._cedfc }

// GetOutlineTree returns the outline tree.
func (_gffeeg *PdfReader) GetOutlineTree() *PdfOutlineTreeNode { return _gffeeg._fgcc }
func (_cfdfd *PdfWriter) hasObject(_gaded _fed.PdfObject) bool {
	_, _afebg := _cfdfd._bdadf[_gaded]
	return _afebg
}

// ToPdfObject implements interface PdfModel.
func (_abcd *PdfAnnotation3D) ToPdfObject() _fed.PdfObject {
	_abcd.PdfAnnotation.ToPdfObject()
	_fefdc := _abcd._ffaab
	_bgbg := _fefdc.PdfObject.(*_fed.PdfObjectDictionary)
	_bgbg.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u0033\u0044"))
	_bgbg.SetIfNotNil("\u0033\u0044\u0044", _abcd.T3DD)
	_bgbg.SetIfNotNil("\u0033\u0044\u0056", _abcd.T3DV)
	_bgbg.SetIfNotNil("\u0033\u0044\u0041", _abcd.T3DA)
	_bgbg.SetIfNotNil("\u0033\u0044\u0049", _abcd.T3DI)
	_bgbg.SetIfNotNil("\u0033\u0044\u0042", _abcd.T3DB)
	return _fefdc
}

// FillWithAppearance populates `form` with values provided by `provider`.
// If not nil, `appGen` is used to generate appearance dictionaries for the
// field annotations, based on the specified settings. Otherwise, appearance
// generation is skipped.
// e.g.: appGen := annotator.FieldAppearance{OnlyIfMissing: true, RegenerateTextFields: true}
// NOTE: In next major version this functionality will be part of Fill. (v4)
func (_eabb *PdfAcroForm) FillWithAppearance(provider FieldValueProvider, appGen FieldAppearanceGenerator) error {
	return _eabb.fill(provider, appGen)
}

// ColorToRGB converts gray -> rgb for a single color component.
func (_dfcgd *PdfColorspaceDeviceGray) ColorToRGB(color PdfColor) (PdfColor, error) {
	_aaeg, _bbba := color.(*PdfColorDeviceGray)
	if !_bbba {
		_fef.Log.Debug("\u0049\u006e\u0070\u0075\u0074\u0020\u0063\u006f\u006c\u006fr\u0020\u006e\u006f\u0074\u0020\u0064\u0065v\u0069\u0063\u0065\u0020\u0067\u0072\u0061\u0079\u0020\u0025\u0054", color)
		return nil, _bb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	return NewPdfColorDeviceRGB(float64(*_aaeg), float64(*_aaeg), float64(*_aaeg)), nil
}

// GetMediaBox gets the inheritable media box value, either from the page
// or a higher up page/pages struct.
func (_efaegb *PdfPage) GetMediaBox() (*PdfRectangle, error) {
	if _efaegb.MediaBox != nil {
		return _efaegb.MediaBox, nil
	}
	_aeac := _efaegb.Parent
	for _aeac != nil {
		_gfgdd, _ecgac := _fed.GetDict(_aeac)
		if !_ecgac {
			return nil, _bb.New("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079")
		}
		if _cdgfb := _gfgdd.Get("\u004d\u0065\u0064\u0069\u0061\u0042\u006f\u0078"); _cdgfb != nil {
			_fadd, _eeced := _fed.GetArray(_cdgfb)
			if !_eeced {
				return nil, _bb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006d\u0065\u0064\u0069a\u0020\u0062\u006f\u0078")
			}
			_abcdc, _acedg := NewPdfRectangle(*_fadd)
			if _acedg != nil {
				return nil, _acedg
			}
			return _abcdc, nil
		}
		_aeac = _gfgdd.Get("\u0050\u0061\u0072\u0065\u006e\u0074")
	}
	return nil, _bb.New("m\u0065\u0064\u0069\u0061 b\u006fx\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064")
}
func (_bebe *PdfReader) traverseObjectData(_agfa _fed.PdfObject) error {
	return _fed.ResolveReferencesDeep(_agfa, _bebe._aaebc)
}

// PdfAnnotationLine represents Line annotations.
// (Section 12.5.6.7).
type PdfAnnotationLine struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	L       _fed.PdfObject
	BS      _fed.PdfObject
	LE      _fed.PdfObject
	IC      _fed.PdfObject
	LL      _fed.PdfObject
	LLE     _fed.PdfObject
	Cap     _fed.PdfObject
	IT      _fed.PdfObject
	LLO     _fed.PdfObject
	CP      _fed.PdfObject
	Measure _fed.PdfObject
	CO      _fed.PdfObject
}

// ToPdfObject implements interface PdfModel.
func (_fbgf *PdfAnnotationPolyLine) ToPdfObject() _fed.PdfObject {
	_fbgf.PdfAnnotation.ToPdfObject()
	_acab := _fbgf._ffaab
	_cebf := _acab.PdfObject.(*_fed.PdfObjectDictionary)
	_fbgf.PdfAnnotationMarkup.appendToPdfDictionary(_cebf)
	_cebf.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u0050\u006f\u006c\u0079\u004c\u0069\u006e\u0065"))
	_cebf.SetIfNotNil("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073", _fbgf.Vertices)
	_cebf.SetIfNotNil("\u004c\u0045", _fbgf.LE)
	_cebf.SetIfNotNil("\u0042\u0053", _fbgf.BS)
	_cebf.SetIfNotNil("\u0049\u0043", _fbgf.IC)
	_cebf.SetIfNotNil("\u0042\u0045", _fbgf.BE)
	_cebf.SetIfNotNil("\u0049\u0054", _fbgf.IT)
	_cebf.SetIfNotNil("\u004de\u0061\u0073\u0075\u0072\u0065", _fbgf.Measure)
	return _acab
}

// NewPdfActionGoTo returns a new "go to" action.
func NewPdfActionGoTo() *PdfActionGoTo {
	_aag := NewPdfAction()
	_gc := &PdfActionGoTo{}
	_gc.PdfAction = _aag
	_aag.SetContext(_gc)
	return _gc
}

// Inspect inspects the object types, subtypes and content in the PDF file returning a map of
// object type to number of instances of each.
func (_egacg *PdfReader) Inspect() (map[string]int, error) { return _egacg._cdfggf.Inspect() }

// ToPdfObject returns the choice field dictionary within an indirect object (container).
func (_bcea *PdfFieldChoice) ToPdfObject() _fed.PdfObject {
	_bcea.PdfField.ToPdfObject()
	_egbb := _bcea._cbaae
	_ffbcf := _egbb.PdfObject.(*_fed.PdfObjectDictionary)
	_ffbcf.Set("\u0046\u0054", _fed.MakeName("\u0043\u0068"))
	if _bcea.Opt != nil {
		_ffbcf.Set("\u004f\u0070\u0074", _bcea.Opt)
	}
	if _bcea.TI != nil {
		_ffbcf.Set("\u0054\u0049", _bcea.TI)
	}
	if _bcea.I != nil {
		_ffbcf.Set("\u0049", _bcea.I)
	}
	return _egbb
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_bfdce *PdfShadingType7) ToPdfObject() _fed.PdfObject {
	_bfdce.PdfShading.ToPdfObject()
	_fdfcb, _gdab := _bfdce.getShadingDict()
	if _gdab != nil {
		_fef.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _bfdce.BitsPerCoordinate != nil {
		_fdfcb.Set("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065", _bfdce.BitsPerCoordinate)
	}
	if _bfdce.BitsPerComponent != nil {
		_fdfcb.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _bfdce.BitsPerComponent)
	}
	if _bfdce.BitsPerFlag != nil {
		_fdfcb.Set("B\u0069\u0074\u0073\u0050\u0065\u0072\u0046\u006c\u0061\u0067", _bfdce.BitsPerFlag)
	}
	if _bfdce.Decode != nil {
		_fdfcb.Set("\u0044\u0065\u0063\u006f\u0064\u0065", _bfdce.Decode)
	}
	if _bfdce.Function != nil {
		if len(_bfdce.Function) == 1 {
			_fdfcb.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _bfdce.Function[0].ToPdfObject())
		} else {
			_efag := _fed.MakeArray()
			for _, _baga := range _bfdce.Function {
				_efag.Append(_baga.ToPdfObject())
			}
			_fdfcb.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _efag)
		}
	}
	return _bfdce._cdcge
}

// LTV represents an LTV (Long-Term Validation) client. It is used to LTV
// enable signatures by adding validation and revocation data (certificate,
// OCSP and CRL information) to the DSS dictionary of a PDF document.
//
// LTV is added through the DSS by:
// - Adding certificates, OCSP and CRL information in the global scope of the
//   DSS. The global data is used for validating any of the signatures present
//   in the document.
// - Adding certificates, OCSP and CRL information for a single signature,
//   through an entry in the VRI dictionary of the DSS. The added data is used
//   for validating that particular signature only. This is the recommended
//   method for adding validation data for a signature. However, this is not
//   is not possible in the same revision the signature is applied. Validation
//   data for a signature is added based on the Contents entry of the signature,
//   which is known only after the revision is written. Even if the Contents
//   are known (e.g. when signing externally), updating the DSS at that point
//   would invalidate the calculated signature. As a result, if adding LTV
//   in the same revision is a requirement, use the first method.
//   See LTV.EnableChain.
// The client applies both methods, when possible.
//
// If `LTV.SkipExisting` is set to true (the default), validations are
// not added for signatures which are already present in the VRI entry of the
// document's DSS dictionary.
type LTV struct {

	// CertClient is the client used to retrieve certificates.
	CertClient *_db.CertClient

	// OCSPClient is the client used to retrieve OCSP validation information.
	OCSPClient *_db.OCSPClient

	// CRLClient is the client used to retrieve CRL validation information.
	CRLClient *_db.CRLClient

	// SkipExisting specifies whether existing signature validations
	// should be skipped.
	SkipExisting bool
	_cgbeg       *PdfAppender
	_aageb       *DSS
}

// SetDocInfo set document info.
// This will overwrite any globally declared document info.
func (_aegga *PdfWriter) SetDocInfo(info *PdfInfo) {
	if _aegga.hasObject(_aegga._egbgf) {
		delete(_aegga._bdadf, _aegga._egbgf)
		delete(_aegga._fefab, _aegga._egbgf)
		for _gcbga, _acacf := range _aegga._gcbcf {
			if _acacf == _aegga._egbgf {
				copy(_aegga._gcbcf[_gcbga:], _aegga._gcbcf[_gcbga+1:])
				_aegga._gcbcf[len(_aegga._gcbcf)-1] = nil
				_aegga._gcbcf = _aegga._gcbcf[:len(_aegga._gcbcf)-1]
				break
			}
		}
	}
	_cfbaf := _fed.PdfIndirectObject{}
	_cfbaf.PdfObject = info.ToPdfObject()
	_aegga._egbgf = &_cfbaf
	_aegga.addObject(&_cfbaf)
}

// PdfAnnotationSound represents Sound annotations.
// (Section 12.5.6.16).
type PdfAnnotationSound struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	Sound _fed.PdfObject
	Name  _fed.PdfObject
}

func (_ddg *PdfReader) newPdfActionFromIndirectObject(_aga *_fed.PdfIndirectObject) (*PdfAction, error) {
	_bgf, _abf := _aga.PdfObject.(*_fed.PdfObjectDictionary)
	if !_abf {
		return nil, _d.Errorf("\u0061\u0063\u0074\u0069\u006f\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u006e\u006f\u0074 \u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020a\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	if model := _ddg._dcfcd.GetModelFromPrimitive(_bgf); model != nil {
		_fab, _ece := model.(*PdfAction)
		if !_ece {
			return nil, _d.Errorf("\u0063\u0061c\u0068\u0065\u0064\u0020\u006d\u006f\u0064\u0065\u006c\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0050\u0044\u0046\u0020\u0061\u0063ti\u006f\u006e")
		}
		return _fab, nil
	}
	_cbc := &PdfAction{}
	_cbc._fa = _aga
	_ddg._dcfcd.Register(_bgf, _cbc)
	if _gbg := _bgf.Get("\u0054\u0079\u0070\u0065"); _gbg != nil {
		_eeg, _gag := _gbg.(*_fed.PdfObjectName)
		if !_gag {
			_fef.Log.Trace("\u0049\u006e\u0063\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069\u0074\u0079\u0021\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0054\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064 \u0062\u0065\u0020\u004e\u0061m\u0065", _gbg)
		} else {
			if *_eeg != "\u0041\u0063\u0074\u0069\u006f\u006e" {
				_fef.Log.Trace("\u0055\u006e\u0073u\u0073\u0070\u0065\u0063t\u0065\u0064\u0020\u0054\u0079\u0070\u0065 \u0021\u003d\u0020\u0041\u0063\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029", *_eeg)
			}
			_cbc.Type = _eeg
		}
	}
	if _cgc := _bgf.Get("\u004e\u0065\u0078\u0074"); _cgc != nil {
		_cbc.Next = _cgc
	}
	if _ecc := _bgf.Get("\u0053"); _ecc != nil {
		_cbc.S = _ecc
	}
	_agf, _fbg := _cbc.S.(*_fed.PdfObjectName)
	if !_fbg {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0053\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0021\u003d\u0020\u006e\u0061\u006d\u0065\u0020\u0028\u0025\u0054\u0029", _cbc.S)
		return nil, _d.Errorf("\u0069\u006e\u0076al\u0069\u0064\u0020\u0053\u0020\u006f\u0062\u006a\u0065c\u0074 \u0074y\u0070e\u0020\u0021\u003d\u0020\u006e\u0061\u006d\u0065\u0020\u0028\u0025\u0054\u0029", _cbc.S)
	}
	_fecf := PdfActionType(_agf.String())
	switch _fecf {
	case ActionTypeGoTo:
		_abg, _fedd := _ddg.newPdfActionGotoFromDict(_bgf)
		if _fedd != nil {
			return nil, _fedd
		}
		_abg.PdfAction = _cbc
		_cbc._fcc = _abg
		return _cbc, nil
	case ActionTypeGoToR:
		_ggd, _cea := _ddg.newPdfActionGotoRFromDict(_bgf)
		if _cea != nil {
			return nil, _cea
		}
		_ggd.PdfAction = _cbc
		_cbc._fcc = _ggd
		return _cbc, nil
	case ActionTypeGoToE:
		_aed, _gec := _ddg.newPdfActionGotoEFromDict(_bgf)
		if _gec != nil {
			return nil, _gec
		}
		_aed.PdfAction = _cbc
		_cbc._fcc = _aed
		return _cbc, nil
	case ActionTypeLaunch:
		_feg, _bffb := _ddg.newPdfActionLaunchFromDict(_bgf)
		if _bffb != nil {
			return nil, _bffb
		}
		_feg.PdfAction = _cbc
		_cbc._fcc = _feg
		return _cbc, nil
	case ActionTypeThread:
		_gfb, _bdd := _ddg.newPdfActionThreadFromDict(_bgf)
		if _bdd != nil {
			return nil, _bdd
		}
		_gfb.PdfAction = _cbc
		_cbc._fcc = _gfb
		return _cbc, nil
	case ActionTypeURI:
		_bgbd, _cedd := _ddg.newPdfActionURIFromDict(_bgf)
		if _cedd != nil {
			return nil, _cedd
		}
		_bgbd.PdfAction = _cbc
		_cbc._fcc = _bgbd
		return _cbc, nil
	case ActionTypeSound:
		_agfc, _aec := _ddg.newPdfActionSoundFromDict(_bgf)
		if _aec != nil {
			return nil, _aec
		}
		_agfc.PdfAction = _cbc
		_cbc._fcc = _agfc
		return _cbc, nil
	case ActionTypeMovie:
		_aef, _dfg := _ddg.newPdfActionMovieFromDict(_bgf)
		if _dfg != nil {
			return nil, _dfg
		}
		_aef.PdfAction = _cbc
		_cbc._fcc = _aef
		return _cbc, nil
	case ActionTypeHide:
		_fg, _dfd := _ddg.newPdfActionHideFromDict(_bgf)
		if _dfd != nil {
			return nil, _dfd
		}
		_fg.PdfAction = _cbc
		_cbc._fcc = _fg
		return _cbc, nil
	case ActionTypeNamed:
		_fgf, _dacb := _ddg.newPdfActionNamedFromDict(_bgf)
		if _dacb != nil {
			return nil, _dacb
		}
		_fgf.PdfAction = _cbc
		_cbc._fcc = _fgf
		return _cbc, nil
	case ActionTypeSubmitForm:
		_ecf, _gbc := _ddg.newPdfActionSubmitFormFromDict(_bgf)
		if _gbc != nil {
			return nil, _gbc
		}
		_ecf.PdfAction = _cbc
		_cbc._fcc = _ecf
		return _cbc, nil
	case ActionTypeResetForm:
		_abc, _aea := _ddg.newPdfActionResetFormFromDict(_bgf)
		if _aea != nil {
			return nil, _aea
		}
		_abc.PdfAction = _cbc
		_cbc._fcc = _abc
		return _cbc, nil
	case ActionTypeImportData:
		_gba, _bca := _ddg.newPdfActionImportDataFromDict(_bgf)
		if _bca != nil {
			return nil, _bca
		}
		_gba.PdfAction = _cbc
		_cbc._fcc = _gba
		return _cbc, nil
	case ActionTypeSetOCGState:
		_gaga, _ege := _ddg.newPdfActionSetOCGStateFromDict(_bgf)
		if _ege != nil {
			return nil, _ege
		}
		_gaga.PdfAction = _cbc
		_cbc._fcc = _gaga
		return _cbc, nil
	case ActionTypeRendition:
		_cdb, _bdf := _ddg.newPdfActionRenditionFromDict(_bgf)
		if _bdf != nil {
			return nil, _bdf
		}
		_cdb.PdfAction = _cbc
		_cbc._fcc = _cdb
		return _cbc, nil
	case ActionTypeTrans:
		_egc, _cbb := _ddg.newPdfActionTransFromDict(_bgf)
		if _cbb != nil {
			return nil, _cbb
		}
		_egc.PdfAction = _cbc
		_cbc._fcc = _egc
		return _cbc, nil
	case ActionTypeGoTo3DView:
		_eccb, _ffaa := _ddg.newPdfActionGoTo3DViewFromDict(_bgf)
		if _ffaa != nil {
			return nil, _ffaa
		}
		_eccb.PdfAction = _cbc
		_cbc._fcc = _eccb
		return _cbc, nil
	case ActionTypeJavaScript:
		_dbe, _aaa := _ddg.newPdfActionJavaScriptFromDict(_bgf)
		if _aaa != nil {
			return nil, _aaa
		}
		_dbe.PdfAction = _cbc
		_cbc._fcc = _dbe
		return _cbc, nil
	}
	_fef.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0049\u0067\u006e\u006f\u0072\u0069\u006eg\u0020u\u006ek\u006eo\u0077\u006e\u0020\u0061\u0063\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0073", _fecf)
	return nil, nil
}

// AddFont adds a font dictionary to the Font resources.
func (_gdbed *PdfPage) AddFont(name _fed.PdfObjectName, font _fed.PdfObject) error {
	if _gdbed.Resources == nil {
		_gdbed.Resources = NewPdfPageResources()
	}
	if _gdbed.Resources.Font == nil {
		_gdbed.Resources.Font = _fed.MakeDict()
	}
	_cfdg, _gebca := _fed.TraceToDirectObject(_gdbed.Resources.Font).(*_fed.PdfObjectDictionary)
	if !_gebca {
		_fef.Log.Debug("\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064 \u0066\u006f\u006et \u0064\u0069\u0063\u0074\u0069\u006fn\u0061\u0072\u0079\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u003a \u0025\u0076", _fed.TraceToDirectObject(_gdbed.Resources.Font))
		return _bb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_cfdg.Set(name, font)
	return nil
}

// PageFromIndirectObject returns the PdfPage and page number for a given indirect object.
func (_aebbc *PdfReader) PageFromIndirectObject(ind *_fed.PdfIndirectObject) (*PdfPage, int, error) {
	if len(_aebbc.PageList) != len(_aebbc._gdac) {
		return nil, 0, _bb.New("\u0070\u0061\u0067\u0065\u0020\u006c\u0069\u0073\u0074\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	for _ebceg, _ebcbe := range _aebbc._gdac {
		if _ebcbe == ind {
			return _aebbc.PageList[_ebceg], _ebceg + 1, nil
		}
	}
	return nil, 0, _bb.New("\u0070\u0061\u0067\u0065\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064")
}

// GetContainingPdfObject implements interface PdfModel.
func (_ga *PdfAction) GetContainingPdfObject() _fed.PdfObject { return _ga._fa }
func (_fdcgc *PdfColorspaceSpecialIndexed) String() string {
	return "\u0049n\u0064\u0065\u0078\u0065\u0064"
}

var _bcceg = false

// GetNumComponents returns the number of color components of the colorspace device.
// Returns 4 for a CMYK32 device.
func (_fcbg *PdfColorspaceDeviceCMYK) GetNumComponents() int { return 4 }

// GetContainingPdfObject implements interface PdfModel.
func (_aagg *PdfAnnotation) GetContainingPdfObject() _fed.PdfObject { return _aagg._ffaab }

// Encrypt encrypts the output file with a specified user/owner password.
func (_dfda *PdfWriter) Encrypt(userPass, ownerPass []byte, options *EncryptOptions) error {
	_faaac := RC4_128bit
	if options != nil {
		_faaac = options.Algorithm
	}
	_bdbgf := _ae.PermOwner
	if options != nil {
		_bdbgf = options.Permissions
	}
	var _fdeda _fec.Filter
	switch _faaac {
	case RC4_128bit:
		_fdeda = _fec.NewFilterV2(16)
	case AES_128bit:
		_fdeda = _fec.NewFilterAESV2()
	case AES_256bit:
		_fdeda = _fec.NewFilterAESV3()
	default:
		return _d.Errorf("\u0075n\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020a\u006cg\u006fr\u0069\u0074\u0068\u006d\u003a\u0020\u0025v", options.Algorithm)
	}
	_ababg, _faffc, _bbbfd := _fed.PdfCryptNewEncrypt(_fdeda, userPass, ownerPass, _bdbgf)
	if _bbbfd != nil {
		return _bbbfd
	}
	_dfda._cbebf = _ababg
	if _faffc.Major != 0 {
		_dfda.SetVersion(_faffc.Major, _faffc.Minor)
	}
	_dfda._fgeef = _faffc.Encrypt
	_dfda._ggbbg = _fed.MakeArray(_fed.MakeHexString(_faffc.ID0), _fed.MakeHexString(_faffc.ID1))
	_ddbdb := _fed.MakeIndirectObject(_faffc.Encrypt)
	_dfda._cfdabb = _ddbdb
	_dfda.addObject(_ddbdb)
	return nil
}

// ToPdfObject returns the PDF representation of the function.
func (_fcgfa *PdfFunctionType4) ToPdfObject() _fed.PdfObject {
	_cefdg := _fcgfa._ebcf
	if _cefdg == nil {
		_fcgfa._ebcf = &_fed.PdfObjectStream{}
		_cefdg = _fcgfa._ebcf
	}
	_bdfdc := _fed.MakeDict()
	_bdfdc.Set("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065", _fed.MakeInteger(4))
	_cggdee := &_fed.PdfObjectArray{}
	for _, _bceggb := range _fcgfa.Domain {
		_cggdee.Append(_fed.MakeFloat(_bceggb))
	}
	_bdfdc.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _cggdee)
	_bedd := &_fed.PdfObjectArray{}
	for _, _cebde := range _fcgfa.Range {
		_bedd.Append(_fed.MakeFloat(_cebde))
	}
	_bdfdc.Set("\u0052\u0061\u006eg\u0065", _bedd)
	if _fcgfa._gcdfd == nil && _fcgfa.Program != nil {
		_fcgfa._gcdfd = []byte(_fcgfa.Program.String())
	}
	_bdfdc.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _fed.MakeInteger(int64(len(_fcgfa._gcdfd))))
	_cefdg.Stream = _fcgfa._gcdfd
	_cefdg.PdfObjectDictionary = _bdfdc
	return _cefdg
}

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// components. The slice should contain a single PdfObjectFloat element.
func (_ddab *PdfColorspaceSpecialSeparation) ColorFromPdfObjects(objects []_fed.PdfObject) (PdfColor, error) {
	if len(objects) != 1 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_cbcaa, _bgga := _fed.GetNumbersAsFloat(objects)
	if _bgga != nil {
		return nil, _bgga
	}
	return _ddab.ColorFromFloats(_cbcaa)
}

// ToPdfObject implements interface PdfModel.
func (_deb *PdfActionLaunch) ToPdfObject() _fed.PdfObject {
	_deb.PdfAction.ToPdfObject()
	_bce := _deb._fa
	_edc := _bce.PdfObject.(*_fed.PdfObjectDictionary)
	_edc.SetIfNotNil("\u0053", _fed.MakeName(string(ActionTypeLaunch)))
	if _deb.F != nil {
		_edc.Set("\u0046", _deb.F.ToPdfObject())
	}
	_edc.SetIfNotNil("\u0057\u0069\u006e", _deb.Win)
	_edc.SetIfNotNil("\u004d\u0061\u0063", _deb.Mac)
	_edc.SetIfNotNil("\u0055\u006e\u0069\u0078", _deb.Unix)
	_edc.SetIfNotNil("\u004ee\u0077\u0057\u0069\u006e\u0064\u006fw", _deb.NewWindow)
	return _bce
}

// Add appends an outline item as a child of the current outline item.
func (_fbfcg *OutlineItem) Add(item *OutlineItem) { _fbfcg.Entries = append(_fbfcg.Entries, item) }
func _adba(_ffac _fed.PdfObject) (*PdfColorspaceCalRGB, error) {
	_efeee := NewPdfColorspaceCalRGB()
	if _bffeca, _fceg := _ffac.(*_fed.PdfIndirectObject); _fceg {
		_efeee._edee = _bffeca
	}
	_ffac = _fed.TraceToDirectObject(_ffac)
	_caea, _gggaa := _ffac.(*_fed.PdfObjectArray)
	if !_gggaa {
		return nil, _d.Errorf("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _caea.Len() != 2 {
		return nil, _d.Errorf("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0043\u0061\u006c\u0052G\u0042 \u0063o\u006c\u006f\u0072\u0073\u0070\u0061\u0063e")
	}
	_ffac = _fed.TraceToDirectObject(_caea.Get(0))
	_fffae, _gggaa := _ffac.(*_fed.PdfObjectName)
	if !_gggaa {
		return nil, _d.Errorf("\u0043\u0061l\u0052\u0047\u0042\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0062je\u0063\u0074")
	}
	if *_fffae != "\u0043\u0061\u006c\u0052\u0047\u0042" {
		return nil, _d.Errorf("\u006e\u006f\u0074 a\u0020\u0043\u0061\u006c\u0052\u0047\u0042\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065")
	}
	_ffac = _fed.TraceToDirectObject(_caea.Get(1))
	_ccdb, _gggaa := _ffac.(*_fed.PdfObjectDictionary)
	if !_gggaa {
		return nil, _d.Errorf("\u0043\u0061l\u0052\u0047\u0042\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0062je\u0063\u0074")
	}
	_ffac = _ccdb.Get("\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074")
	_ffac = _fed.TraceToDirectObject(_ffac)
	_adcg, _gggaa := _ffac.(*_fed.PdfObjectArray)
	if !_gggaa {
		return nil, _d.Errorf("\u0043\u0061\u006c\u0052\u0047\u0042\u003a\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0057\u0068\u0069\u0074\u0065\u0050o\u0069\u006e\u0074")
	}
	if _adcg.Len() != 3 {
		return nil, _d.Errorf("\u0043\u0061\u006c\u0052\u0047\u0042\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u0057h\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_ffbc, _gfaf := _adcg.GetAsFloat64Slice()
	if _gfaf != nil {
		return nil, _gfaf
	}
	_efeee.WhitePoint = _ffbc
	_ffac = _ccdb.Get("\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074")
	if _ffac != nil {
		_ffac = _fed.TraceToDirectObject(_ffac)
		_fadb, _cfdb := _ffac.(*_fed.PdfObjectArray)
		if !_cfdb {
			return nil, _d.Errorf("\u0043\u0061\u006c\u0052\u0047\u0042\u003a\u0020\u0049\u006e\u0076a\u006c\u0069\u0064\u0020\u0042\u006c\u0061\u0063\u006b\u0050o\u0069\u006e\u0074")
		}
		if _fadb.Len() != 3 {
			return nil, _d.Errorf("\u0043\u0061\u006c\u0052\u0047\u0042\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u0042l\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074\u0020\u0061\u0072\u0072\u0061\u0079")
		}
		_fged, _abfe := _fadb.GetAsFloat64Slice()
		if _abfe != nil {
			return nil, _abfe
		}
		_efeee.BlackPoint = _fged
	}
	_ffac = _ccdb.Get("\u0047\u0061\u006dm\u0061")
	if _ffac != nil {
		_ffac = _fed.TraceToDirectObject(_ffac)
		_cgbdd, _aabc := _ffac.(*_fed.PdfObjectArray)
		if !_aabc {
			return nil, _d.Errorf("C\u0061\u006c\u0052\u0047B:\u0020I\u006e\u0076\u0061\u006c\u0069d\u0020\u0047\u0061\u006d\u006d\u0061")
		}
		if _cgbdd.Len() != 3 {
			return nil, _d.Errorf("C\u0061\u006c\u0052\u0047\u0042\u003a \u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0047a\u006d\u006d\u0061 \u0061r\u0072\u0061\u0079")
		}
		_gffeg, _fdcf := _cgbdd.GetAsFloat64Slice()
		if _fdcf != nil {
			return nil, _fdcf
		}
		_efeee.Gamma = _gffeg
	}
	_ffac = _ccdb.Get("\u004d\u0061\u0074\u0072\u0069\u0078")
	if _ffac != nil {
		_ffac = _fed.TraceToDirectObject(_ffac)
		_eggcd, _afbf := _ffac.(*_fed.PdfObjectArray)
		if !_afbf {
			return nil, _d.Errorf("\u0043\u0061\u006c\u0052GB\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004d\u0061\u0074\u0072i\u0078")
		}
		if _eggcd.Len() != 9 {
			_fef.Log.Error("\u004d\u0061t\u0072\u0069\u0078 \u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073", _eggcd.String())
			return nil, _d.Errorf("\u0043\u0061\u006c\u0052G\u0042\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u004da\u0074\u0072\u0069\u0078\u0020\u0061\u0072r\u0061\u0079")
		}
		_cffab, _agbe := _eggcd.GetAsFloat64Slice()
		if _agbe != nil {
			return nil, _agbe
		}
		_efeee.Matrix = _cffab
	}
	return _efeee, nil
}
func (_eedee *PdfReader) newPdfActionGotoEFromDict(_ea *_fed.PdfObjectDictionary) (*PdfActionGoToE, error) {
	_dgbc, _ddf := _eec(_ea.Get("\u0046"))
	if _ddf != nil {
		return nil, _ddf
	}
	return &PdfActionGoToE{D: _ea.Get("\u0044"), NewWindow: _ea.Get("\u004ee\u0077\u0057\u0069\u006e\u0064\u006fw"), T: _ea.Get("\u0054"), F: _dgbc}, nil
}

// Set sets the colorspace corresponding to key. Add to Names if not set.
func (_dafaa *PdfPageResourcesColorspaces) Set(key _fed.PdfObjectName, val PdfColorspace) {
	if _, _cadef := _dafaa.Colorspaces[string(key)]; !_cadef {
		_dafaa.Names = append(_dafaa.Names, string(key))
	}
	_dafaa.Colorspaces[string(key)] = val
}

// Optimizer is the interface that performs optimization of PDF object structure for output writing.
//
// Optimize receives a slice of input `objects`, performs optimization, including removing, replacing objects and
// output the optimized slice of objects.
type Optimizer interface {
	Optimize(_dgeed []_fed.PdfObject) ([]_fed.PdfObject, error)
}

func (_cabd *DSS) generateHashMap(_gaab []*_fed.PdfObjectStream) (map[string]*_fed.PdfObjectStream, error) {
	_acdgg := map[string]*_fed.PdfObjectStream{}
	for _, _abadc := range _gaab {
		_fcdda, _bbgc := _fed.DecodeStream(_abadc)
		if _bbgc != nil {
			return nil, _bbgc
		}
		_abebf, _bbgc := _dfebf(_fcdda)
		if _bbgc != nil {
			return nil, _bbgc
		}
		_acdgg[string(_abebf)] = _abadc
	}
	return _acdgg, nil
}
func (_dgf *PdfReader) newPdfAnnotationWidgetFromDict(_faa *_fed.PdfObjectDictionary) (*PdfAnnotationWidget, error) {
	_afe := PdfAnnotationWidget{}
	_afe.H = _faa.Get("\u0048")
	_afe.MK = _faa.Get("\u004d\u004b")
	_afe.A = _faa.Get("\u0041")
	_afe.AA = _faa.Get("\u0041\u0041")
	_afe.BS = _faa.Get("\u0042\u0053")
	_afe.Parent = _faa.Get("\u0050\u0061\u0072\u0065\u006e\u0074")
	return &_afe, nil
}

// PdfShadingType3 is a Radial shading.
type PdfShadingType3 struct {
	*PdfShading
	Coords   *_fed.PdfObjectArray
	Domain   *_fed.PdfObjectArray
	Function []PdfFunction
	Extend   *_fed.PdfObjectArray
}

func _fagef(_dcgf *_fed.PdfObjectDictionary) (*PdfShadingType1, error) {
	_beffd := PdfShadingType1{}
	if _eabgf := _dcgf.Get("\u0044\u006f\u006d\u0061\u0069\u006e"); _eabgf != nil {
		_eabgf = _fed.TraceToDirectObject(_eabgf)
		_acgdf, _gcafc := _eabgf.(*_fed.PdfObjectArray)
		if !_gcafc {
			_fef.Log.Debug("\u0044\u006f\u006d\u0061i\u006e\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _eabgf)
			return nil, _bb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_beffd.Domain = _acgdf
	}
	if _daffc := _dcgf.Get("\u004d\u0061\u0074\u0072\u0069\u0078"); _daffc != nil {
		_daffc = _fed.TraceToDirectObject(_daffc)
		_abff, _bfdaf := _daffc.(*_fed.PdfObjectArray)
		if !_bfdaf {
			_fef.Log.Debug("\u004d\u0061\u0074\u0072i\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _daffc)
			return nil, _bb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_beffd.Matrix = _abff
	}
	_bdfcb := _dcgf.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e")
	if _bdfcb == nil {
		_fef.Log.Debug("\u0052\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0020\u0046\u0075\u006ec\u0074\u0069\u006f\u006e")
		return nil, ErrRequiredAttributeMissing
	}
	_beffd.Function = []PdfFunction{}
	if _dadae, _gcbb := _bdfcb.(*_fed.PdfObjectArray); _gcbb {
		for _, _ecffd := range _dadae.Elements() {
			_cfaad, _cfecb := _bggad(_ecffd)
			if _cfecb != nil {
				_fef.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _cfecb)
				return nil, _cfecb
			}
			_beffd.Function = append(_beffd.Function, _cfaad)
		}
	} else {
		_aegde, _fabag := _bggad(_bdfcb)
		if _fabag != nil {
			_fef.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _fabag)
			return nil, _fabag
		}
		_beffd.Function = append(_beffd.Function, _aegde)
	}
	return &_beffd, nil
}

// NewPdfReader returns a new PdfReader for an input io.ReadSeeker interface. Can be used to read PDF from
// memory or file. Immediately loads and traverses the PDF structure including pages and page contents (if
// not encrypted). Loads entire document structure into memory.
// Alternatively a lazy-loading reader can be created with NewPdfReaderLazy which loads only references,
// and references are loaded from disk into memory on an as-needed basis.
func NewPdfReader(rs _ge.ReadSeeker) (*PdfReader, error) {
	const _fece = "\u006do\u0064e\u006c\u003a\u004e\u0065\u0077P\u0064\u0066R\u0065\u0061\u0064\u0065\u0072"
	return _ecagf(rs, &ReaderOpts{}, false, _fece)
}

// Resample resamples the image data converting from current BitsPerComponent to a target BitsPerComponent
// value.  Sets the image's BitsPerComponent to the target value following resampling.
//
// For example, converting an 8-bit RGB image to 1-bit grayscale (common for scanned images):
//   // Convert RGB image to grayscale.
//   rgbColorSpace := pdf.NewPdfColorspaceDeviceRGB()
//   grayImage, err := rgbColorSpace.ImageToGray(rgbImage)
//   if err != nil {
//     return err
//   }
//   // Resample as 1 bit.
//   grayImage.Resample(1)
func (_cbeeg *Image) Resample(targetBitsPerComponent int64) {
	if _cbeeg.BitsPerComponent == targetBitsPerComponent {
		return
	}
	_acfg := _cbeeg.GetSamples()
	if targetBitsPerComponent < _cbeeg.BitsPerComponent {
		_cffbc := _cbeeg.BitsPerComponent - targetBitsPerComponent
		for _bdfgb := range _acfg {
			_acfg[_bdfgb] >>= uint(_cffbc)
		}
	} else if targetBitsPerComponent > _cbeeg.BitsPerComponent {
		_fgdd := targetBitsPerComponent - _cbeeg.BitsPerComponent
		for _gegf := range _acfg {
			_acfg[_gegf] <<= uint(_fgdd)
		}
	}
	_cbeeg.BitsPerComponent = targetBitsPerComponent
	if _cbeeg.BitsPerComponent < 8 {
		_cbeeg.resampleLowBits(_acfg)
		return
	}
	_cebbf := _eede.BytesPerLine(int(_cbeeg.Width), int(_cbeeg.BitsPerComponent), _cbeeg.ColorComponents)
	_babae := make([]byte, _cebbf*int(_cbeeg.Height))
	var (
		_dgcde, _eafd, _fgcb, _ebcef int
		_ebag                        uint32
	)
	for _fgcb = 0; _fgcb < int(_cbeeg.Height); _fgcb++ {
		_dgcde = _fgcb * _cebbf
		_eafd = (_fgcb+1)*_cebbf - 1
		_dbec := _bba.ResampleUint32(_acfg[_dgcde:_eafd], int(targetBitsPerComponent), 8)
		for _ebcef, _ebag = range _dbec {
			_babae[_ebcef+_dgcde] = byte(_ebag)
		}
	}
	_cbeeg.Data = _babae
}
func _cegdb(_abadd _fed.PdfObject) (*fontFile, error) {
	_fef.Log.Trace("\u006e\u0065\u0077\u0046\u006f\u006e\u0074\u0046\u0069\u006c\u0065\u0046\u0072\u006f\u006dP\u0064f\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u006f\u0062\u006a\u003d\u0025\u0073", _abadd)
	_bebg := &fontFile{}
	_abadd = _fed.TraceToDirectObject(_abadd)
	_aacaf, _bgeb := _abadd.(*_fed.PdfObjectStream)
	if !_bgeb {
		_fef.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020F\u006f\u006et\u0046\u0069\u006c\u0065\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0028\u0025\u0054\u0029", _abadd)
		return nil, _fed.ErrTypeError
	}
	_acdee := _aacaf.PdfObjectDictionary
	_ebdb, _abdg := _fed.DecodeStream(_aacaf)
	if _abdg != nil {
		return nil, _abdg
	}
	_egfd, _bgeb := _fed.GetNameVal(_acdee.Get("\u0053u\u0062\u0074\u0079\u0070\u0065"))
	if !_bgeb {
		_bebg._egeeg = _egfd
		if _egfd == "\u0054\u0079\u0070\u0065\u0031\u0043" {
			_fef.Log.Debug("T\u0079\u0070\u0065\u0031\u0043\u0020\u0066\u006f\u006e\u0074\u0073\u0020\u0061\u0072\u0065\u0020\u0063\u0075r\u0072\u0065\u006e\u0074\u006c\u0079\u0020\u006e\u006f\u0074 s\u0075\u0070\u0070o\u0072t\u0065\u0064")
			return nil, ErrType1CFontNotSupported
		}
	}
	_cebda, _ := _fed.GetIntVal(_acdee.Get("\u004ce\u006e\u0067\u0074\u0068\u0031"))
	_adbdb, _ := _fed.GetIntVal(_acdee.Get("\u004ce\u006e\u0067\u0074\u0068\u0032"))
	if _cebda > len(_ebdb) {
		_cebda = len(_ebdb)
	}
	if _cebda+_adbdb > len(_ebdb) {
		_adbdb = len(_ebdb) - _cebda
	}
	_bbcfd := _ebdb[:_cebda]
	var _degba []byte
	if _adbdb > 0 {
		_degba = _ebdb[_cebda : _cebda+_adbdb]
	}
	if _cebda > 0 && _adbdb > 0 {
		_gbda := _bebg.loadFromSegments(_bbcfd, _degba)
		if _gbda != nil {
			return nil, _gbda
		}
	}
	return _bebg, nil
}

// NewPdfActionSound returns a new "sound" action.
func NewPdfActionSound() *PdfActionSound {
	_fag := NewPdfAction()
	_fea := &PdfActionSound{}
	_fea.PdfAction = _fag
	_fag.SetContext(_fea)
	return _fea
}

// GetContentStreams returns the content stream as an array of strings.
func (_cgac *PdfPage) GetContentStreams() ([]string, error) {
	_dedd := _cgac.GetContentStreamObjs()
	var _gedgc []string
	for _, _ffbbb := range _dedd {
		_agdg, _bdefb := _dcdfad(_ffbbb)
		if _bdefb != nil {
			return nil, _bdefb
		}
		_gedgc = append(_gedgc, _agdg)
	}
	return _gedgc, nil
}

// GetXObjectFormByName returns the XObjectForm with the specified name from the
// page resources, if it exists.
func (_fabbd *PdfPageResources) GetXObjectFormByName(keyName _fed.PdfObjectName) (*XObjectForm, error) {
	_accfab, _faedc := _fabbd.GetXObjectByName(keyName)
	if _accfab == nil {
		return nil, nil
	}
	if _faedc != XObjectTypeForm {
		return nil, _bb.New("\u006e\u006f\u0074\u0020\u0061\u0020\u0066\u006f\u0072\u006d")
	}
	_dedagf, _febafg := NewXObjectFormFromStream(_accfab)
	if _febafg != nil {
		return nil, _febafg
	}
	return _dedagf, nil
}

// SetContentStream updates the content stream with specified encoding.
// If encoding is null, will use the xform.Filter object or Raw encoding if not set.
func (_dadeg *XObjectForm) SetContentStream(content []byte, encoder _fed.StreamEncoder) error {
	_agdaa := content
	if encoder == nil {
		if _dadeg.Filter != nil {
			encoder = _dadeg.Filter
		} else {
			encoder = _fed.NewRawEncoder()
		}
	}
	_cffga, _ecdff := encoder.EncodeBytes(_agdaa)
	if _ecdff != nil {
		return _ecdff
	}
	_agdaa = _cffga
	_dadeg.Stream = _agdaa
	_dadeg.Filter = encoder
	return nil
}

// NewPdfColorspaceFromPdfObject loads a PdfColorspace from a PdfObject.  Returns an error if there is
// a failure in loading.
func NewPdfColorspaceFromPdfObject(obj _fed.PdfObject) (PdfColorspace, error) {
	var _bffd *_fed.PdfIndirectObject
	var _babe *_fed.PdfObjectName
	var _bddd *_fed.PdfObjectArray
	if _abde, _eadeaa := obj.(*_fed.PdfIndirectObject); _eadeaa {
		_bffd = _abde
	}
	obj = _fed.TraceToDirectObject(obj)
	switch _edgb := obj.(type) {
	case *_fed.PdfObjectArray:
		_bddd = _edgb
	case *_fed.PdfObjectName:
		_babe = _edgb
	}
	if _babe != nil {
		switch *_babe {
		case "\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079":
			return NewPdfColorspaceDeviceGray(), nil
		case "\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B":
			return NewPdfColorspaceDeviceRGB(), nil
		case "\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b":
			return NewPdfColorspaceDeviceCMYK(), nil
		case "\u0050a\u0074\u0074\u0065\u0072\u006e":
			return NewPdfColorspaceSpecialPattern(), nil
		default:
			_fef.Log.Debug("\u0045\u0052\u0052\u004fR\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020c\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065 \u0025\u0073", *_babe)
			return nil, _fbdeg
		}
	}
	if _bddd != nil && _bddd.Len() > 0 {
		var _gadc _fed.PdfObject = _bffd
		if _bffd == nil {
			_gadc = _bddd
		}
		if _cdfd, _bdec := _fed.GetName(_bddd.Get(0)); _bdec {
			switch _cdfd.String() {
			case "\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079":
				if _bddd.Len() == 1 {
					return NewPdfColorspaceDeviceGray(), nil
				}
			case "\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B":
				if _bddd.Len() == 1 {
					return NewPdfColorspaceDeviceRGB(), nil
				}
			case "\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b":
				if _bddd.Len() == 1 {
					return NewPdfColorspaceDeviceCMYK(), nil
				}
			case "\u0043a\u006c\u0047\u0072\u0061\u0079":
				return _fgdbf(_gadc)
			case "\u0043\u0061\u006c\u0052\u0047\u0042":
				return _adba(_gadc)
			case "\u004c\u0061\u0062":
				return _agcd(_gadc)
			case "\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064":
				return _addb(_gadc)
			case "\u0050a\u0074\u0074\u0065\u0072\u006e":
				return _cggde(_gadc)
			case "\u0049n\u0064\u0065\u0078\u0065\u0064":
				return _dbcg(_gadc)
			case "\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006f\u006e":
				return _gbaea(_gadc)
			case "\u0044e\u0076\u0069\u0063\u0065\u004e":
				return _fdag(_gadc)
			default:
				_fef.Log.Debug("A\u0072\u0072\u0061\u0079\u0020\u0077i\u0074\u0068\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u006e\u0061m\u0065:\u0020\u0025\u0073", *_cdfd)
			}
		}
	}
	_fef.Log.Debug("\u0050\u0044\u0046\u0020\u0046i\u006c\u0065\u0020\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0073", obj.String())
	return nil, ErrTypeCheck
}

// ToPdfObject implements interface PdfModel.
func (_aegc *PdfAnnotationProjection) ToPdfObject() _fed.PdfObject {
	_aegc.PdfAnnotation.ToPdfObject()
	_ccgf := _aegc._ffaab
	_ffb := _ccgf.PdfObject.(*_fed.PdfObjectDictionary)
	_aegc.PdfAnnotationMarkup.appendToPdfDictionary(_ffb)
	return _ccgf
}

// ToPdfObject convert PdfInfo to pdf object.
func (_ccec *PdfInfo) ToPdfObject() _fed.PdfObject {
	_faag := _fed.MakeDict()
	_faag.SetIfNotNil("\u0054\u0069\u0074l\u0065", _ccec.Title)
	_faag.SetIfNotNil("\u0041\u0075\u0074\u0068\u006f\u0072", _ccec.Author)
	_faag.SetIfNotNil("\u0053u\u0062\u006a\u0065\u0063\u0074", _ccec.Subject)
	_faag.SetIfNotNil("\u004b\u0065\u0079\u0077\u006f\u0072\u0064\u0073", _ccec.Keywords)
	_faag.SetIfNotNil("\u0043r\u0065\u0061\u0074\u006f\u0072", _ccec.Creator)
	_faag.SetIfNotNil("\u0050\u0072\u006f\u0064\u0075\u0063\u0065\u0072", _ccec.Producer)
	_faag.SetIfNotNil("\u0054r\u0061\u0070\u0070\u0065\u0064", _ccec.Trapped)
	if _ccec.CreationDate != nil {
		_faag.SetIfNotNil("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065", _ccec.CreationDate.ToPdfObject())
	}
	if _ccec.ModifiedDate != nil {
		_faag.SetIfNotNil("\u004do\u0064\u0044\u0061\u0074\u0065", _ccec.ModifiedDate.ToPdfObject())
	}
	for _, _ecgg := range _ccec._debc.Keys() {
		_faag.SetIfNotNil(_ecgg, _ccec._debc.Get(_ecgg))
	}
	return _faag
}

// GetContainingPdfObject returns the container of the pattern object (indirect object).
func (_bdeb *PdfPattern) GetContainingPdfObject() _fed.PdfObject { return _bdeb._fbefb }

// G returns the value of the green component of the color.
func (_cbdda *PdfColorDeviceRGB) G() float64 { return _cbdda[1] }

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_gcfg *PdfShadingType4) ToPdfObject() _fed.PdfObject {
	_gcfg.PdfShading.ToPdfObject()
	_cgadg, _feeaa := _gcfg.getShadingDict()
	if _feeaa != nil {
		_fef.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _gcfg.BitsPerCoordinate != nil {
		_cgadg.Set("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065", _gcfg.BitsPerCoordinate)
	}
	if _gcfg.BitsPerComponent != nil {
		_cgadg.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _gcfg.BitsPerComponent)
	}
	if _gcfg.BitsPerFlag != nil {
		_cgadg.Set("B\u0069\u0074\u0073\u0050\u0065\u0072\u0046\u006c\u0061\u0067", _gcfg.BitsPerFlag)
	}
	if _gcfg.Decode != nil {
		_cgadg.Set("\u0044\u0065\u0063\u006f\u0064\u0065", _gcfg.Decode)
	}
	if _gcfg.Function != nil {
		if len(_gcfg.Function) == 1 {
			_cgadg.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _gcfg.Function[0].ToPdfObject())
		} else {
			_dcgbc := _fed.MakeArray()
			for _, _aaffaf := range _gcfg.Function {
				_dcgbc.Append(_aaffaf.ToPdfObject())
			}
			_cgadg.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _dcgbc)
		}
	}
	return _gcfg._cdcge
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain three elements representing the
// red, green and blue components of the color. The values of the elements
// should be between 0 and 1.
func (_dfbc *PdfColorspaceDeviceRGB) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 3 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_gbcef := vals[0]
	if _gbcef < 0.0 || _gbcef > 1.0 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_adgc := vals[1]
	if _adgc < 0.0 || _adgc > 1.0 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_eggc := vals[2]
	if _eggc < 0.0 || _eggc > 1.0 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_fcba := NewPdfColorDeviceRGB(_gbcef, _adgc, _eggc)
	return _fcba, nil
}

// ColorToRGB converts a CMYK32 color to an RGB color.
func (_fbeg *PdfColorspaceDeviceCMYK) ColorToRGB(color PdfColor) (PdfColor, error) {
	_gdcb, _feba := color.(*PdfColorDeviceCMYK)
	if !_feba {
		_fef.Log.Debug("I\u006e\u0070\u0075\u0074\u0020\u0063o\u006c\u006f\u0072\u0020\u006e\u006f\u0074\u0020\u0064e\u0076\u0069\u0063e\u0020c\u006d\u0079\u006b")
		return nil, _bb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_cec := _gdcb.C()
	_fecbc := _gdcb.M()
	_gbcf := _gdcb.Y()
	_dfae := _gdcb.K()
	_cec = _cec*(1-_dfae) + _dfae
	_fecbc = _fecbc*(1-_dfae) + _dfae
	_gbcf = _gbcf*(1-_dfae) + _dfae
	_ffeb := 1 - _cec
	_gedg := 1 - _fecbc
	_egbf := 1 - _gbcf
	return NewPdfColorDeviceRGB(_ffeb, _gedg, _egbf), nil
}

// Encoder returns the font's text encoder.
func (_aecd *pdfFontSimple) Encoder() _dg.TextEncoder {
	if _aecd._ebcbf != nil {
		return _aecd._ebcbf
	}
	if _aecd._cffd != nil {
		return _aecd._cffd
	}
	_fbef, _ := _dg.NewSimpleTextEncoder("\u0053\u0074a\u006e\u0064\u0061r\u0064\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", nil)
	return _fbef
}

// C returns the value of the C component of the color.
func (_fbggg *PdfColorCalRGB) C() float64 { return _fbggg[2] }

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_gfcdea *PdfShading) ToPdfObject() _fed.PdfObject {
	_dcbbc := _gfcdea._cdcge
	_acedca, _gdgeacg := _gfcdea.getShadingDict()
	if _gdgeacg != nil {
		_fef.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _gfcdea.ShadingType != nil {
		_acedca.Set("S\u0068\u0061\u0064\u0069\u006e\u0067\u0054\u0079\u0070\u0065", _gfcdea.ShadingType)
	}
	if _gfcdea.ColorSpace != nil {
		_acedca.Set("\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065", _gfcdea.ColorSpace.ToPdfObject())
	}
	if _gfcdea.Background != nil {
		_acedca.Set("\u0042\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064", _gfcdea.Background)
	}
	if _gfcdea.BBox != nil {
		_acedca.Set("\u0042\u0042\u006f\u0078", _gfcdea.BBox.ToPdfObject())
	}
	if _gfcdea.AntiAlias != nil {
		_acedca.Set("\u0041n\u0074\u0069\u0041\u006c\u0069\u0061s", _gfcdea.AntiAlias)
	}
	return _dcbbc
}
func (_ebedd *PdfWriter) updateObjectNumbers() {
	_ecedbd := _ebedd.ObjNumOffset
	_faddd := 0
	for _, _fbebc := range _ebedd._gcbcf {
		_ffdc := int64(_faddd + 1 + _ecedbd)
		_fgdcd := true
		if _ebedd._bgeec {
			if _gdbgg, _ccafc := _ebedd._afgcd[_fbebc]; _ccafc {
				_ffdc = _gdbgg
				_fgdcd = false
			}
		}
		switch _debda := _fbebc.(type) {
		case *_fed.PdfIndirectObject:
			_debda.ObjectNumber = _ffdc
			_debda.GenerationNumber = 0
		case *_fed.PdfObjectStream:
			_debda.ObjectNumber = _ffdc
			_debda.GenerationNumber = 0
		case *_fed.PdfObjectStreams:
			_debda.ObjectNumber = _ffdc
			_debda.GenerationNumber = 0
		default:
			_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u0020%\u0054\u0020\u002d\u0020\u0073\u006b\u0069p\u0070\u0069\u006e\u0067", _debda)
			continue
		}
		if _fgdcd {
			_faddd++
		}
	}
	_agegd := func(_ebcc _fed.PdfObject) int64 {
		switch _bcfaef := _ebcc.(type) {
		case *_fed.PdfIndirectObject:
			return _bcfaef.ObjectNumber
		case *_fed.PdfObjectStream:
			return _bcfaef.ObjectNumber
		case *_fed.PdfObjectStreams:
			return _bcfaef.ObjectNumber
		}
		return 0
	}
	_ef.SliceStable(_ebedd._gcbcf, func(_ddae, _gccfe int) bool { return _agegd(_ebedd._gcbcf[_ddae]) < _agegd(_ebedd._gcbcf[_gccfe]) })
}
func _bbed(_bbcbea *PdfAnnotation) (*XObjectForm, *PdfRectangle, error) {
	_gdde, _bfef := _fed.GetDict(_bbcbea.AP)
	if !_bfef {
		return nil, nil, _bb.New("f\u0069\u0065\u006c\u0064\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0041\u0050\u0020d\u0069\u0063\u0074i\u006fn\u0061\u0072\u0079")
	}
	if _gdde == nil {
		return nil, nil, nil
	}
	_fdef, _bfef := _fed.GetArray(_bbcbea.Rect)
	if !_bfef || _fdef.Len() != 4 {
		return nil, nil, _bb.New("\u0072\u0065\u0063t\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064")
	}
	_effea, _gfgc := NewPdfRectangle(*_fdef)
	if _gfgc != nil {
		return nil, nil, _gfgc
	}
	_adea := _fed.TraceToDirectObject(_gdde.Get("\u004e"))
	switch _bbcab := _adea.(type) {
	case *_fed.PdfObjectStream:
		_ggbg := _bbcab
		_gaega, _fffc := NewXObjectFormFromStream(_ggbg)
		return _gaega, _effea, _fffc
	case *_fed.PdfObjectDictionary:
		_cdbc := _bbcab
		_acce, _edca := _fed.GetName(_bbcbea.AS)
		if !_edca {
			return nil, nil, nil
		}
		if _cdbc.Get(*_acce) == nil {
			_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0041\u0053\u0020\u0073\u0074\u0061\u0074\u0065\u0020\u006e\u006f\u0074 \u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064\u0020\u0069\u006e\u0020\u0041\u0050\u0020\u0064\u0069\u0063\u0074\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006eg")
			return nil, nil, nil
		}
		_efbd, _edca := _fed.GetStream(_cdbc.Get(*_acce))
		if !_edca {
			_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055n\u0061\u0062\u006ce \u0074\u006f\u0020\u0061\u0063\u0063e\u0073\u0073\u0020\u0061\u0070\u0070\u0065\u0061\u0072\u0061\u006e\u0063\u0065\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0066\u006f\u0072 \u0025\u0076", _acce)
			return nil, nil, _bb.New("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006d\u0069s\u0073\u0069\u006e\u0067")
		}
		_fdeae, _abfaa := NewXObjectFormFromStream(_efbd)
		return _fdeae, _effea, _abfaa
	}
	_fef.Log.Debug("\u0049\u006e\u0076\u0061li\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0066\u006f\u0072\u0020\u004e\u003a\u0020%\u0054", _adea)
	return nil, nil, _bb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
}

// ReplacePage replaces the original page to a new page.
func (_gacb *PdfAppender) ReplacePage(pageNum int, page *PdfPage) {
	_bgaed := pageNum - 1
	for _gdfa := range _gacb._dce {
		if _gdfa == _bgaed {
			_gab := page.Duplicate()
			_daadc(_gab)
			_gacb._dce[_gdfa] = _gab
		}
	}
}

// PdfColorCalRGB represents a color in the Colorimetric CIE RGB colorspace.
// A, B, C components
// Each component is defined in the range 0.0 - 1.0 where 1.0 is the primary intensity.
type PdfColorCalRGB [3]float64

// IsShading specifies if the pattern is a shading pattern.
func (_dcefc *PdfPattern) IsShading() bool { return _dcefc.PatternType == 2 }

// A returns the value of the A component of the color.
func (_fdea *PdfColorLab) A() float64 { return _fdea[1] }

// NewPdfReaderFromFile creates a new PdfReader from the speficied PDF file.
// If ReaderOpts is nil it will be set to default value from NewReaderOpts.
func NewPdfReaderFromFile(pdfFile string, opts *ReaderOpts) (*PdfReader, *_da.File, error) {
	const _ebaef = "\u006d\u006f\u0064\u0065\u006c\u003a\u004e\u0065\u0077\u0050\u0064f\u0052\u0065\u0061\u0064\u0065\u0072\u0046\u0072\u006f\u006dF\u0069\u006c\u0065"
	_efaag, _bgeab := _da.Open(pdfFile)
	if _bgeab != nil {
		return nil, nil, _bgeab
	}
	_ggdge, _bgeab := _ecagf(_efaag, opts, true, _ebaef)
	if _bgeab != nil {
		_efaag.Close()
		return nil, nil, _bgeab
	}
	return _ggdge, _efaag, nil
}

type pdfCIDFontType0 struct {
	fontCommon
	_beba *_fed.PdfIndirectObject
	_gdeg _dg.TextEncoder

	// Table 117 – Entries in a CIDFont dictionary (page 269)
	// (Required) Dictionary that defines the character collection of the CIDFont.
	// See Table 116.
	CIDSystemInfo *_fed.PdfObjectDictionary

	// Glyph metrics fields (optional).
	DW    _fed.PdfObject
	W     _fed.PdfObject
	DW2   _fed.PdfObject
	W2    _fed.PdfObject
	_dadd map[_dg.CharCode]float64
	_fabb float64
}

func (_ddgf *PdfReader) resolveReference(_ffgbg *_fed.PdfObjectReference) (_fed.PdfObject, bool, error) {
	_gefbg, _bcacg := _ddgf._cdfggf.ObjCache[int(_ffgbg.ObjectNumber)]
	if !_bcacg {
		_fef.Log.Trace("R\u0065\u0061\u0064\u0065r \u004co\u006f\u006b\u0075\u0070\u0020r\u0065\u0066\u003a\u0020\u0025\u0073", _ffgbg)
		_bafbe, _abggc := _ddgf._cdfggf.LookupByReference(*_ffgbg)
		if _abggc != nil {
			return nil, false, _abggc
		}
		_ddgf._cdfggf.ObjCache[int(_ffgbg.ObjectNumber)] = _bafbe
		return _bafbe, false, nil
	}
	return _gefbg, true, nil
}

// PdfTilingPattern is a Tiling pattern that consists of repetitions of a pattern cell with defined intervals.
// It is a type 1 pattern. (PatternType = 1).
// A tiling pattern is represented by a stream object, where the stream content is
// a content stream that describes the pattern cell.
type PdfTilingPattern struct {
	*PdfPattern
	PaintType  *_fed.PdfObjectInteger
	TilingType *_fed.PdfObjectInteger
	BBox       *PdfRectangle
	XStep      *_fed.PdfObjectFloat
	YStep      *_fed.PdfObjectFloat
	Resources  *PdfPageResources
	Matrix     *_fed.PdfObjectArray
}

// ToPdfObject implements interface PdfModel.
func (_daf *PdfActionSetOCGState) ToPdfObject() _fed.PdfObject {
	_daf.PdfAction.ToPdfObject()
	_cde := _daf._fa
	_gb := _cde.PdfObject.(*_fed.PdfObjectDictionary)
	_gb.SetIfNotNil("\u0053", _fed.MakeName(string(ActionTypeSetOCGState)))
	_gb.SetIfNotNil("\u0053\u0074\u0061t\u0065", _daf.State)
	_gb.SetIfNotNil("\u0050\u0072\u0065\u0073\u0065\u0072\u0076\u0065\u0052\u0042", _daf.PreserveRB)
	return _cde
}

// GetContentStreamObjs returns a slice of PDF objects containing the content
// streams of the page.
func (_dfbf *PdfPage) GetContentStreamObjs() []_fed.PdfObject {
	if _dfbf.Contents == nil {
		return nil
	}
	_gaagf := _fed.TraceToDirectObject(_dfbf.Contents)
	if _edcb, _cbba := _gaagf.(*_fed.PdfObjectArray); _cbba {
		return _edcb.Elements()
	}
	return []_fed.PdfObject{_gaagf}
}

// GetColorspaceByName returns the colorspace with the specified name from the page resources.
func (_dfede *PdfPageResources) GetColorspaceByName(keyName _fed.PdfObjectName) (PdfColorspace, bool) {
	_afce, _gbaed := _dfede.GetColorspaces()
	if _gbaed != nil {
		_fef.Log.Debug("\u0045\u0052R\u004f\u0052\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0072\u0061\u0063\u0065: \u0025\u0076", _gbaed)
		return nil, false
	}
	if _afce == nil {
		return nil, false
	}
	_cdeeg, _cdad := _afce.Colorspaces[string(keyName)]
	if !_cdad {
		return nil, false
	}
	return _cdeeg, true
}

// PdfAppender appends new PDF content to an existing PDF document via incremental updates.
type PdfAppender struct {
	_ffcf  _ge.ReadSeeker
	_cgbc  *_fed.PdfParser
	_ccc   *PdfReader
	Reader *PdfReader
	_dce   []*PdfPage
	_eae   *PdfAcroForm
	_bcbe  *DSS
	_cdga  _fed.XrefTable
	_eaa   int64
	_efed  int
	_gdba  []_fed.PdfObject
	_bcgf  map[_fed.PdfObject]struct{}
	_aebf  map[_fed.PdfObject]int64
	_egga  map[_fed.PdfObject]struct{}
	_aded  map[_fed.PdfObject]struct{}
	_edga  int64
	_dfcc  bool
}

// String implements interface PdfObject.
func (_cc *PdfAction) String() string {
	_cga, _cf := _cc.ToPdfObject().(*_fed.PdfIndirectObject)
	if _cf {
		return _d.Sprintf("\u0025\u0054\u003a\u0020\u0025\u0073", _cc._fcc, _cga.PdfObject.String())
	}
	return ""
}

// Write writes out the PDF.
func (_becda *PdfWriter) Write(writer _ge.Writer) error {
	_fef.Log.Trace("\u0057r\u0069\u0074\u0065\u0028\u0029")
	if _becda._aecef != nil {
		_fef.Log.Trace("\u004f\u0075t\u006c\u0069\u006ee\u0054\u0072\u0065\u0065\u003a\u0020\u0025\u002b\u0076", _becda._aecef)
		_fdge := _becda._aecef.ToPdfObject()
		_fef.Log.Trace("\u004fu\u0074\u006c\u0069\u006e\u0065\u0073\u003a\u0020\u0025\u002b\u0076 \u0028\u0025\u0054\u002c\u0020\u0070\u003a\u0025\u0070\u0029", _fdge, _fdge, _fdge)
		_becda._cdefg.Set("\u004f\u0075\u0074\u006c\u0069\u006e\u0065\u0073", _fdge)
		_dfccb := _becda.addObjects(_fdge)
		if _dfccb != nil {
			return _dfccb
		}
	}
	if _becda._cccab != nil {
		_fef.Log.Trace("\u0057r\u0069t\u0069\u006e\u0067\u0020\u0061c\u0072\u006f \u0066\u006f\u0072\u006d\u0073")
		_gccgg := _becda._cccab.ToPdfObject()
		_fef.Log.Trace("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d\u003a\u0020\u0025\u002b\u0076", _gccgg)
		_becda._cdefg.Set("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d", _gccgg)
		_fadacb := _becda.addObjects(_gccgg)
		if _fadacb != nil {
			return _fadacb
		}
	}
	for _bgcbd, _badefc := range _becda._affff {
		if !_becda.hasObject(_bgcbd) {
			_fef.Log.Debug("\u0057\u0041\u0052\u004e\u0020\u0050\u0065n\u0064\u0069\u006eg\u0020\u006f\u0062j\u0065\u0063t\u0020\u0025\u002b\u0076\u0020\u0025T\u0020(%\u0070\u0029\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0061\u0064\u0064\u0065\u0064\u0020\u0066\u006f\u0072\u0020\u0077\u0072\u0069\u0074\u0069\u006e\u0067", _bgcbd, _bgcbd, _bgcbd)
			for _, _ebbac := range _badefc {
				for _, _cdcab := range _ebbac.Keys() {
					_cdcca := _ebbac.Get(_cdcab)
					if _cdcca == _bgcbd {
						_fef.Log.Debug("\u0050e\u006e\u0064i\u006e\u0067\u0020\u006fb\u006a\u0065\u0063t\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0061nd\u0020\u0072\u0065p\u006c\u0061c\u0065\u0064\u0020\u0077\u0069\u0074h\u0020\u006eu\u006c\u006c")
						_ebbac.Set(_cdcab, _fed.MakeNull())
						break
					}
				}
			}
		}
	}
	_becda._cdefg.Set("\u0056e\u0072\u0073\u0069\u006f\u006e", _fed.MakeName(_d.Sprintf("\u0025\u0064\u002e%\u0064", _becda._gbgag, _becda._cccf)))
	_becda.copyObjects()
	if _becda._ggfgb != nil {
		var _bgebe error
		_becda._gcbcf, _bgebe = _becda._ggfgb.Optimize(_becda._gcbcf)
		if _bgebe != nil {
			return _bgebe
		}
		_ffaf := make(map[_fed.PdfObject]struct{}, len(_becda._gcbcf))
		for _, _eaegd := range _becda._gcbcf {
			_ffaf[_eaegd] = struct{}{}
		}
		_becda._bdadf = _ffaf
	}
	_becda._cgdb = _becda._febb
	_becda._adge = _b.NewWriter(writer)
	_ebeae := _becda._gbgag > 1 || (_becda._gbgag == 1 && _becda._cccf > 4)
	if _becda._egdec != nil {
		_ebeae = *_becda._egdec
	}
	_gaagb := make(map[_fed.PdfObject]bool)
	for _, _ecbegg := range _becda._gcbcf {
		if _bbceb, _egcab := _ecbegg.(*_fed.PdfObjectStreams); _egcab {
			_ebeae = true
			for _, _cgfeb := range _bbceb.Elements() {
				_gaagb[_cgfeb] = true
				if _afggg, _acacd := _cgfeb.(*_fed.PdfIndirectObject); _acacd {
					_gaagb[_afggg.PdfObject] = true
				}
			}
		}
	}
	if _ebeae && _becda._gbgag == 1 && _becda._cccf < 5 {
		_becda._cccf = 5
	}
	if _becda._bgeec {
		_becda.writeString("\u000a")
	} else {
		_becda.writeString(_d.Sprintf("\u0025\u0025\u0050D\u0046\u002d\u0025\u0064\u002e\u0025\u0064\u000a", _becda._gbgag, _becda._cccf))
		_becda.writeString("\u0025\u00e2\u00e3\u00cf\u00d3\u000a")
	}
	_becda.updateObjectNumbers()
	_fef.Log.Trace("\u0057\u0072\u0069\u0074\u0069\u006e\u0067\u0020\u0025d\u0020\u006f\u0062\u006a", len(_becda._gcbcf))
	_becda._agbdc = make(map[int]crossReference)
	_becda._agbdc[0] = crossReference{Type: 0, ObjectNumber: 0, Generation: 0xFFFF}
	if _becda._ccabce.ObjectMap != nil {
		for _cabbb, _dddgaf := range _becda._ccabce.ObjectMap {
			if _cabbb == 0 {
				continue
			}
			if _dddgaf.XType == _fed.XrefTypeObjectStream {
				_ebffd := crossReference{Type: 2, ObjectNumber: _dddgaf.OsObjNumber, Index: _dddgaf.OsObjIndex}
				_becda._agbdc[_cabbb] = _ebffd
			}
			if _dddgaf.XType == _fed.XrefTypeTableEntry {
				_agabe := crossReference{Type: 1, ObjectNumber: _dddgaf.ObjectNumber, Offset: _dddgaf.Offset}
				_becda._agbdc[_cabbb] = _agabe
			}
		}
	}
	for _, _gbdfdg := range _becda._gcbcf {
		if _acfaeg := _gaagb[_gbdfdg]; _acfaeg {
			continue
		}
		_efbcc := int64(0)
		switch _edbaf := _gbdfdg.(type) {
		case *_fed.PdfIndirectObject:
			_efbcc = _edbaf.ObjectNumber
		case *_fed.PdfObjectStream:
			_efbcc = _edbaf.ObjectNumber
		case *_fed.PdfObjectStreams:
			_efbcc = _edbaf.ObjectNumber
		default:
			_fef.Log.Debug("\u0045R\u0052\u004fR\u003a\u0020\u0055n\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064\u0020\u0074\u0079\u0070\u0065 \u0069\u006e\u0020\u0077\u0072\u0069\u0074\u0065\u0072\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0054", _gbdfdg)
			return ErrTypeCheck
		}
		if _becda._cbebf != nil && _gbdfdg != _becda._cfdabb {
			_aefbde := _becda._cbebf.Encrypt(_gbdfdg, _efbcc, 0)
			if _aefbde != nil {
				_fef.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067\u0020(%\u0073\u0029", _aefbde)
				return _aefbde
			}
		}
		_becda.writeObject(int(_efbcc), _gbdfdg)
	}
	_facc := _becda._cgdb
	var _cecaa int
	for _gcddf := range _becda._agbdc {
		if _gcddf > _cecaa {
			_cecaa = _gcddf
		}
	}
	if _ebeae {
		_gebdf := _cecaa + 1
		_becda._agbdc[_gebdf] = crossReference{Type: 1, ObjectNumber: _gebdf, Offset: _facc}
		_fcdec := _eb.NewBuffer(nil)
		_abdcb := _fed.MakeArray()
		for _fcgg := 0; _fcgg <= _cecaa; {
			for ; _fcgg <= _cecaa; _fcgg++ {
				_degbe, _fgeea := _becda._agbdc[_fcgg]
				if _fgeea && (!_becda._bgeec || _becda._bgeec && (_degbe.Type == 1 && _degbe.Offset >= _becda._defa || _degbe.Type == 0)) {
					break
				}
			}
			var _cbcea int
			for _cbcea = _fcgg + 1; _cbcea <= _cecaa; _cbcea++ {
				_fcaba, _gegca := _becda._agbdc[_cbcea]
				if _gegca && (!_becda._bgeec || _becda._bgeec && (_fcaba.Type == 1 && _fcaba.Offset > _becda._defa)) {
					continue
				}
				break
			}
			_abdcb.Append(_fed.MakeInteger(int64(_fcgg)), _fed.MakeInteger(int64(_cbcea-_fcgg)))
			for _adcdd := _fcgg; _adcdd < _cbcea; _adcdd++ {
				_ccabb := _becda._agbdc[_adcdd]
				switch _ccabb.Type {
				case 0:
					_f.Write(_fcdec, _f.BigEndian, byte(0))
					_f.Write(_fcdec, _f.BigEndian, uint32(0))
					_f.Write(_fcdec, _f.BigEndian, uint16(0xFFFF))
				case 1:
					_f.Write(_fcdec, _f.BigEndian, byte(1))
					_f.Write(_fcdec, _f.BigEndian, uint32(_ccabb.Offset))
					_f.Write(_fcdec, _f.BigEndian, uint16(_ccabb.Generation))
				case 2:
					_f.Write(_fcdec, _f.BigEndian, byte(2))
					_f.Write(_fcdec, _f.BigEndian, uint32(_ccabb.ObjectNumber))
					_f.Write(_fcdec, _f.BigEndian, uint16(_ccabb.Index))
				}
			}
			_fcgg = _cbcea + 1
		}
		_edafa, _fffdc := _fed.MakeStream(_fcdec.Bytes(), _fed.NewFlateEncoder())
		if _fffdc != nil {
			return _fffdc
		}
		_edafa.ObjectNumber = int64(_gebdf)
		_edafa.PdfObjectDictionary.Set("\u0054\u0079\u0070\u0065", _fed.MakeName("\u0058\u0052\u0065\u0066"))
		_edafa.PdfObjectDictionary.Set("\u0057", _fed.MakeArray(_fed.MakeInteger(1), _fed.MakeInteger(4), _fed.MakeInteger(2)))
		_edafa.PdfObjectDictionary.Set("\u0049\u006e\u0064e\u0078", _abdcb)
		_edafa.PdfObjectDictionary.Set("\u0053\u0069\u007a\u0065", _fed.MakeInteger(int64(_gebdf+1)))
		_edafa.PdfObjectDictionary.Set("\u0049\u006e\u0066\u006f", _becda._egbgf)
		_edafa.PdfObjectDictionary.Set("\u0052\u006f\u006f\u0074", _becda._aeacb)
		if _becda._bgeec && _becda._fcbac > 0 {
			_edafa.PdfObjectDictionary.Set("\u0050\u0072\u0065\u0076", _fed.MakeInteger(_becda._fcbac))
		}
		if _becda._cbebf != nil {
			_edafa.Set("\u0045n\u0063\u0072\u0079\u0070\u0074", _becda._cfdabb)
			_edafa.Set("\u0049\u0044", _becda._ggbbg)
			_fef.Log.Trace("\u0049d\u0073\u003a\u0020\u0025\u0073", _becda._ggbbg)
		}
		_becda.writeObject(int(_edafa.ObjectNumber), _edafa)
	} else {
		_becda.writeString("\u0078\u0072\u0065\u0066\u000d\u000a")
		for _ebfcg := 0; _ebfcg <= _cecaa; {
			for ; _ebfcg <= _cecaa; _ebfcg++ {
				_abcbf, _gaabff := _becda._agbdc[_ebfcg]
				if _gaabff && (!_becda._bgeec || _becda._bgeec && (_abcbf.Type == 1 && _abcbf.Offset >= _becda._defa || _abcbf.Type == 0)) {
					break
				}
			}
			var _ddebd int
			for _ddebd = _ebfcg + 1; _ddebd <= _cecaa; _ddebd++ {
				_cbcbgd, _fabda := _becda._agbdc[_ddebd]
				if _fabda && (!_becda._bgeec || _becda._bgeec && (_cbcbgd.Type == 1 && _cbcbgd.Offset > _becda._defa)) {
					continue
				}
				break
			}
			_fcec := _d.Sprintf("\u0025d\u0020\u0025\u0064\u000d\u000a", _ebfcg, _ddebd-_ebfcg)
			_becda.writeString(_fcec)
			for _ffef := _ebfcg; _ffef < _ddebd; _ffef++ {
				_eggbg := _becda._agbdc[_ffef]
				switch _eggbg.Type {
				case 0:
					_fcec = _d.Sprintf("\u0025\u002e\u0031\u0030\u0064\u0020\u0025\u002e\u0035d\u0020\u0066\u000d\u000a", 0, 65535)
					_becda.writeString(_fcec)
				case 1:
					_fcec = _d.Sprintf("\u0025\u002e\u0031\u0030\u0064\u0020\u0025\u002e\u0035d\u0020\u006e\u000d\u000a", _eggbg.Offset, 0)
					_becda.writeString(_fcec)
				}
			}
			_ebfcg = _ddebd + 1
		}
		_eadad := _fed.MakeDict()
		_eadad.Set("\u0049\u006e\u0066\u006f", _becda._egbgf)
		_eadad.Set("\u0052\u006f\u006f\u0074", _becda._aeacb)
		_eadad.Set("\u0053\u0069\u007a\u0065", _fed.MakeInteger(int64(_cecaa+1)))
		if _becda._bgeec && _becda._fcbac > 0 {
			_eadad.Set("\u0050\u0072\u0065\u0076", _fed.MakeInteger(_becda._fcbac))
		}
		if _becda._cbebf != nil {
			_eadad.Set("\u0045n\u0063\u0072\u0079\u0070\u0074", _becda._cfdabb)
			_eadad.Set("\u0049\u0044", _becda._ggbbg)
			_fef.Log.Trace("\u0049d\u0073\u003a\u0020\u0025\u0073", _becda._ggbbg)
		}
		_becda.writeString("\u0074\u0072\u0061\u0069\u006c\u0065\u0072\u000a")
		_becda.writeString(_eadad.WriteString())
		_becda.writeString("\u000a")
	}
	_dfddb := _d.Sprintf("\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u000a\u0025\u0064\u000a", _facc)
	_becda.writeString(_dfddb)
	_becda.writeString("\u0025\u0025\u0045\u004f\u0046\u000a")
	if _becda._deee == nil {
		_becda._deee = _becda._adge.Flush()
	}
	return _becda._deee
}
func (_adgf *PdfFilespec) getDict() *_fed.PdfObjectDictionary {
	if _abegg, _caeee := _adgf._dfeff.(*_fed.PdfIndirectObject); _caeee {
		_dbdf, _gcdg := _abegg.PdfObject.(*_fed.PdfObjectDictionary)
		if !_gcdg {
			return nil
		}
		return _dbdf
	} else if _cbbee, _afdce := _adgf._dfeff.(*_fed.PdfObjectDictionary); _afdce {
		return _cbbee
	} else {
		_fef.Log.Debug("\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020F\u0069\u006c\u0065\u0073\u0070\u0065\u0063\u0020\u0064\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006f\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064 \u006f\u0062\u006a\u0065\u0063\u0074 \u0074\u0079p\u0065\u0020(\u0025T\u0029", _adgf._dfeff)
		return nil
	}
}

// PdfAnnotationMarkup represents additional fields for mark-up annotations.
// (Section 12.5.6.2 p. 399).
type PdfAnnotationMarkup struct {
	T            _fed.PdfObject
	Popup        *PdfAnnotationPopup
	CA           _fed.PdfObject
	RC           _fed.PdfObject
	CreationDate _fed.PdfObject
	IRT          _fed.PdfObject
	Subj         _fed.PdfObject
	RT           _fed.PdfObject
	IT           _fed.PdfObject
	ExData       _fed.PdfObject
}

// NewLTV returns a new LTV client.
func NewLTV(appender *PdfAppender) (*LTV, error) {
	_afcce := appender.Reader.DSS
	if _afcce == nil {
		_afcce = NewDSS()
	}
	if _acgb := _afcce.generateHashMaps(); _acgb != nil {
		return nil, _acgb
	}
	return &LTV{CertClient: _db.NewCertClient(), OCSPClient: _db.NewOCSPClient(), CRLClient: _db.NewCRLClient(), SkipExisting: true, _cgbeg: appender, _aageb: _afcce}, nil
}
func (_fca *PdfReader) newPdfAnnotationPolyLineFromDict(_fdba *_fed.PdfObjectDictionary) (*PdfAnnotationPolyLine, error) {
	_fcfb := PdfAnnotationPolyLine{}
	_cfa, _eadf := _fca.newPdfAnnotationMarkupFromDict(_fdba)
	if _eadf != nil {
		return nil, _eadf
	}
	_fcfb.PdfAnnotationMarkup = _cfa
	_fcfb.Vertices = _fdba.Get("\u0056\u0065\u0072\u0074\u0069\u0063\u0065\u0073")
	_fcfb.LE = _fdba.Get("\u004c\u0045")
	_fcfb.BS = _fdba.Get("\u0042\u0053")
	_fcfb.IC = _fdba.Get("\u0049\u0043")
	_fcfb.BE = _fdba.Get("\u0042\u0045")
	_fcfb.IT = _fdba.Get("\u0049\u0054")
	_fcfb.Measure = _fdba.Get("\u004de\u0061\u0073\u0075\u0072\u0065")
	return &_fcfb, nil
}

// SetImageHandler sets the image handler used by the package.
func SetImageHandler(imgHandling ImageHandler) { ImageHandling = imgHandling }

// ToPdfObject implements interface PdfModel.
func (_gbgf *PdfAnnotationScreen) ToPdfObject() _fed.PdfObject {
	_gbgf.PdfAnnotation.ToPdfObject()
	_dbbf := _gbgf._ffaab
	_cgab := _dbbf.PdfObject.(*_fed.PdfObjectDictionary)
	_cgab.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u0053\u0063\u0072\u0065\u0065\u006e"))
	_cgab.SetIfNotNil("\u0054", _gbgf.T)
	_cgab.SetIfNotNil("\u004d\u004b", _gbgf.MK)
	_cgab.SetIfNotNil("\u0041", _gbgf.A)
	_cgab.SetIfNotNil("\u0041\u0041", _gbgf.AA)
	return _dbbf
}

// AlphaMap performs mapping of alpha data for transformations. Allows custom filtering of alpha data etc.
func (_dgde *Image) AlphaMap(mapFunc AlphaMapFunc) {
	for _ecgad, _cdgcf := range _dgde._caeaf {
		_dgde._caeaf[_ecgad] = mapFunc(_cdgcf)
	}
}

// SetFontByName sets the font specified by keyName to the given object.
func (_dbad *PdfPageResources) SetFontByName(keyName _fed.PdfObjectName, obj _fed.PdfObject) error {
	if _dbad.Font == nil {
		_dbad.Font = _fed.MakeDict()
	}
	_gaggc, _gcdag := _fed.TraceToDirectObject(_dbad.Font).(*_fed.PdfObjectDictionary)
	if !_gcdag {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006fn\u0061\u0072\u0079\u0021\u0020(\u0067\u006ft\u0020\u0025\u0054\u0029", _fed.TraceToDirectObject(_dbad.Font))
		return _fed.ErrTypeError
	}
	_gaggc.Set(keyName, obj)
	return nil
}

// NewPdfAnnotationPolyLine returns a new polyline annotation.
func NewPdfAnnotationPolyLine() *PdfAnnotationPolyLine {
	_cgb := NewPdfAnnotation()
	_fedad := &PdfAnnotationPolyLine{}
	_fedad.PdfAnnotation = _cgb
	_fedad.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_cgb.SetContext(_fedad)
	return _fedad
}
func _cbgab(_fefcge *XObjectImage) error {
	if _fefcge.SMask == nil {
		return nil
	}
	_dacac, _dcfff := _fefcge.SMask.(*_fed.PdfObjectStream)
	if !_dcfff {
		_fef.Log.Debug("\u0053\u004da\u0073\u006b\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0053\u0074re\u0061\u006d")
		return _fed.ErrTypeError
	}
	_baafe := _dacac.PdfObjectDictionary
	_daaea := _baafe.Get("\u004d\u0061\u0074t\u0065")
	if _daaea == nil {
		return nil
	}
	_bgafd, _dacf := _ccegb(_daaea.(*_fed.PdfObjectArray))
	if _dacf != nil {
		return _dacf
	}
	_efcea := _fed.MakeArrayFromFloats([]float64{_bgafd})
	_baafe.SetIfNotNil("\u004d\u0061\u0074t\u0065", _efcea)
	return nil
}

// DSS represents a Document Security Store dictionary.
// The DSS dictionary contains both global and signature specific validation
// information. The certificates and revocation data in the `Certs`, `OCSPs`,
// and `CRLs` fields can be used to validate any signature in the document.
// Additionally, the VRI entry contains validation data per signature.
// The keys in the VRI entry are calculated as upper(hex(sha1(sig.Contents))).
// The values are VRI dictionaries containing certificates and revocation
// information used for validating a single signature.
// See ETSI TS 102 778-4 V1.1.1 for more information.
type DSS struct {
	_dcaa *_fed.PdfIndirectObject
	Certs []*_fed.PdfObjectStream
	OCSPs []*_fed.PdfObjectStream
	CRLs  []*_fed.PdfObjectStream
	VRI   map[string]*VRI
	_ffga map[string]*_fed.PdfObjectStream
	_bece map[string]*_fed.PdfObjectStream
	_eeag map[string]*_fed.PdfObjectStream
}

// SetPdfKeywords sets the Keywords attribute of the output PDF.
func SetPdfKeywords(keywords string) { _abadca.Lock(); defer _abadca.Unlock(); _acge = keywords }

// GetContext returns a reference to the subshading entry as represented by PdfShadingType1-7.
func (_ccdaa *PdfShading) GetContext() PdfModel { return _ccdaa._cebded }

// ToPdfObject implements interface PdfModel.
func (_dfe *PdfActionResetForm) ToPdfObject() _fed.PdfObject {
	_dfe.PdfAction.ToPdfObject()
	_cfe := _dfe._fa
	_bgc := _cfe.PdfObject.(*_fed.PdfObjectDictionary)
	_bgc.SetIfNotNil("\u0053", _fed.MakeName(string(ActionTypeResetForm)))
	_bgc.SetIfNotNil("\u0046\u0069\u0065\u006c\u0064\u0073", _dfe.Fields)
	_bgc.SetIfNotNil("\u0046\u006c\u0061g\u0073", _dfe.Flags)
	return _cfe
}

// ToPdfObject implements interface PdfModel.
func (_ecae *PdfAnnotationInk) ToPdfObject() _fed.PdfObject {
	_ecae.PdfAnnotation.ToPdfObject()
	_agd := _ecae._ffaab
	_afea := _agd.PdfObject.(*_fed.PdfObjectDictionary)
	_ecae.PdfAnnotationMarkup.appendToPdfDictionary(_afea)
	_afea.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u0049\u006e\u006b"))
	_afea.SetIfNotNil("\u0049n\u006b\u004c\u0069\u0073\u0074", _ecae.InkList)
	_afea.SetIfNotNil("\u0042\u0053", _ecae.BS)
	return _agd
}

// PdfFunctionType0 uses a sequence of sample values (contained in a stream) to provide an approximation
// for functions whose domains and ranges are bounded. The samples are organized as an m-dimensional
// table in which each entry has n components
type PdfFunctionType0 struct {
	Domain        []float64
	Range         []float64
	NumInputs     int
	NumOutputs    int
	Size          []int
	BitsPerSample int
	Order         int
	Encode        []float64
	Decode        []float64
	_eggab        []byte
	_adfdc        []uint32
	_dacbd        *_fed.PdfObjectStream
}

// SetXObjectByName adds the XObject from the passed in stream to the page resources.
// The added XObject is identified by the specified name.
func (_dggfa *PdfPageResources) SetXObjectByName(keyName _fed.PdfObjectName, stream *_fed.PdfObjectStream) error {
	if _dggfa.XObject == nil {
		_dggfa.XObject = _fed.MakeDict()
	}
	_eaacd := _fed.TraceToDirectObject(_dggfa.XObject)
	_abcfcd, _cfdc := _eaacd.(*_fed.PdfObjectDictionary)
	if !_cfdc {
		_fef.Log.Debug("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0058\u004f\u0062j\u0065\u0063\u0074\u002c\u0020\u0067\u006f\u0074\u0020\u0025T\u002f\u0025\u0054", _dggfa.XObject, _eaacd)
		return _bb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_abcfcd.Set(keyName, stream)
	return nil
}
func (_eaeg *PdfAppender) mergeResources(_gdad, _accf _fed.PdfObject, _cffa map[_fed.PdfObjectName]_fed.PdfObjectName) _fed.PdfObject {
	if _accf == nil && _gdad == nil {
		return nil
	}
	if _accf == nil {
		return _gdad
	}
	_bcebd, _ggaa := _fed.GetDict(_accf)
	if !_ggaa {
		return _gdad
	}
	if _gdad == nil {
		_ebb := _fed.MakeDict()
		_ebb.Merge(_bcebd)
		return _accf
	}
	_edad, _ggaa := _fed.GetDict(_gdad)
	if !_ggaa {
		_fef.Log.Error("\u0045\u0072\u0072or\u0020\u0072\u0065\u0073\u006f\u0075\u0072\u0063\u0065 \u0069s\u0020n\u006ft\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
		_edad = _fed.MakeDict()
	}
	for _, _fbbac := range _bcebd.Keys() {
		if _acag, _cbdc := _cffa[_fbbac]; _cbdc {
			_edad.Set(_acag, _bcebd.Get(_fbbac))
		} else {
			_edad.Set(_fbbac, _bcebd.Get(_fbbac))
		}
	}
	return _edad
}

// NewPdfAnnotationUnderline returns a new text underline annotation.
func NewPdfAnnotationUnderline() *PdfAnnotationUnderline {
	_bbge := NewPdfAnnotation()
	_cee := &PdfAnnotationUnderline{}
	_cee.PdfAnnotation = _bbge
	_cee.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_bbge.SetContext(_cee)
	return _cee
}

// GetNumComponents returns the number of color components (3 for Lab).
func (_abafa *PdfColorLab) GetNumComponents() int { return 3 }

// GetRuneMetrics returns the char metrics for a rune.
// TODO(peterwilliams97) There is nothing callers can do if no CharMetrics are found so we might as
//                       well give them 0 width. There is no need for the bool return.
func (_gfcbg *PdfFont) GetRuneMetrics(r rune) (CharMetrics, bool) {
	_afae := _gfcbg.actualFont()
	if _afae == nil {
		_fef.Log.Debug("ER\u0052\u004fR\u003a\u0020\u0047\u0065\u0074\u0047\u006c\u0079\u0070h\u0043\u0068\u0061\u0072\u004d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u004e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020f\u006fr\u0020\u0066\u006f\u006e\u0074\u0020\u0074\u0079p\u0065=\u0025\u0023T", _gfcbg._gdaa)
		return _geg.CharMetrics{}, false
	}
	if _afcac, _gaefa := _afae.GetRuneMetrics(r); _gaefa {
		return _afcac, true
	}
	if _bcff, _aaff := _gfcbg.GetFontDescriptor(); _aaff == nil && _bcff != nil {
		return _geg.CharMetrics{Wx: _bcff._ffegc}, true
	}
	_fef.Log.Debug("\u0047\u0065\u0074\u0047\u006c\u0079\u0070h\u0043\u0068\u0061r\u004d\u0065\u0074\u0072i\u0063\u0073\u003a\u0020\u004e\u006f\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u0066\u006f\u0072\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _gfcbg)
	return _geg.CharMetrics{}, false
}
func (_dfc *PdfReader) newPdfActionGotoFromDict(_dfef *_fed.PdfObjectDictionary) (*PdfActionGoTo, error) {
	return &PdfActionGoTo{D: _dfef.Get("\u0044")}, nil
}

const (
	FieldFlagClear             FieldFlag = 0
	FieldFlagReadOnly          FieldFlag = 1
	FieldFlagRequired          FieldFlag = (1 << 1)
	FieldFlagNoExport          FieldFlag = (2 << 1)
	FieldFlagNoToggleToOff     FieldFlag = (1 << 14)
	FieldFlagRadio             FieldFlag = (1 << 15)
	FieldFlagPushbutton        FieldFlag = (1 << 16)
	FieldFlagRadiosInUnision   FieldFlag = (1 << 25)
	FieldFlagMultiline         FieldFlag = (1 << 12)
	FieldFlagPassword          FieldFlag = (1 << 13)
	FieldFlagFileSelect        FieldFlag = (1 << 20)
	FieldFlagDoNotScroll       FieldFlag = (1 << 23)
	FieldFlagComb              FieldFlag = (1 << 24)
	FieldFlagRichText          FieldFlag = (1 << 25)
	FieldFlagDoNotSpellCheck   FieldFlag = (1 << 22)
	FieldFlagCombo             FieldFlag = (1 << 17)
	FieldFlagEdit              FieldFlag = (1 << 18)
	FieldFlagSort              FieldFlag = (1 << 19)
	FieldFlagMultiSelect       FieldFlag = (1 << 21)
	FieldFlagCommitOnSelChange FieldFlag = (1 << 26)
)

var _edfa = map[string]struct{}{"\u0057i\u006eA\u006e\u0073\u0069\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067": {}, "\u004d\u0061c\u0052\u006f\u006da\u006e\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067": {}, "\u004d\u0061\u0063\u0045\u0078\u0070\u0065\u0072\u0074\u0045\u006e\u0063o\u0064\u0069\u006e\u0067": {}, "\u0053\u0074a\u006e\u0064\u0061r\u0064\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067": {}}

// String returns a string representation of the field.
func (_bbbaf *PdfField) String() string {
	if _eccbb, _badgf := _bbbaf.ToPdfObject().(*_fed.PdfIndirectObject); _badgf {
		return _d.Sprintf("\u0025\u0054\u003a\u0020\u0025\u0073", _bbbaf._ggbfc, _eccbb.PdfObject.String())
	}
	return ""
}

// ImageToRGB converts an image with samples in Separation CS to an image with samples specified in
// DeviceRGB CS.
func (_eddb *PdfColorspaceSpecialSeparation) ImageToRGB(img Image) (Image, error) {
	_ccdg := _bba.NewReader(img.getBase())
	_affbc := _eede.NewImageBase(int(img.Width), int(img.Height), int(img.BitsPerComponent), _eddb.AlternateSpace.GetNumComponents(), nil, img._caeaf, nil)
	_beccc := _bba.NewWriter(_affbc)
	_dbbfb := _bg.Pow(2, float64(img.BitsPerComponent)) - 1
	_fef.Log.Trace("\u0053\u0065\u0070a\u0072\u0061\u0074\u0069\u006f\u006e\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0073\u0070\u0061\u0063\u0065\u0020\u002d\u003e\u0020\u0054\u006f\u0052\u0047\u0042\u0020\u0063o\u006e\u0076\u0065\u0072\u0073\u0069\u006f\u006e")
	_fef.Log.Trace("\u0054i\u006et\u0054\u0072\u0061\u006e\u0073f\u006f\u0072m\u003a\u0020\u0025\u002b\u0076", _eddb.TintTransform)
	_cbeb := _eddb.AlternateSpace.DecodeArray()
	var (
		_dccgf uint32
		_aefb  error
	)
	for {
		_dccgf, _aefb = _ccdg.ReadSample()
		if _aefb == _ge.EOF {
			break
		}
		if _aefb != nil {
			return img, _aefb
		}
		_aadgg := float64(_dccgf) / _dbbfb
		_daebg, _ffd := _eddb.TintTransform.Evaluate([]float64{_aadgg})
		if _ffd != nil {
			return img, _ffd
		}
		for _bgade, _bfdf := range _daebg {
			_ggeaa := _eede.LinearInterpolate(_bfdf, _cbeb[_bgade*2], _cbeb[_bgade*2+1], 0, 1)
			if _ffd = _beccc.WriteSample(uint32(_ggeaa * _dbbfb)); _ffd != nil {
				return img, _ffd
			}
		}
	}
	return _eddb.AlternateSpace.ImageToRGB(_ddbab(&_affbc))
}

// SetXObjectImageByName adds the provided XObjectImage to the page resources.
// The added XObjectImage is identified by the specified name.
func (_agcdf *PdfPageResources) SetXObjectImageByName(keyName _fed.PdfObjectName, ximg *XObjectImage) error {
	_egbe := ximg.ToPdfObject().(*_fed.PdfObjectStream)
	_bfcef := _agcdf.SetXObjectByName(keyName, _egbe)
	return _bfcef
}

// ColorAt returns the color of the image pixel specified by the x and y coordinates.
func (_febg *Image) ColorAt(x, y int) (_cd.Color, error) {
	_afaf := _eede.BytesPerLine(int(_febg.Width), int(_febg.BitsPerComponent), _febg.ColorComponents)
	switch _febg.ColorComponents {
	case 1:
		return _eede.ColorAtGrayscale(x, y, int(_febg.BitsPerComponent), _afaf, _febg.Data, _febg._ccdge)
	case 3:
		return _eede.ColorAtNRGBA(x, y, int(_febg.Width), _afaf, int(_febg.BitsPerComponent), _febg.Data, _febg._caeaf, _febg._ccdge)
	case 4:
		return _eede.ColorAtCMYK(x, y, int(_febg.Width), _febg.Data, _febg._ccdge)
	}
	_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 i\u006da\u0067\u0065\u002e\u0020\u0025\u0064\u0020\u0063\u006f\u006d\u0070\u006fn\u0065\u006e\u0074\u0073\u002c\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073\u0020\u0070\u0065\u0072 \u0063\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _febg.ColorComponents, _febg.BitsPerComponent)
	return nil, _bb.New("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006d\u0061g\u0065 \u0063\u006f\u006c\u006f\u0072\u0073\u0070a\u0063\u0065")
}

// NewPdfActionHide returns a new "hide" action.
func NewPdfActionHide() *PdfActionHide {
	_acd := NewPdfAction()
	_fbb := &PdfActionHide{}
	_fbb.PdfAction = _acd
	_acd.SetContext(_fbb)
	return _fbb
}

// ReaderOpts defines options for creating PdfReader instances.
type ReaderOpts struct {

	// Password password of the PDF file encryption.
	// Default: empty ("").
	Password string

	// LazyLoad set if the PDF file would be loaded using lazy-loading mode.
	// Default: true.
	LazyLoad bool
}

// PdfShadingType7 is a Tensor-product patch mesh.
type PdfShadingType7 struct {
	*PdfShading
	BitsPerCoordinate *_fed.PdfObjectInteger
	BitsPerComponent  *_fed.PdfObjectInteger
	BitsPerFlag       *_fed.PdfObjectInteger
	Decode            *_fed.PdfObjectArray
	Function          []PdfFunction
}

// ToPdfObject returns colorspace in a PDF object format [name stream]
func (_eedgf *PdfColorspaceICCBased) ToPdfObject() _fed.PdfObject {
	_afbb := &_fed.PdfObjectArray{}
	_afbb.Append(_fed.MakeName("\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064"))
	var _deeb *_fed.PdfObjectStream
	if _eedgf._dceb != nil {
		_deeb = _eedgf._dceb
	} else {
		_deeb = &_fed.PdfObjectStream{}
	}
	_bgff := _fed.MakeDict()
	_bgff.Set("\u004e", _fed.MakeInteger(int64(_eedgf.N)))
	if _eedgf.Alternate != nil {
		_bgff.Set("\u0041l\u0074\u0065\u0072\u006e\u0061\u0074e", _eedgf.Alternate.ToPdfObject())
	}
	if _eedgf.Metadata != nil {
		_bgff.Set("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061", _eedgf.Metadata)
	}
	if _eedgf.Range != nil {
		var _fbcge []_fed.PdfObject
		for _, _geba := range _eedgf.Range {
			_fbcge = append(_fbcge, _fed.MakeFloat(_geba))
		}
		_bgff.Set("\u0052\u0061\u006eg\u0065", _fed.MakeArray(_fbcge...))
	}
	_bgff.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _fed.MakeInteger(int64(len(_eedgf.Data))))
	_deeb.Stream = _eedgf.Data
	_deeb.PdfObjectDictionary = _bgff
	_afbb.Append(_deeb)
	if _eedgf._caga != nil {
		_eedgf._caga.PdfObject = _afbb
		return _eedgf._caga
	}
	return _afbb
}

// ToPdfObject returns a stream object.
func (_fdcbbe *XObjectForm) ToPdfObject() _fed.PdfObject {
	_cbdfd := _fdcbbe._cedfc
	_dgbaa := _cbdfd.PdfObjectDictionary
	if _fdcbbe.Filter != nil {
		_dgbaa = _fdcbbe.Filter.MakeStreamDict()
		_cbdfd.PdfObjectDictionary = _dgbaa
	}
	_dgbaa.Set("\u0054\u0079\u0070\u0065", _fed.MakeName("\u0058O\u0062\u006a\u0065\u0063\u0074"))
	_dgbaa.Set("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u0046\u006f\u0072\u006d"))
	_dgbaa.SetIfNotNil("\u0046\u006f\u0072\u006d\u0054\u0079\u0070\u0065", _fdcbbe.FormType)
	_dgbaa.SetIfNotNil("\u0042\u0042\u006f\u0078", _fdcbbe.BBox)
	_dgbaa.SetIfNotNil("\u004d\u0061\u0074\u0072\u0069\u0078", _fdcbbe.Matrix)
	if _fdcbbe.Resources != nil {
		_dgbaa.SetIfNotNil("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s", _fdcbbe.Resources.ToPdfObject())
	}
	_dgbaa.SetIfNotNil("\u0047\u0072\u006fu\u0070", _fdcbbe.Group)
	_dgbaa.SetIfNotNil("\u0052\u0065\u0066", _fdcbbe.Ref)
	_dgbaa.SetIfNotNil("\u004d\u0065\u0074\u0061\u0044\u0061\u0074\u0061", _fdcbbe.MetaData)
	_dgbaa.SetIfNotNil("\u0050i\u0065\u0063\u0065\u0049\u006e\u0066o", _fdcbbe.PieceInfo)
	_dgbaa.SetIfNotNil("\u004c\u0061\u0073t\u004d\u006f\u0064\u0069\u0066\u0069\u0065\u0064", _fdcbbe.LastModified)
	_dgbaa.SetIfNotNil("\u0053\u0074\u0072u\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074", _fdcbbe.StructParent)
	_dgbaa.SetIfNotNil("\u0053\u0074\u0072\u0075\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074\u0073", _fdcbbe.StructParents)
	_dgbaa.SetIfNotNil("\u004f\u0050\u0049", _fdcbbe.OPI)
	_dgbaa.SetIfNotNil("\u004f\u0043", _fdcbbe.OC)
	_dgbaa.SetIfNotNil("\u004e\u0061\u006d\u0065", _fdcbbe.Name)
	_dgbaa.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _fed.MakeInteger(int64(len(_fdcbbe.Stream))))
	_cbdfd.Stream = _fdcbbe.Stream
	return _cbdfd
}

// SetSamples convert samples to byte-data and sets for the image.
// NOTE: The method resamples the data and this could lead to high memory usage,
// especially on large images. It should be used only when it is not possible
// to work with the image byte data directly.
func (_dagceg *Image) SetSamples(samples []uint32) {
	if _dagceg.BitsPerComponent < 8 {
		samples = _dagceg.samplesAddPadding(samples)
	}
	_gcaa := _bba.ResampleUint32(samples, int(_dagceg.BitsPerComponent), 8)
	_dcde := make([]byte, len(_gcaa))
	for _bdaeb, _ddage := range _gcaa {
		_dcde[_bdaeb] = byte(_ddage)
	}
	_dagceg.Data = _dcde
}

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// components. The slice should contain a single PdfObjectFloat element in
// range 0-1.
func (_bgaef *PdfColorspaceDeviceGray) ColorFromPdfObjects(objects []_fed.PdfObject) (PdfColor, error) {
	if len(objects) != 1 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_bbga, _baba := _fed.GetNumbersAsFloat(objects)
	if _baba != nil {
		return nil, _baba
	}
	return _bgaef.ColorFromFloats(_bbga)
}

// Encoder returns the font's text encoder.
func (_eedab pdfCIDFontType0) Encoder() _dg.TextEncoder { return _eedab._gdeg }
func (_acfae Image) getBase() _eede.ImageBase {
	return _eede.NewImageBase(int(_acfae.Width), int(_acfae.Height), int(_acfae.BitsPerComponent), _acfae.ColorComponents, _acfae.Data, _acfae._caeaf, _acfae._ccdge)
}

// GetNumComponents returns the number of color components of the colorspace device.
// Returns 1 for a grayscale device.
func (_afcfe *PdfColorspaceDeviceGray) GetNumComponents() int { return 1 }

// DecodeArray returns the component range values for the DeviceN colorspace.
// [0 1.0 0 1.0 ...] for each color component.
func (_abbe *PdfColorspaceDeviceN) DecodeArray() []float64 {
	var _bcggg []float64
	for _agcdd := 0; _agcdd < _abbe.GetNumComponents(); _agcdd++ {
		_bcggg = append(_bcggg, 0.0, 1.0)
	}
	return _bcggg
}

// Val returns the color value.
func (_agca *PdfColorDeviceGray) Val() float64 { return float64(*_agca) }

// HasXObjectByName checks if an XObject with a specified keyName is defined.
func (_ccfg *PdfPageResources) HasXObjectByName(keyName _fed.PdfObjectName) bool {
	_bcabf, _ := _ccfg.GetXObjectByName(keyName)
	return _bcabf != nil
}
func (_fgae *LTV) generateVRIKey(_cbabg *PdfSignature) (string, error) {
	_afeaf, _cgbbc := _dfebf(_cbabg.Contents.Bytes())
	if _cgbbc != nil {
		return "", _cgbbc
	}
	return _eed.ToUpper(_gf.EncodeToString(_afeaf)), nil
}

// ToPdfObject implements interface PdfModel.
func (_bfbeg *PdfAnnotationRedact) ToPdfObject() _fed.PdfObject {
	_bfbeg.PdfAnnotation.ToPdfObject()
	_gbga := _bfbeg._ffaab
	_cafa := _gbga.PdfObject.(*_fed.PdfObjectDictionary)
	_bfbeg.PdfAnnotationMarkup.appendToPdfDictionary(_cafa)
	_cafa.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u0052\u0065\u0064\u0061\u0063\u0074"))
	_cafa.SetIfNotNil("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073", _bfbeg.QuadPoints)
	_cafa.SetIfNotNil("\u0049\u0043", _bfbeg.IC)
	_cafa.SetIfNotNil("\u0052\u004f", _bfbeg.RO)
	_cafa.SetIfNotNil("O\u0076\u0065\u0072\u006c\u0061\u0079\u0054\u0065\u0078\u0074", _bfbeg.OverlayText)
	_cafa.SetIfNotNil("\u0052\u0065\u0070\u0065\u0061\u0074", _bfbeg.Repeat)
	_cafa.SetIfNotNil("\u0044\u0041", _bfbeg.DA)
	_cafa.SetIfNotNil("\u0051", _bfbeg.Q)
	return _gbga
}

// PdfOutlineItem represents an outline item dictionary (Table 153 - pp. 376 - 377).
type PdfOutlineItem struct {
	PdfOutlineTreeNode
	Title  *_fed.PdfObjectString
	Parent *PdfOutlineTreeNode
	Prev   *PdfOutlineTreeNode
	Next   *PdfOutlineTreeNode
	Count  *int64
	Dest   _fed.PdfObject
	A      _fed.PdfObject
	SE     _fed.PdfObject
	C      _fed.PdfObject
	F      _fed.PdfObject
	_gafcc *_fed.PdfIndirectObject
}

// NewPdfReaderLazy creates a new PdfReader for `rs` in lazy-loading mode. The difference
// from NewPdfReader is that in lazy-loading mode, objects are only loaded into memory when needed
// rather than entire structure being loaded into memory on reader creation.
// Note that it may make sense to use the lazy-load reader when processing only parts of files,
// rather than loading entire file into memory. Example: splitting a few pages from a large PDF file.
func NewPdfReaderLazy(rs _ge.ReadSeeker) (*PdfReader, error) {
	const _aeeaa = "\u006d\u006f\u0064\u0065l:\u004e\u0065\u0077\u0050\u0064\u0066\u0052\u0065\u0061\u0064\u0065\u0072\u004c\u0061z\u0079"
	return _ecagf(rs, &ReaderOpts{LazyLoad: true}, false, _aeeaa)
}

// GetAlphabet returns a map of the runes in `text` and their frequencies.
func GetAlphabet(text string) map[rune]int {
	_dgbd := map[rune]int{}
	for _, _fcdga := range text {
		_dgbd[_fcdga]++
	}
	return _dgbd
}
func (_dafa *LTV) validateSig(_fcef *PdfSignature) error {
	if _fcef == nil || _fcef.Contents == nil || len(_fcef.Contents.Bytes()) == 0 {
		return _d.Errorf("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065 \u0066\u0069\u0065l\u0064:\u0020\u0025\u0076", _fcef)
	}
	return nil
}
func (_faggg *PdfFunctionType0) processSamples() error {
	_ffgee := _bba.ResampleBytes(_faggg._eggab, _faggg.BitsPerSample)
	_faggg._adfdc = _ffgee
	return nil
}
func (_aca *PdfReader) newPdfAnnotationRedactFromDict(_cbdb *_fed.PdfObjectDictionary) (*PdfAnnotationRedact, error) {
	_gge := PdfAnnotationRedact{}
	_ceg, _bed := _aca.newPdfAnnotationMarkupFromDict(_cbdb)
	if _bed != nil {
		return nil, _bed
	}
	_gge.PdfAnnotationMarkup = _ceg
	_gge.QuadPoints = _cbdb.Get("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073")
	_gge.IC = _cbdb.Get("\u0049\u0043")
	_gge.RO = _cbdb.Get("\u0052\u004f")
	_gge.OverlayText = _cbdb.Get("O\u0076\u0065\u0072\u006c\u0061\u0079\u0054\u0065\u0078\u0074")
	_gge.Repeat = _cbdb.Get("\u0052\u0065\u0070\u0065\u0061\u0074")
	_gge.DA = _cbdb.Get("\u0044\u0041")
	_gge.Q = _cbdb.Get("\u0051")
	return &_gge, nil
}
func _abdga() string {
	_abadca.Lock()
	defer _abadca.Unlock()
	return _d.Sprintf("\u0055\u006e\u0069Do\u0063\u0020\u0076\u0025\u0073\u0020\u0028\u0025\u0073)\u0020-\u0020h\u0074t\u0070\u003a\u002f\u002f\u0075\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f", _aabcd(), "\u0043\u006fm\u006d\u0065\u0072\u0063\u0069\u0061\u006c\u0020\u004c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u002d\u0020\u0042\u0075\u0073\u0069ne\u0073\u0073")
}
func (_fdgbd *PdfSignature) extractChainFromPKCS7() ([]*_fe.Certificate, error) {
	_dedda, _fefba := _de.Parse(_fdgbd.Contents.Bytes())
	if _fefba != nil {
		return nil, _fefba
	}
	return _dedda.Certificates, nil
}
func _abfg(_ebbfa *PdfField, _cdbcb _fed.PdfObject) error {
	switch _ebbfa.GetContext().(type) {
	case *PdfFieldText:
		switch _eceac := _cdbcb.(type) {
		case *_fed.PdfObjectName:
			_fdbge := _eceac
			_fef.Log.Debug("\u0055\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u003a\u0020\u0047\u006f\u0074 \u0056\u0020\u0061\u0073\u0020\u006e\u0061\u006d\u0065\u0020\u002d\u003e\u0020c\u006f\u006e\u0076\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0074\u006f s\u0074\u0072\u0069\u006e\u0067\u0020\u0027\u0025\u0073\u0027", _fdbge.String())
			_ebbfa.V = _fed.MakeEncodedString(_eceac.String(), true)
		case *_fed.PdfObjectString:
			_ebbfa.V = _fed.MakeEncodedString(_eceac.String(), true)
		default:
			_fef.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0056\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u0028\u0025\u0023\u0076\u0029", _eceac, _eceac)
		}
	case *PdfFieldButton:
		switch _cdbcb.(type) {
		case *_fed.PdfObjectName:
			if len(_cdbcb.String()) > 0 {
				_ebbfa.V = _cdbcb
				_ffebf(_ebbfa, _cdbcb)
			}
		case *_fed.PdfObjectString:
			if len(_cdbcb.String()) > 0 {
				_ebbfa.V = _fed.MakeName(_cdbcb.String())
				_ffebf(_ebbfa, _ebbfa.V)
			}
		default:
			_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u004e\u0045\u0058P\u0045\u0043\u0054\u0045\u0044\u0020\u0025\u0073\u0020\u002d>\u0020\u0025\u0076", _ebbfa.PartialName(), _cdbcb)
			_ebbfa.V = _cdbcb
		}
	case *PdfFieldChoice:
		switch _cdbcb.(type) {
		case *_fed.PdfObjectName:
			if len(_cdbcb.String()) > 0 {
				_ebbfa.V = _fed.MakeString(_cdbcb.String())
				_ffebf(_ebbfa, _cdbcb)
			}
		case *_fed.PdfObjectString:
			if len(_cdbcb.String()) > 0 {
				_ebbfa.V = _cdbcb
				_ffebf(_ebbfa, _fed.MakeName(_cdbcb.String()))
			}
		default:
			_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u004e\u0045\u0058P\u0045\u0043\u0054\u0045\u0044\u0020\u0025\u0073\u0020\u002d>\u0020\u0025\u0076", _ebbfa.PartialName(), _cdbcb)
			_ebbfa.V = _cdbcb
		}
	case *PdfFieldSignature:
		_fef.Log.Debug("\u0054\u004f\u0044\u004f\u003a \u0053\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0061\u0070\u0070e\u0061\u0072\u0061\u006e\u0063\u0065\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0079\u0065\u0074\u003a\u0020\u0025\u0073\u002f\u0025v", _ebbfa.PartialName(), _cdbcb)
	}
	return nil
}

// NewPdfAction returns an initialized generic PDF action model.
func NewPdfAction() *PdfAction {
	_cfb := &PdfAction{}
	_cfb._fa = _fed.MakeIndirectObject(_fed.MakeDict())
	return _cfb
}

// ToPdfObject returns the PDF representation of the outline tree node.
func (_gddec *PdfOutlineTreeNode) ToPdfObject() _fed.PdfObject {
	return _gddec.GetContext().ToPdfObject()
}

// DecodeArray returns the range of color component values in CalGray colorspace.
func (_aafc *PdfColorspaceCalGray) DecodeArray() []float64 { return []float64{0.0, 1.0} }

// ToPdfObject implements interface PdfModel.
func (_cdcd *PdfActionMovie) ToPdfObject() _fed.PdfObject {
	_cdcd.PdfAction.ToPdfObject()
	_cbd := _cdcd._fa
	_ced := _cbd.PdfObject.(*_fed.PdfObjectDictionary)
	_ced.SetIfNotNil("\u0053", _fed.MakeName(string(ActionTypeMovie)))
	_ced.SetIfNotNil("\u0041\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e", _cdcd.Annotation)
	_ced.SetIfNotNil("\u0054", _cdcd.T)
	_ced.SetIfNotNil("\u004fp\u0065\u0072\u0061\u0074\u0069\u006fn", _cdcd.Operation)
	return _cbd
}

// FlattenFields flattens the form fields and annotations for the PDF loaded in `pdf` and makes
// non-editable.
// Looks up all widget annotations corresponding to form fields and flattens them by drawing the content
// through the content stream rather than annotations.
// References to flattened annotations will be removed from Page Annots array. For fields the AcroForm entry
// will be emptied.
// When `allannots` is true, all annotations will be flattened. Keep false if want to keep non-form related
// annotations intact.
// When `appgen` is not nil, it will be used to generate appearance streams for the field annotations.
func (_eeeb *PdfReader) FlattenFields(allannots bool, appgen FieldAppearanceGenerator) error {
	return _eeeb.flattenFieldsWithOpts(allannots, appgen, nil)
}

// GenerateXObjectName generates an unused XObject name that can be used for
// adding new XObjects. Uses format XObj1, XObj2, ...
func (_cgaaab *PdfPageResources) GenerateXObjectName() _fed.PdfObjectName {
	_fbca := 1
	for {
		_cfadb := _fed.MakeName(_d.Sprintf("\u0058\u004f\u0062\u006a\u0025\u0064", _fbca))
		if !_cgaaab.HasXObjectByName(*_cfadb) {
			return *_cfadb
		}
		_fbca++
	}
}

// UpdateObject marks `obj` as updated and to be included in the following revision.
func (_adfdb *PdfAppender) UpdateObject(obj _fed.PdfObject) {
	_adfdb.replaceObject(obj, obj)
	if _, _fabd := _adfdb._bcgf[obj]; !_fabd {
		_adfdb._gdba = append(_adfdb._gdba, obj)
		_adfdb._bcgf[obj] = struct{}{}
	}
}

// ToPdfObject returns the PDF representation of the page resources.
func (_befee *PdfPageResources) ToPdfObject() _fed.PdfObject {
	_gcdgc := _befee._fcdee
	_gcdgc.SetIfNotNil("\u0045x\u0074\u0047\u0053\u0074\u0061\u0074e", _befee.ExtGState)
	if _befee._ebfeb != nil {
		_befee.ColorSpace = _befee._ebfeb.ToPdfObject()
	}
	_gcdgc.SetIfNotNil("\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065", _befee.ColorSpace)
	_gcdgc.SetIfNotNil("\u0050a\u0074\u0074\u0065\u0072\u006e", _befee.Pattern)
	_gcdgc.SetIfNotNil("\u0053h\u0061\u0064\u0069\u006e\u0067", _befee.Shading)
	_gcdgc.SetIfNotNil("\u0058O\u0062\u006a\u0065\u0063\u0074", _befee.XObject)
	_gcdgc.SetIfNotNil("\u0046\u006f\u006e\u0074", _befee.Font)
	_gcdgc.SetIfNotNil("\u0050r\u006f\u0063\u0053\u0065\u0074", _befee.ProcSet)
	_gcdgc.SetIfNotNil("\u0050\u0072\u006f\u0070\u0065\u0072\u0074\u0069\u0065\u0073", _befee.Properties)
	return _gcdgc
}

// PdfSignature represents a PDF signature dictionary and is used for signing via form signature fields.
// (Section 12.8, Table 252 - Entries in a signature dictionary p. 475 in PDF32000_2008).
type PdfSignature struct {
	Handler SignatureHandler
	_gccdf  *_fed.PdfIndirectObject

	// Type: Sig/DocTimeStamp
	Type         *_fed.PdfObjectName
	Filter       *_fed.PdfObjectName
	SubFilter    *_fed.PdfObjectName
	Contents     *_fed.PdfObjectString
	Cert         _fed.PdfObject
	ByteRange    *_fed.PdfObjectArray
	Reference    *_fed.PdfObjectArray
	Changes      *_fed.PdfObjectArray
	Name         *_fed.PdfObjectString
	M            *_fed.PdfObjectString
	Location     *_fed.PdfObjectString
	Reason       *_fed.PdfObjectString
	ContactInfo  *_fed.PdfObjectString
	R            *_fed.PdfObjectInteger
	V            *_fed.PdfObjectInteger
	PropBuild    *_fed.PdfObjectDictionary
	PropAuthTime *_fed.PdfObjectInteger
	PropAuthType *_fed.PdfObjectName
}

// GetNumComponents returns the number of color components of the colorspace device.
// Returns 3 for a Lab device.
func (_dcfb *PdfColorspaceLab) GetNumComponents() int { return 3 }

// SetPdfProducer sets the Producer attribute of the output PDF.
func SetPdfProducer(producer string) { _abadca.Lock(); defer _abadca.Unlock(); _dbfc = producer }

// GetNumComponents returns the number of color components.
func (_cfbge *PdfColorspaceICCBased) GetNumComponents() int { return _cfbge.N }
func (_aggd *PdfPage) setContainer(_daafd *_fed.PdfIndirectObject) {
	_daafd.PdfObject = _aggd._bdgge
	_aggd._efbb = _daafd
}

// K returns the value of the key component of the color.
func (_dga *PdfColorDeviceCMYK) K() float64 { return _dga[3] }

// ToPdfObject converts the PdfFont object to its PDF representation.
func (_efea *PdfFont) ToPdfObject() _fed.PdfObject {
	if _efea._gdaa == nil {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0066\u006f\u006e\u0074 \u0063\u006f\u006e\u0074\u0065\u0078\u0074\u0020\u0069\u0073 \u006e\u0069\u006c")
		return _fed.MakeNull()
	}
	return _efea._gdaa.ToPdfObject()
}

// NewPdfFontFromPdfObject loads a PdfFont from the dictionary `fontObj`.  If there is a problem an
// error is returned.
func NewPdfFontFromPdfObject(fontObj _fed.PdfObject) (*PdfFont, error) { return _faab(fontObj, true) }

// Evaluate runs the function on the passed in slice and returns the results.
func (_cdfb *PdfFunctionType2) Evaluate(x []float64) ([]float64, error) {
	if len(x) != 1 {
		_fef.Log.Error("\u004f\u006e\u006c\u0079 o\u006e\u0065\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0061\u006c\u006c\u006f\u0077e\u0064")
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_fgbe := []float64{0.0}
	if _cdfb.C0 != nil {
		_fgbe = _cdfb.C0
	}
	_gcfcd := []float64{1.0}
	if _cdfb.C1 != nil {
		_gcfcd = _cdfb.C1
	}
	var _ggeac []float64
	for _ffbba := 0; _ffbba < len(_fgbe); _ffbba++ {
		_aeafb := _fgbe[_ffbba] + _bg.Pow(x[0], _cdfb.N)*(_gcfcd[_ffbba]-_fgbe[_ffbba])
		_ggeac = append(_ggeac, _aeafb)
	}
	return _ggeac, nil
}
func _cabgbd() string {
	_abadca.Lock()
	defer _abadca.Unlock()
	if len(_cgeda) > 0 {
		return _cgeda
	}
	return "\u0055n\u0069\u0044\u006f\u0063 \u002d\u0020\u0068\u0074\u0074p\u003a/\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069o"
}

// DecodeArray returns the range of color component values in the ICCBased colorspace.
func (_afeg *PdfColorspaceICCBased) DecodeArray() []float64 { return _afeg.Range }

// ToPdfObject implements interface PdfModel.
func (_aadg *PdfAnnotationTrapNet) ToPdfObject() _fed.PdfObject {
	_aadg.PdfAnnotation.ToPdfObject()
	_cgba := _aadg._ffaab
	_gfge := _cgba.PdfObject.(*_fed.PdfObjectDictionary)
	_gfge.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u0054r\u0061\u0070\u004e\u0065\u0074"))
	return _cgba
}
func (_edcfg *PdfReader) loadAnnotations(_adggd _fed.PdfObject) ([]*PdfAnnotation, error) {
	_cdafa, _decgf := _fed.GetArray(_adggd)
	if !_decgf {
		return nil, _d.Errorf("\u0041\u006e\u006e\u006fts\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	var _bbfaf []*PdfAnnotation
	for _, _dbbad := range _cdafa.Elements() {
		_dbbad = _fed.ResolveReference(_dbbad)
		if _, _fdbcf := _dbbad.(*_fed.PdfObjectNull); _fdbcf {
			continue
		}
		_cfcbg, _efgaf := _dbbad.(*_fed.PdfObjectDictionary)
		_daecc, _dddga := _dbbad.(*_fed.PdfIndirectObject)
		if _efgaf {
			_daecc = &_fed.PdfIndirectObject{}
			_daecc.PdfObject = _cfcbg
		} else {
			if !_dddga {
				return nil, _d.Errorf("\u0061\u006eno\u0074\u0061\u0074i\u006f\u006e\u0020\u006eot \u0069n \u0061\u006e\u0020\u0069\u006e\u0064\u0069re\u0063\u0074\u0020\u006f\u0062\u006a\u0065c\u0074")
			}
		}
		_aaab, _bgbfa := _edcfg.newPdfAnnotationFromIndirectObject(_daecc)
		if _bgbfa != nil {
			return nil, _bgbfa
		}
		switch _becag := _aaab.GetContext().(type) {
		case *PdfAnnotationWidget:
			for _, _bfcf := range _edcfg.AcroForm.AllFields() {
				if _bfcf._cbaae == _becag.Parent {
					_becag._eagb = _bfcf
					break
				}
			}
		}
		if _aaab != nil {
			_bbfaf = append(_bbfaf, _aaab)
		}
	}
	return _bbfaf, nil
}
func (_bbeb *PdfReader) newPdfAnnotationTrapNetFromDict(_dbbd *_fed.PdfObjectDictionary) (*PdfAnnotationTrapNet, error) {
	_ddde := PdfAnnotationTrapNet{}
	return &_ddde, nil
}
func _ggfga(_gdgff []*_fed.PdfObjectStream) *_fed.PdfObjectArray {
	if len(_gdgff) == 0 {
		return nil
	}
	_dgcgbf := make([]_fed.PdfObject, 0, len(_gdgff))
	for _, _cebfaf := range _gdgff {
		_dgcgbf = append(_dgcgbf, _cebfaf)
	}
	return _fed.MakeArray(_dgcgbf...)
}

// SetShadingByName sets a shading resource specified by keyName.
func (_eaedc *PdfPageResources) SetShadingByName(keyName _fed.PdfObjectName, shadingObj _fed.PdfObject) error {
	if _eaedc.Shading == nil {
		_eaedc.Shading = _fed.MakeDict()
	}
	_gbbf, _ggfd := _eaedc.Shading.(*_fed.PdfObjectDictionary)
	if !_ggfd {
		return _fed.ErrTypeError
	}
	_gbbf.Set(keyName, shadingObj)
	return nil
}

// CharcodeBytesToUnicode converts PDF character codes `data` to a Go unicode string.
//
// 9.10 Extraction of Text Content (page 292)
// The process of finding glyph descriptions in OpenType fonts by a conforming reader shall be the following:
// • For Type 1 fonts using “CFF” tables, the process shall be as described in 9.6.6.2, "Encodings
//   for Type 1 Fonts".
// • For TrueType fonts using “glyf” tables, the process shall be as described in 9.6.6.4,
//   "Encodings for TrueType Fonts". Since this process sometimes produces ambiguous results,
//   conforming writers, instead of using a simple font, shall use a Type 0 font with an Identity-H
//   encoding and use the glyph indices as character codes, as described following Table 118.
func (_begb *PdfFont) CharcodeBytesToUnicode(data []byte) (string, int, int) {
	_cfegd, _, _gdga := _begb.CharcodesToUnicodeWithStats(_begb.BytesToCharcodes(data))
	_bbgad := _dg.ExpandLigatures(_cfegd)
	return _bbgad, _eg.RuneCountInString(_bbgad), _gdga
}

// PdfColorDeviceGray represents a grayscale color value that shall be represented by a single number in the
// range 0.0 to 1.0 where 0.0 corresponds to black and 1.0 to white.
type PdfColorDeviceGray float64

// GetCharMetrics returns the char metrics for character code `code`.
func (_fdbaafa pdfCIDFontType2) GetCharMetrics(code _dg.CharCode) (_geg.CharMetrics, bool) {
	if _ffdff, _eeebg := _fdbaafa._faabg[code]; _eeebg {
		return _geg.CharMetrics{Wx: _ffdff}, true
	}
	_cbee := rune(code)
	_fbfee, _egdg := _fdbaafa._bbff[_cbee]
	if !_egdg {
		_fbfee = int(_fdbaafa._bcedd)
	}
	return _geg.CharMetrics{Wx: float64(_fbfee)}, true
}
func (_dagg *LTV) buildCertChain(_abcac, _agdf []*_fe.Certificate) ([]*_fe.Certificate, map[string]*_fe.Certificate, error) {
	_bdbg := map[string]*_fe.Certificate{}
	for _, _gbbgf := range _abcac {
		_bdbg[_gbbgf.Subject.CommonName] = _gbbgf
	}
	_dbgab := _abcac
	for _, _gfcbb := range _agdf {
		_bdfga := _gfcbb.Subject.CommonName
		if _, _bfabc := _bdbg[_bdfga]; _bfabc {
			continue
		}
		_bdbg[_bdfga] = _gfcbb
		_dbgab = append(_dbgab, _gfcbb)
	}
	if len(_dbgab) == 0 {
		return nil, nil, ErrSignNoCertificates
	}
	var _eecb error
	for _bgffd := _dbgab[0]; _bgffd != nil && !_dagg.CertClient.IsCA(_bgffd); {
		_bggg, _bacdc := _bdbg[_bgffd.Issuer.CommonName]
		if !_bacdc {
			if _bggg, _eecb = _dagg.CertClient.GetIssuer(_bgffd); _eecb != nil {
				_fef.Log.Debug("W\u0041\u0052\u004e\u003a\u0020\u0043\u006f\u0075\u006cd\u0020\u006e\u006f\u0074\u0020\u0072\u0065tr\u0069\u0065\u0076\u0065 \u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061te\u0020\u0069s\u0073\u0075\u0065\u0072\u003a\u0020\u0025\u0076", _eecb)
				break
			}
			_bdbg[_bgffd.Issuer.CommonName] = _bggg
			_dbgab = append(_dbgab, _bggg)
		}
		_bgffd = _bggg
	}
	return _dbgab, _bdbg, nil
}

// NewPdfAnnotationRedact returns a new redact annotation.
func NewPdfAnnotationRedact() *PdfAnnotationRedact {
	_geb := NewPdfAnnotation()
	_egca := &PdfAnnotationRedact{}
	_egca.PdfAnnotation = _geb
	_egca.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_geb.SetContext(_egca)
	return _egca
}
func (_abfb *PdfReader) newPdfActionSetOCGStateFromDict(_cgdd *_fed.PdfObjectDictionary) (*PdfActionSetOCGState, error) {
	return &PdfActionSetOCGState{State: _cgdd.Get("\u0053\u0074\u0061t\u0065"), PreserveRB: _cgdd.Get("\u0050\u0072\u0065\u0073\u0065\u0072\u0076\u0065\u0052\u0042")}, nil
}

// Sign signs a specific page with a digital signature.
// The signature field parameter must have a valid signature dictionary
// specified by its V field.
func (_gbce *PdfAppender) Sign(pageNum int, field *PdfFieldSignature) error {
	if field == nil {
		return _bb.New("\u0073\u0069g\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065 n\u0069\u006c")
	}
	_ecca := field.V
	if _ecca == nil {
		return _bb.New("\u0073\u0069\u0067na\u0074\u0075\u0072\u0065\u0020\u0064\u0069\u0063\u0074i\u006fn\u0061r\u0079 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c")
	}
	_gdfc := pageNum - 1
	if _gdfc < 0 || _gdfc > len(_gbce._dce)-1 {
		return _d.Errorf("\u0070\u0061\u0067\u0065\u0020\u0025\u0064\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064", pageNum)
	}
	_bfcb := _gbce.Reader.PageList[_gdfc]
	field.P = _bfcb.ToPdfObject()
	if field.T == nil || field.T.String() == "" {
		field.T = _fed.MakeString(_d.Sprintf("\u0053\u0069\u0067n\u0061\u0074\u0075\u0072\u0065\u0020\u0025\u0064", pageNum))
	}
	_bfcb.AddAnnotation(field.PdfAnnotationWidget.PdfAnnotation)
	if _gbce._eae == _gbce._ccc.AcroForm {
		_gbce._eae = _gbce.Reader.AcroForm
	}
	_ffbb := _gbce._eae
	if _ffbb == nil {
		_ffbb = NewPdfAcroForm()
	}
	_ffbb.SigFlags = _fed.MakeInteger(3)
	_feef := append(_ffbb.AllFields(), field.PdfField)
	_ffbb.Fields = &_feef
	_gbce.ReplaceAcroForm(_ffbb)
	_gbce.UpdatePage(_bfcb)
	_gbce._dce[_gdfc] = _bfcb
	return nil
}

// ToPdfObject implements interface PdfModel.
func (_fdgf *PdfActionNamed) ToPdfObject() _fed.PdfObject {
	_fdgf.PdfAction.ToPdfObject()
	_bge := _fdgf._fa
	_dggd := _bge.PdfObject.(*_fed.PdfObjectDictionary)
	_dggd.SetIfNotNil("\u0053", _fed.MakeName(string(ActionTypeNamed)))
	_dggd.SetIfNotNil("\u004e", _fdgf.N)
	return _bge
}

// ToPdfObject implements interface PdfModel.
func (_cdgf *PdfAnnotationPrinterMark) ToPdfObject() _fed.PdfObject {
	_cdgf.PdfAnnotation.ToPdfObject()
	_fege := _cdgf._ffaab
	_efggc := _fege.PdfObject.(*_fed.PdfObjectDictionary)
	_efggc.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("P\u0072\u0069\u006e\u0074\u0065\u0072\u004d\u0061\u0072\u006b"))
	_efggc.SetIfNotNil("\u004d\u004e", _cdgf.MN)
	return _fege
}

// PdfActionGoToR represents a GoToR action.
type PdfActionGoToR struct {
	*PdfAction
	F         *PdfFilespec
	D         _fed.PdfObject
	NewWindow _fed.PdfObject
}

// NewPdfAnnotationScreen returns a new screen annotation.
func NewPdfAnnotationScreen() *PdfAnnotationScreen {
	_bcfa := NewPdfAnnotation()
	_dfgg := &PdfAnnotationScreen{}
	_dfgg.PdfAnnotation = _bcfa
	_bcfa.SetContext(_dfgg)
	return _dfgg
}

// Decrypt decrypts the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful,
// false otherwise.
func (_ffgb *PdfReader) Decrypt(password []byte) (bool, error) {
	_gcgee, _aefff := _ffgb._cdfggf.Decrypt(password)
	if _aefff != nil {
		return false, _aefff
	}
	if !_gcgee {
		return false, nil
	}
	_aefff = _ffgb.loadStructure()
	if _aefff != nil {
		_fef.Log.Debug("\u0045\u0052\u0052OR\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f \u006co\u0061d\u0020s\u0074\u0072\u0075\u0063\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029", _aefff)
		return false, _aefff
	}
	return true, nil
}

// AddPage adds a page to the PDF file. The new page should be an indirect object.
func (_aagba *PdfWriter) AddPage(page *PdfPage) error {
	const _cggca = "\u006d\u006f\u0064el\u003a\u0050\u0064\u0066\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065"
	_daadc(page)
	_cebaa := page.ToPdfObject()
	_fef.Log.Trace("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d")
	_fef.Log.Trace("\u0041p\u0070\u0065\u006e\u0064i\u006e\u0067\u0020\u0074\u006f \u0070a\u0067e\u0020\u006c\u0069\u0073\u0074\u0020\u0025T", _cebaa)
	_edaf, _dabd := _fed.GetIndirect(_cebaa)
	if !_dabd {
		return _bb.New("\u0070\u0061\u0067\u0065\u0020\u0073h\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0069\u006ed\u0069\u0072\u0065\u0063\u0074\u0020\u006fb\u006a\u0065\u0063\u0074")
	}
	_fef.Log.Trace("\u0025\u0073", _edaf)
	_fef.Log.Trace("\u0025\u0073", _edaf.PdfObject)
	_eafeg, _dabd := _fed.GetDict(_edaf.PdfObject)
	if !_dabd {
		return _bb.New("\u0070\u0061\u0067e \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0068o\u0075l\u0064 \u0062e\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079")
	}
	_efdcc, _dabd := _fed.GetName(_eafeg.Get("\u0054\u0079\u0070\u0065"))
	if !_dabd {
		return _d.Errorf("\u0070\u0061\u0067\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054y\u0070\u0065\u0020\u006b\u0065\u0079\u0020\u0077\u0069t\u0068\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u006f\u0066\u0020t\u0079\u0070\u0065\u0020\u006e\u0061m\u0065\u0020\u0028%\u0054\u0029", _eafeg.Get("\u0054\u0079\u0070\u0065"))
	}
	if _efdcc.String() != "\u0050\u0061\u0067\u0065" {
		return _bb.New("\u0066\u0069e\u006c\u0064\u0020\u0054\u0079\u0070\u0065\u0020\u0021\u003d\u0020\u0050\u0061\u0067\u0065\u0020\u0028\u0052\u0065\u0071\u0075\u0069re\u0064\u0029")
	}
	_adgd := []_fed.PdfObjectName{"\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s", "\u004d\u0065\u0064\u0069\u0061\u0042\u006f\u0078", "\u0043r\u006f\u0070\u0042\u006f\u0078", "\u0052\u006f\u0074\u0061\u0074\u0065"}
	_eadfd, _fbdf := _fed.GetIndirect(_eafeg.Get("\u0050\u0061\u0072\u0065\u006e\u0074"))
	_fef.Log.Trace("P\u0061g\u0065\u0020\u0050\u0061\u0072\u0065\u006e\u0074:\u0020\u0025\u0054\u0020(%\u0076\u0029", _eafeg.Get("\u0050\u0061\u0072\u0065\u006e\u0074"), _fbdf)
	for _fbdf {
		_fef.Log.Trace("\u0050a\u0067e\u0020\u0050\u0061\u0072\u0065\u006e\u0074\u003a\u0020\u0025\u0054", _eadfd)
		_cgdab, _cgbec := _fed.GetDict(_eadfd.PdfObject)
		if !_cgbec {
			return _bb.New("i\u006e\u0076\u0061\u006cid\u0020P\u0061\u0072\u0065\u006e\u0074 \u006f\u0062\u006a\u0065\u0063\u0074")
		}
		for _, _bgeafa := range _adgd {
			_fef.Log.Trace("\u0046\u0069\u0065\u006c\u0064\u0020\u0025\u0073", _bgeafa)
			if _eafeg.Get(_bgeafa) != nil {
				_fef.Log.Trace("\u002d \u0070a\u0067\u0065\u0020\u0068\u0061s\u0020\u0061l\u0072\u0065\u0061\u0064\u0079")
				continue
			}
			if _caddg := _cgdab.Get(_bgeafa); _caddg != nil {
				_fef.Log.Trace("\u0049\u006e\u0068\u0065ri\u0074\u0069\u006e\u0067\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0025\u0073", _bgeafa)
				_eafeg.Set(_bgeafa, _caddg)
			}
		}
		_eadfd, _fbdf = _fed.GetIndirect(_cgdab.Get("\u0050\u0061\u0072\u0065\u006e\u0074"))
		_fef.Log.Trace("\u004ee\u0078t\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u003a\u0020\u0025\u0054", _cgdab.Get("\u0050\u0061\u0072\u0065\u006e\u0074"))
	}
	_fef.Log.Trace("\u0054\u0072\u0061\u0076\u0065\u0072\u0073\u0061\u006c \u0064\u006f\u006e\u0065")
	_eafeg.Set("\u0050\u0061\u0072\u0065\u006e\u0074", _aagba._eeafd)
	_edaf.PdfObject = _eafeg
	_cbbaf, _dabd := _fed.GetDict(_aagba._eeafd.PdfObject)
	if !_dabd {
		return _bb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0061g\u0065\u0073\u0020\u006f\u0062\u006a\u0020(\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0029")
	}
	_eecfc, _dabd := _fed.GetArray(_cbbaf.Get("\u004b\u0069\u0064\u0073"))
	if !_dabd {
		return _bb.New("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0050\u0061g\u0065\u0073\u0020\u004b\u0069\u0064\u0073\u0020o\u0062\u006a\u0020\u0028\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072\u0061\u0079\u0029")
	}
	_eecfc.Append(_edaf)
	_aagba._aadcf[_eafeg] = struct{}{}
	_caff, _dabd := _fed.GetInt(_cbbaf.Get("\u0043\u006f\u0075n\u0074"))
	if !_dabd {
		return _bb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064 \u0050\u0061\u0067e\u0073\u0020\u0043\u006fu\u006e\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0029")
	}
	*_caff = *_caff + 1
	if page._fdcd == nil {
		_fggga := _fdg.Track(_aagba._gdgg, _cggca)
		if _fggga != nil {
			return _fggga
		}
	} else {
		_bfced := _fdg.Track(page._fdcd._cfage, _cggca)
		if _bfced != nil {
			return _bfced
		}
	}
	_aagba.addObject(_edaf)
	_fbefa := _aagba.addObjects(_eafeg)
	if _fbefa != nil {
		return _fbefa
	}
	return nil
}

// PdfField contains the common attributes of a form field. The context object contains the specific field data
// which can represent a button, text, choice or signature.
// The PdfField is typically not used directly, but is encapsulated by the more specific field types such as
// PdfFieldButton etc (i.e. the context attribute).
type PdfField struct {
	_ggbfc      PdfModel
	_cbaae      *_fed.PdfIndirectObject
	Parent      *PdfField
	Annotations []*PdfAnnotationWidget
	Kids        []*PdfField
	FT          *_fed.PdfObjectName
	T           *_fed.PdfObjectString
	TU          *_fed.PdfObjectString
	TM          *_fed.PdfObjectString
	Ff          *_fed.PdfObjectInteger
	V           _fed.PdfObject
	DV          _fed.PdfObject
	AA          _fed.PdfObject
}

// PdfAnnotationPolygon represents Polygon annotations.
// (Section 12.5.6.9).
type PdfAnnotationPolygon struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	Vertices _fed.PdfObject
	LE       _fed.PdfObject
	BS       _fed.PdfObject
	IC       _fed.PdfObject
	BE       _fed.PdfObject
	IT       _fed.PdfObject
	Measure  _fed.PdfObject
}

func (_bage *pdfFontType3) getFontDescriptor() *PdfFontDescriptor { return _bage._bgdgb }

// SetFilter sets compression filter. Decodes with current filter sets and
// encodes the data with the new filter.
func (_cggdd *XObjectImage) SetFilter(encoder _fed.StreamEncoder) error {
	_fegeg := _cggdd.Stream
	_fgced, _cegf := _cggdd.Filter.DecodeBytes(_fegeg)
	if _cegf != nil {
		return _cegf
	}
	_cggdd.Filter = encoder
	encoder.UpdateParams(_cggdd.getParamsDict())
	_fegeg, _cegf = encoder.EncodeBytes(_fgced)
	if _cegf != nil {
		return _cegf
	}
	_cggdd.Stream = _fegeg
	return nil
}
func _bfag(_gbagc _fed.PdfObject) (map[_dg.CharCode]float64, error) {
	if _gbagc == nil {
		return nil, nil
	}
	_ffgcc, _eagdf := _fed.GetArray(_gbagc)
	if !_eagdf {
		return nil, nil
	}
	_ddabc := map[_dg.CharCode]float64{}
	_cegbg := _ffgcc.Len()
	for _fbee := 0; _fbee < _cegbg-1; _fbee++ {
		_fgbdg := _fed.TraceToDirectObject(_ffgcc.Get(_fbee))
		_bfbga, _feabd := _fed.GetIntVal(_fgbdg)
		if !_feabd {
			return nil, _d.Errorf("\u0042a\u0064\u0020\u0066\u006fn\u0074\u0020\u0057\u0020\u006fb\u006a0\u003a \u0069\u003d\u0025\u0064\u0020\u0025\u0023v", _fbee, _fgbdg)
		}
		_fbee++
		if _fbee > _cegbg-1 {
			return nil, _d.Errorf("\u0042\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0057\u0020a\u0072\u0072\u0061\u0079\u003a\u0020\u0061\u0072\u0072\u0032=\u0025\u002b\u0076", _ffgcc)
		}
		_fgcd := _fed.TraceToDirectObject(_ffgcc.Get(_fbee))
		switch _fgcd.(type) {
		case *_fed.PdfObjectArray:
			_gbgde, _ := _fed.GetArray(_fgcd)
			if _ccdgc, _bbde := _gbgde.ToFloat64Array(); _bbde == nil {
				for _afefe := 0; _afefe < len(_ccdgc); _afefe++ {
					_ddabc[_dg.CharCode(_bfbga+_afefe)] = _ccdgc[_afefe]
				}
			} else {
				return nil, _d.Errorf("\u0042\u0061\u0064 \u0066\u006f\u006e\u0074 \u0057\u0020\u0061\u0072\u0072\u0061\u0079 \u006f\u0062\u006a\u0031\u003a\u0020\u0069\u003d\u0025\u0064\u0020\u0025\u0023\u0076", _fbee, _fgcd)
			}
		case *_fed.PdfObjectInteger:
			_bbbg, _ecaeb := _fed.GetIntVal(_fgcd)
			if !_ecaeb {
				return nil, _d.Errorf("\u0042\u0061d\u0020\u0066\u006f\u006e\u0074\u0020\u0057\u0020\u0069\u006e\u0074\u0020\u006f\u0062\u006a\u0031\u003a\u0020\u0069\u003d\u0025\u0064 %\u0023\u0076", _fbee, _fgcd)
			}
			_fbee++
			if _fbee > _cegbg-1 {
				return nil, _d.Errorf("\u0042\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0057\u0020a\u0072\u0072\u0061\u0079\u003a\u0020\u0061\u0072\u0072\u0032=\u0025\u002b\u0076", _ffgcc)
			}
			_agda := _ffgcc.Get(_fbee)
			_ddeb, _ebdc := _fed.GetNumberAsFloat(_agda)
			if _ebdc != nil {
				return nil, _d.Errorf("\u0042\u0061d\u0020\u0066\u006f\u006e\u0074\u0020\u0057\u0020\u0069\u006e\u0074\u0020\u006f\u0062\u006a\u0032\u003a\u0020\u0069\u003d\u0025\u0064 %\u0023\u0076", _fbee, _agda)
			}
			for _gada := _bfbga; _gada <= _bbbg; _gada++ {
				_ddabc[_dg.CharCode(_gada)] = _ddeb
			}
		default:
			return nil, _d.Errorf("\u0042\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0057 \u006f\u0062\u006a\u0031\u0020\u0074\u0079p\u0065\u003a\u0020\u0069\u003d\u0025\u0064\u0020\u0025\u0023\u0076", _fbee, _fgcd)
		}
	}
	return _ddabc, nil
}

// ToUnicode returns the name of the font's "ToUnicode" field if there is one, or "" if there isn't.
func (_afgb *PdfFont) ToUnicode() string {
	if _afgb.baseFields()._ecfd == nil {
		return ""
	}
	return _afgb.baseFields()._ecfd.Name()
}

// Normalize swaps (Llx,Urx) if Urx < Llx, and (Lly,Ury) if Ury < Lly.
func (_abegc *PdfRectangle) Normalize() {
	if _abegc.Llx > _abegc.Urx {
		_abegc.Llx, _abegc.Urx = _abegc.Urx, _abegc.Llx
	}
	if _abegc.Lly > _abegc.Ury {
		_abegc.Lly, _abegc.Ury = _abegc.Ury, _abegc.Lly
	}
}

// NewPdfFontFromTTFFile loads a TTF font file and returns a PdfFont type
// that can be used in text styling functions.
// Uses a WinAnsiTextEncoder and loads only character codes 32-255.
// NOTE: For composite fonts such as used in symbolic languages, use NewCompositePdfFontFromTTFFile.
func NewPdfFontFromTTFFile(filePath string) (*PdfFont, error) {
	_cbeg, _gebaa := _da.Open(filePath)
	if _gebaa != nil {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020T\u0054F\u0020\u0066\u006f\u006e\u0074\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0076", _gebaa)
		return nil, _gebaa
	}
	defer _cbeg.Close()
	return NewPdfFontFromTTF(_cbeg)
}

// Initialize initializes the PdfSignature.
func (_gbdd *PdfSignature) Initialize() error {
	if _gbdd.Handler == nil {
		return _bb.New("\u0073\u0069\u0067n\u0061\u0074\u0075\u0072e\u0020\u0068\u0061\u006e\u0064\u006c\u0065r\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c")
	}
	return _gbdd.Handler.InitSignature(_gbdd)
}

// NewPdfAnnotationLine returns a new line annotation.
func NewPdfAnnotationLine() *PdfAnnotationLine {
	_cgeg := NewPdfAnnotation()
	_ged := &PdfAnnotationLine{}
	_ged.PdfAnnotation = _cgeg
	_ged.PdfAnnotationMarkup = &PdfAnnotationMarkup{}
	_cgeg.SetContext(_ged)
	return _ged
}

// ToPdfObject implements interface PdfModel.
func (_cac *PdfActionImportData) ToPdfObject() _fed.PdfObject {
	_cac.PdfAction.ToPdfObject()
	_af := _cac._fa
	_gacg := _af.PdfObject.(*_fed.PdfObjectDictionary)
	_gacg.SetIfNotNil("\u0053", _fed.MakeName(string(ActionTypeImportData)))
	if _cac.F != nil {
		_gacg.Set("\u0046", _cac.F.ToPdfObject())
	}
	return _af
}

// ToPdfObject implements interface PdfModel.
func (_bbab *PdfActionTrans) ToPdfObject() _fed.PdfObject {
	_bbab.PdfAction.ToPdfObject()
	_dd := _bbab._fa
	_acf := _dd.PdfObject.(*_fed.PdfObjectDictionary)
	_acf.SetIfNotNil("\u0053", _fed.MakeName(string(ActionTypeTrans)))
	_acf.SetIfNotNil("\u0054\u0072\u0061n\u0073", _bbab.Trans)
	return _dd
}

// ToImage converts an object to an Image which can be transformed or saved out.
// The image data is decoded and the Image returned.
func (_baaff *XObjectImage) ToImage() (*Image, error) {
	_cebfd := &Image{}
	if _baaff.Height == nil {
		return nil, _bb.New("\u0068e\u0069\u0067\u0068\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062u\u0074\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
	}
	_cebfd.Height = *_baaff.Height
	if _baaff.Width == nil {
		return nil, _bb.New("\u0077\u0069\u0064th\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067")
	}
	_cebfd.Width = *_baaff.Width
	if _baaff.BitsPerComponent == nil {
		switch _baaff.Filter.(type) {
		case *_fed.CCITTFaxEncoder, *_fed.JBIG2Encoder:
			_cebfd.BitsPerComponent = 1
		case *_fed.LZWEncoder, *_fed.RunLengthEncoder:
			_cebfd.BitsPerComponent = 8
		default:
			return nil, _bb.New("\u0062\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006fm\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u006d\u0069\u0073s\u0069\u006e\u0067")
		}
	} else {
		_cebfd.BitsPerComponent = *_baaff.BitsPerComponent
	}
	_cebfd.ColorComponents = _baaff.ColorSpace.GetNumComponents()
	_baaff._agffg.Set("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073", _fed.MakeInteger(int64(_cebfd.ColorComponents)))
	_efagb, _agggae := _fed.DecodeStream(_baaff._agffg)
	if _agggae != nil {
		return nil, _agggae
	}
	_cebfd.Data = _efagb
	if _baaff.Decode != nil {
		_gegada, _ccbe := _baaff.Decode.(*_fed.PdfObjectArray)
		if !_ccbe {
			_fef.Log.Debug("I\u006e\u0076\u0061\u006cid\u0020D\u0065\u0063\u006f\u0064\u0065 \u006f\u0062\u006a\u0065\u0063\u0074")
			return nil, _bb.New("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0074\u0079\u0070\u0065")
		}
		_adbab, _dddfd := _gegada.ToFloat64Array()
		if _dddfd != nil {
			return nil, _dddfd
		}
		_cebfd._ccdge = _adbab
	}
	return _cebfd, nil
}

// String returns a string that describes `font`.
func (_ecagb *PdfFont) String() string {
	_cegb := ""
	if _ecagb._gdaa.Encoder() != nil {
		_cegb = _ecagb._gdaa.Encoder().String()
	}
	return _d.Sprintf("\u0046\u004f\u004e\u0054\u007b\u0025\u0054\u0020\u0025s\u0020\u0025\u0073\u007d", _ecagb._gdaa, _ecagb.baseFields().coreString(), _cegb)
}

// DecodeArray returns the range of color component values in CalRGB colorspace.
func (_ebd *PdfColorspaceCalRGB) DecodeArray() []float64 {
	return []float64{0.0, 1.0, 0.0, 1.0, 0.0, 1.0}
}
func _feggf(_cfded []byte) []byte {
	const _dgafb = 52845
	const _cada = 22719
	_gceed := 55665
	for _, _cffbf := range _cfded[:4] {
		_gceed = (int(_cffbf)+_gceed)*_dgafb + _cada
	}
	_gcacg := make([]byte, len(_cfded)-4)
	for _babgc, _cceaa := range _cfded[4:] {
		_gcacg[_babgc] = byte(int(_cceaa) ^ _gceed>>8)
		_gceed = (int(_cceaa)+_gceed)*_dgafb + _cada
	}
	return _gcacg
}

// PdfPageResources is a Page resources model.
// Implements PdfModel.
type PdfPageResources struct {
	ExtGState  _fed.PdfObject
	ColorSpace _fed.PdfObject
	Pattern    _fed.PdfObject
	Shading    _fed.PdfObject
	XObject    _fed.PdfObject
	Font       _fed.PdfObject
	ProcSet    _fed.PdfObject
	Properties _fed.PdfObject
	_fcdee     *_fed.PdfObjectDictionary
	_ebfeb     *PdfPageResourcesColorspaces
}

// CheckAccessRights checks access rights and permissions for a specified password.  If either user/owner
// password is specified,  full rights are granted, otherwise the access rights are specified by the
// Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_dafaf *PdfReader) CheckAccessRights(password []byte) (bool, _ae.Permissions, error) {
	return _dafaf._cdfggf.CheckAccessRights(password)
}
func (_feea *PdfReader) newPdfAnnotationPrinterMarkFromDict(_efeg *_fed.PdfObjectDictionary) (*PdfAnnotationPrinterMark, error) {
	_edg := PdfAnnotationPrinterMark{}
	_edg.MN = _efeg.Get("\u004d\u004e")
	return &_edg, nil
}

// PdfActionTrans represents a trans action.
type PdfActionTrans struct {
	*PdfAction
	Trans _fed.PdfObject
}

// SetXObjectFormByName adds the provided XObjectForm to the page resources.
// The added XObjectForm is identified by the specified name.
func (_ggfad *PdfPageResources) SetXObjectFormByName(keyName _fed.PdfObjectName, xform *XObjectForm) error {
	_dbgbgd := xform.ToPdfObject().(*_fed.PdfObjectStream)
	_degc := _ggfad.SetXObjectByName(keyName, _dbgbgd)
	return _degc
}

// GetAction returns the PDF action for the annotation link.
func (_ead *PdfAnnotationLink) GetAction() (*PdfAction, error) {
	if _ead._cge != nil {
		return _ead._cge, nil
	}
	if _ead.A == nil {
		return nil, nil
	}
	if _ead._dfbb == nil {
		return nil, nil
	}
	_fgbg, _ggg := _ead._dfbb.loadAction(_ead.A)
	if _ggg != nil {
		return nil, _ggg
	}
	_ead._cge = _fgbg
	return _ead._cge, nil
}

// Compress is yet to be implemented.
// Should be able to compress in terms of JPEG quality parameter,
// and DPI threshold (need to know bounding area dimensions).
func (_faggd DefaultImageHandler) Compress(input *Image, quality int64) (*Image, error) {
	return input, nil
}

// ColorToRGB converts an Indexed color to an RGB color.
func (_eggb *PdfColorspaceSpecialIndexed) ColorToRGB(color PdfColor) (PdfColor, error) {
	if _eggb.Base == nil {
		return nil, _bb.New("\u0069\u006e\u0064\u0065\u0078\u0065d\u0020\u0062\u0061\u0073\u0065\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070a\u0063\u0065\u0020\u0075\u006e\u0064\u0065f\u0069\u006e\u0065\u0064")
	}
	return _eggb.Base.ColorToRGB(color)
}
func (_ecdbd fontCommon) asPdfObjectDictionary(_acfde string) *_fed.PdfObjectDictionary {
	if _acfde != "" && _ecdbd._afge != "" && _acfde != _ecdbd._afge {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0061\u0073\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0044\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u002e\u0020O\u0076\u0065\u0072\u0072\u0069\u0064\u0069\u006e\u0067\u0020\u0073\u0075\u0062t\u0079\u0070\u0065\u0020\u0074\u006f \u0025\u0023\u0071 \u0025\u0073", _acfde, _ecdbd)
	} else if _acfde == "" && _ecdbd._afge == "" {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0061s\u0050\u0064\u0066Ob\u006a\u0065\u0063\u0074\u0044\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006e\u006f\u0020\u0073\u0075\u0062\u0074y\u0070\u0065\u002e\u0020\u0066\u006f\u006e\u0074=\u0025\u0073", _ecdbd)
	} else if _ecdbd._afge == "" {
		_ecdbd._afge = _acfde
	}
	_fbgcb := _fed.MakeDict()
	_fbgcb.Set("\u0054\u0079\u0070\u0065", _fed.MakeName("\u0046\u006f\u006e\u0074"))
	_fbgcb.Set("\u0042\u0061\u0073\u0065\u0046\u006f\u006e\u0074", _fed.MakeName(_ecdbd._daac))
	_fbgcb.Set("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName(_ecdbd._afge))
	if _ecdbd._bgdgb != nil {
		_fbgcb.Set("\u0046\u006f\u006e\u0074\u0044\u0065\u0073\u0063\u0072i\u0070\u0074\u006f\u0072", _ecdbd._bgdgb.ToPdfObject())
	}
	if _ecdbd._bbfbc != nil {
		_fbgcb.Set("\u0054o\u0055\u006e\u0069\u0063\u006f\u0064e", _ecdbd._bbfbc)
	} else if _ecdbd._ecfd != nil {
		_cggec, _gffcf := _ecdbd._ecfd.Stream()
		if _gffcf != nil {
			_fef.Log.Debug("\u0057\u0041\u0052\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006eo\u0074\u0020\u0067\u0065\u0074\u0020C\u004d\u0061\u0070\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u002e\u0020\u0065r\u0072\u003d\u0025\u0076", _gffcf)
		} else {
			_fbgcb.Set("\u0054o\u0055\u006e\u0069\u0063\u006f\u0064e", _cggec)
		}
	}
	return _fbgcb
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_bfbgb *PdfShadingType3) ToPdfObject() _fed.PdfObject {
	_bfbgb.PdfShading.ToPdfObject()
	_eedb, _deaec := _bfbgb.getShadingDict()
	if _deaec != nil {
		_fef.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _bfbgb.Coords != nil {
		_eedb.Set("\u0043\u006f\u006f\u0072\u0064\u0073", _bfbgb.Coords)
	}
	if _bfbgb.Domain != nil {
		_eedb.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _bfbgb.Domain)
	}
	if _bfbgb.Function != nil {
		if len(_bfbgb.Function) == 1 {
			_eedb.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _bfbgb.Function[0].ToPdfObject())
		} else {
			_bacfad := _fed.MakeArray()
			for _, _bccab := range _bfbgb.Function {
				_bacfad.Append(_bccab.ToPdfObject())
			}
			_eedb.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _bacfad)
		}
	}
	if _bfbgb.Extend != nil {
		_eedb.Set("\u0045\u0078\u0074\u0065\u006e\u0064", _bfbgb.Extend)
	}
	return _bfbgb._cdcge
}

// EncryptionAlgorithm is used in EncryptOptions to change the default algorithm used to encrypt the document.
type EncryptionAlgorithm int

func (_eabdc PdfFont) actualFont() pdfFont {
	if _eabdc._gdaa == nil {
		_fef.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0061\u0063\u0074\u0075\u0061\u006c\u0046\u006f\u006e\u0074\u002e\u0020\u0063\u006f\u006e\u0074\u0065\u0078\u0074\u0020\u0069\u0073\u0020\u006e\u0069\u006c.\u0020\u0066\u006f\u006e\u0074\u003d\u0025\u0073", _eabdc)
	}
	return _eabdc._gdaa
}

// Outline represents a PDF outline dictionary (Table 152 - p. 376).
// Currently, the Outline object can only be used to construct PDF outlines.
type Outline struct {
	Entries []*OutlineItem `json:"entries,omitempty"`
}

func (_babff *PdfWriter) writeObject(_dfacb int, _bdbba _fed.PdfObject) {
	_fef.Log.Trace("\u0057\u0072\u0069\u0074\u0065\u0020\u006f\u0062\u006a \u0023\u0025\u0064\u000a", _dfacb)
	if _dbfcf, _gfdbc := _bdbba.(*_fed.PdfIndirectObject); _gfdbc {
		_babff._agbdc[_dfacb] = crossReference{Type: 1, Offset: _babff._cgdb, Generation: _dbfcf.GenerationNumber}
		_afcbe := _d.Sprintf("\u0025d\u0020\u0030\u0020\u006f\u0062\u006a\n", _dfacb)
		if _deebb, _abfgga := _dbfcf.PdfObject.(*pdfSignDictionary); _abfgga {
			_deebb._baaf = _babff._cgdb + int64(len(_afcbe))
		}
		if _dbfcf.PdfObject == nil {
			_fef.Log.Debug("E\u0072\u0072\u006fr\u003a\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0027\u0073\u0020\u0050\u0064\u0066\u004f\u0062j\u0065\u0063\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020b\u0065\u0020\u006e\u0069l\u0020\u002d\u0020\u0073e\u0074\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063t\u004e\u0075\u006c\u006c")
			_dbfcf.PdfObject = _fed.MakeNull()
		}
		_afcbe += _dbfcf.PdfObject.WriteString()
		_afcbe += "\u000a\u0065\u006e\u0064\u006f\u0062\u006a\u000a"
		_babff.writeString(_afcbe)
		return
	}
	if _gccag, _ebcgc := _bdbba.(*_fed.PdfObjectStream); _ebcgc {
		_babff._agbdc[_dfacb] = crossReference{Type: 1, Offset: _babff._cgdb, Generation: _gccag.GenerationNumber}
		_dbcba := _d.Sprintf("\u0025d\u0020\u0030\u0020\u006f\u0062\u006a\n", _dfacb)
		_dbcba += _gccag.PdfObjectDictionary.WriteString()
		_dbcba += "\u000a\u0073\u0074\u0072\u0065\u0061\u006d\u000a"
		_babff.writeString(_dbcba)
		_babff.writeBytes(_gccag.Stream)
		_babff.writeString("\u000ae\u006ed\u0073\u0074\u0072\u0065\u0061m\u000a\u0065n\u0064\u006f\u0062\u006a\u000a")
		return
	}
	if _fgbea, _cbgb := _bdbba.(*_fed.PdfObjectStreams); _cbgb {
		_babff._agbdc[_dfacb] = crossReference{Type: 1, Offset: _babff._cgdb, Generation: _fgbea.GenerationNumber}
		_agcbe := _d.Sprintf("\u0025d\u0020\u0030\u0020\u006f\u0062\u006a\n", _dfacb)
		var _daece []string
		var _gfccg string
		var _efcgg int64
		for _agbfc, _efeae := range _fgbea.Elements() {
			_egedf, _addbd := _efeae.(*_fed.PdfIndirectObject)
			if !_addbd {
				_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065am\u0073 \u004e\u0020\u0025\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006es\u0020\u006e\u006f\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u0070\u0064\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0025\u0076", _dfacb, _efeae)
				continue
			}
			_debeg := _egedf.PdfObject.WriteString() + "\u0020"
			_gfccg = _gfccg + _debeg
			_daece = append(_daece, _d.Sprintf("\u0025\u0064\u0020%\u0064", _egedf.ObjectNumber, _efcgg))
			_babff._agbdc[int(_egedf.ObjectNumber)] = crossReference{Type: 2, ObjectNumber: _dfacb, Index: _agbfc}
			_efcgg = _efcgg + int64(len([]byte(_debeg)))
		}
		_bbaa := _eed.Join(_daece, "\u0020") + "\u0020"
		_bbdec := _fed.NewFlateEncoder()
		_aaafg := _bbdec.MakeStreamDict()
		_aaafg.Set(_fed.PdfObjectName("\u0054\u0079\u0070\u0065"), _fed.MakeName("\u004f\u0062\u006a\u0053\u0074\u006d"))
		_cbgd := int64(_fgbea.Len())
		_aaafg.Set(_fed.PdfObjectName("\u004e"), _fed.MakeInteger(_cbgd))
		_dege := int64(len(_bbaa))
		_aaafg.Set(_fed.PdfObjectName("\u0046\u0069\u0072s\u0074"), _fed.MakeInteger(_dege))
		_ddfb, _ := _bbdec.EncodeBytes([]byte(_bbaa + _gfccg))
		_baeab := int64(len(_ddfb))
		_aaafg.Set(_fed.PdfObjectName("\u004c\u0065\u006e\u0067\u0074\u0068"), _fed.MakeInteger(_baeab))
		_agcbe += _aaafg.WriteString()
		_agcbe += "\u000a\u0073\u0074\u0072\u0065\u0061\u006d\u000a"
		_babff.writeString(_agcbe)
		_babff.writeBytes(_ddfb)
		_babff.writeString("\u000ae\u006ed\u0073\u0074\u0072\u0065\u0061m\u000a\u0065n\u0064\u006f\u0062\u006a\u000a")
		return
	}
	_babff.writeString(_bdbba.WriteString())
}

// IsPush returns true if the button field represents a push button, false otherwise.
func (_cbga *PdfFieldButton) IsPush() bool { return _cbga.GetType() == ButtonTypePush }
func (_egcf *PdfReader) loadStructure() error {
	if _egcf._cdfggf.GetCrypter() != nil && !_egcf._cdfggf.IsAuthenticated() {
		return _d.Errorf("\u0066\u0069\u006ce\u0020\u006e\u0065\u0065d\u0020\u0074\u006f\u0020\u0062\u0065\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	}
	_aggdg := _egcf._cdfggf.GetTrailer()
	if _aggdg == nil {
		return _d.Errorf("\u006di\u0073s\u0069\u006e\u0067\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072")
	}
	_fffab, _fefddd := _aggdg.Get("\u0052\u006f\u006f\u0074").(*_fed.PdfObjectReference)
	if !_fefddd {
		return _d.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052\u006f\u006ft\u0020\u0028\u0074\u0072\u0061\u0069\u006c\u0065\u0072\u003a \u0025\u0073\u0029", _aggdg)
	}
	_cebg, _adabd := _egcf._cdfggf.LookupByReference(*_fffab)
	if _adabd != nil {
		_fef.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020\u0072\u006f\u006f\u0074\u0020\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u003a\u0020\u0025\u0073", _adabd)
		return _adabd
	}
	_bcfeb, _fefddd := _cebg.(*_fed.PdfIndirectObject)
	if !_fefddd {
		_fef.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u003a\u0020\u0028\u0072\u006f\u006f\u0074\u0020\u0025\u0071\u0029\u0020\u0028\u0074\u0072\u0061\u0069\u006c\u0065\u0072\u0020\u0025\u0073\u0029", _cebg, *_aggdg)
		return _bb.New("\u006di\u0073s\u0069\u006e\u0067\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067")
	}
	_edggf, _fefddd := (*_bcfeb).PdfObject.(*_fed.PdfObjectDictionary)
	if !_fefddd {
		_fef.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020I\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u0061t\u0061\u006c\u006fg\u0020(\u0025\u0073\u0029", _bcfeb.PdfObject)
		return _bb.New("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067")
	}
	_fef.Log.Trace("C\u0061\u0074\u0061\u006c\u006f\u0067\u003a\u0020\u0025\u0073", _edggf)
	_ffde, _fefddd := _edggf.Get("\u0050\u0061\u0067e\u0073").(*_fed.PdfObjectReference)
	if !_fefddd {
		return _bb.New("\u0070\u0061\u0067\u0065\u0073\u0020\u0069\u006e\u0020\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020b\u0065\u0020\u0061\u0020\u0072e\u0066\u0065r\u0065\u006e\u0063\u0065")
	}
	_ecdf, _adabd := _egcf._cdfggf.LookupByReference(*_ffde)
	if _adabd != nil {
		_fef.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020F\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020r\u0065\u0061\u0064 \u0070a\u0067\u0065\u0073")
		return _adabd
	}
	_cafaf, _fefddd := _ecdf.(*_fed.PdfIndirectObject)
	if !_fefddd {
		_fef.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020P\u0061\u0067\u0065\u0073\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0069n\u0076a\u006c\u0069\u0064")
		_fef.Log.Debug("\u006f\u0070\u003a\u0020\u0025\u0070", _cafaf)
		return _bb.New("p\u0061g\u0065\u0073\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0069\u006e\u0076al\u0069\u0064")
	}
	_fbaf, _fefddd := _cafaf.PdfObject.(*_fed.PdfObjectDictionary)
	if !_fefddd {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067\u0065\u0073\u0020\u006f\u0062j\u0065c\u0074\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0025\u0073\u0029", _cafaf)
		return _bb.New("p\u0061g\u0065\u0073\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0069\u006e\u0076al\u0069\u0064")
	}
	_agcbf, _fefddd := _fed.GetInt(_fbaf.Get("\u0043\u006f\u0075n\u0074"))
	if !_fefddd {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0050\u0061\u0067\u0065\u0073\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
		return _bb.New("\u0070\u0061\u0067\u0065s \u0063\u006f\u0075\u006e\u0074\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064")
	}
	if _, _fefddd = _fed.GetName(_fbaf.Get("\u0054\u0079\u0070\u0065")); !_fefddd {
		_fef.Log.Debug("\u0050\u0061\u0067\u0065\u0073\u0020\u0064\u0069\u0063\u0074\u0020T\u0079\u0070\u0065\u0020\u0066\u0069\u0065\u006cd\u0020n\u006f\u0074\u0020\u0073\u0065\u0074\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0054\u0079p\u0065\u0020\u0074\u006f\u0020\u0050\u0061\u0067\u0065\u0073\u002e")
		_fbaf.Set("\u0054\u0079\u0070\u0065", _fed.MakeName("\u0050\u0061\u0067e\u0073"))
	}
	if _bgdad, _fbfec := _fed.GetInt(_fbaf.Get("\u0052\u006f\u0074\u0061\u0074\u0065")); _fbfec {
		_bdecg := int64(*_bgdad)
		_egcf.Rotate = &_bdecg
	}
	_egcf._dfcaf = _fffab
	_egcf._bfcdc = _edggf
	_egcf._cbabc = _fbaf
	_egcf._fadda = _cafaf
	_egcf._efcga = int(*_agcbf)
	_egcf._gdac = []*_fed.PdfIndirectObject{}
	_geeb := map[_fed.PdfObject]struct{}{}
	_adabd = _egcf.buildPageList(_cafaf, nil, _geeb)
	if _adabd != nil {
		return _adabd
	}
	_fef.Log.Trace("\u002d\u002d\u002d")
	_fef.Log.Trace("\u0054\u004f\u0043")
	_fef.Log.Trace("\u0050\u0061\u0067e\u0073")
	_fef.Log.Trace("\u0025\u0064\u003a\u0020\u0025\u0073", len(_egcf._gdac), _egcf._gdac)
	_egcf._fgcc, _adabd = _egcf.loadOutlines()
	if _adabd != nil {
		_fef.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0062\u0075i\u006c\u0064\u0020\u006f\u0075\u0074\u006c\u0069\u006e\u0065 t\u0072\u0065\u0065 \u0028%\u0073\u0029", _adabd)
		return _adabd
	}
	_egcf.AcroForm, _adabd = _egcf.loadForms()
	if _adabd != nil {
		return _adabd
	}
	_egcf.DSS, _adabd = _egcf.loadDSS()
	if _adabd != nil {
		return _adabd
	}
	return nil
}
func (_bdaa *PdfReader) loadForms() (*PdfAcroForm, error) {
	if _bdaa._cdfggf.GetCrypter() != nil && !_bdaa._cdfggf.IsAuthenticated() {
		return nil, _d.Errorf("\u0066\u0069\u006ce\u0020\u006e\u0065\u0065d\u0020\u0074\u006f\u0020\u0062\u0065\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	}
	_afggd := _bdaa._bfcdc
	_edeef := _afggd.Get("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d")
	if _edeef == nil {
		return nil, nil
	}
	_gcagb, _ := _fed.GetIndirect(_edeef)
	_edeef = _fed.TraceToDirectObject(_edeef)
	if _fed.IsNullObject(_edeef) {
		_fef.Log.Trace("\u0041\u0063\u0072of\u006f\u0072\u006d\u0020\u0069\u0073\u0020\u0061\u0020n\u0075l\u006c \u006fb\u006a\u0065\u0063\u0074\u0020\u0028\u0065\u006d\u0070\u0074\u0079\u0029\u000a")
		return nil, nil
	}
	_aefaaa, _baaca := _fed.GetDict(_edeef)
	if !_baaca {
		_fef.Log.Debug("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0041\u0063\u0072\u006fF\u006fr\u006d \u0065\u006e\u0074\u0072\u0079\u0020\u0025T", _edeef)
		_fef.Log.Debug("\u0044\u006f\u0065\u0073 n\u006f\u0074\u0020\u0068\u0061\u0076\u0065\u0020\u0066\u006f\u0072\u006d\u0073")
		return nil, _d.Errorf("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0061\u0063\u0072\u006ff\u006fr\u006d \u0065\u006e\u0074\u0072\u0079\u0020\u0025T", _edeef)
	}
	_fef.Log.Trace("\u0048\u0061\u0073\u0020\u0041\u0063\u0072\u006f\u0020f\u006f\u0072\u006d\u0073")
	_fef.Log.Trace("\u0054\u0072\u0061\u0076\u0065\u0072\u0073\u0065\u0020\u0074\u0068\u0065\u0020\u0041\u0063r\u006ff\u006f\u0072\u006d\u0073\u0020\u0073\u0074\u0072\u0075\u0063\u0074\u0075\u0072\u0065")
	if !_bdaa._bgbff {
		_bcebb := _bdaa.traverseObjectData(_aefaaa)
		if _bcebb != nil {
			_fef.Log.Debug("E\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0074\u0072a\u0076\u0065\u0072\u0073\u0065\u0020\u0041\u0063\u0072\u006fFo\u0072\u006d\u0073 \u0028%\u0073\u0029", _bcebb)
			return nil, _bcebb
		}
	}
	_ffdeg, _gcfbc := _bdaa.newPdfAcroFormFromDict(_gcagb, _aefaaa)
	if _gcfbc != nil {
		return nil, _gcfbc
	}
	return _ffdeg, nil
}

// PdfColorspace interface defines the common methods of a PDF colorspace.
// The colorspace defines the data storage format for each color and color representation.
//
// Device based colorspace, specified by name
// - /DeviceGray
// - /DeviceRGB
// - /DeviceCMYK
//
// CIE based colorspace specified by [name, dictionary]
// - [/CalGray dict]
// - [/CalRGB dict]
// - [/Lab dict]
// - [/ICCBased dict]
//
// Special colorspaces
// - /Pattern
// - /Indexed
// - /Separation
// - /DeviceN
//
// Work is in progress to support all colorspaces. At the moment ICCBased color spaces fall back to the alternate
// colorspace which works OK in most cases. For full color support, will need fully featured ICC support.
type PdfColorspace interface {

	// String returns the PdfColorspace's name.
	String() string

	// ImageToRGB converts an Image in a given PdfColorspace to an RGB image.
	ImageToRGB(Image) (Image, error)

	// ColorToRGB converts a single color in a given PdfColorspace to an RGB color.
	ColorToRGB(_cgge PdfColor) (PdfColor, error)

	// GetNumComponents returns the number of components in the PdfColorspace.
	GetNumComponents() int

	// ToPdfObject returns a PdfObject representation of the PdfColorspace.
	ToPdfObject() _fed.PdfObject

	// ColorFromPdfObjects returns a PdfColor in the given PdfColorspace from an array of PdfObject where each
	// PdfObject represents a numeric value.
	ColorFromPdfObjects(_bffe []_fed.PdfObject) (PdfColor, error)

	// ColorFromFloats returns a new PdfColor based on input color components for a given PdfColorspace.
	ColorFromFloats(_dgfg []float64) (PdfColor, error)

	// DecodeArray returns the Decode array for the PdfColorSpace, i.e. the range of each component.
	DecodeArray() []float64
}
type crossReference struct {
	Type int

	// Type 1
	Offset     int64
	Generation int64

	// Type 2
	ObjectNumber int
	Index        int
}

// BytesToCharcodes converts the bytes in a PDF string to character codes.
func (_aggb *PdfFont) BytesToCharcodes(data []byte) []_dg.CharCode {
	_fef.Log.Trace("\u0042\u0079\u0074es\u0054\u006f\u0043\u0068\u0061\u0072\u0063\u006f\u0064e\u0073:\u0020d\u0061t\u0061\u003d\u005b\u0025\u0020\u0030\u0032\u0078\u005d\u003d\u0025\u0023\u0071", data, data)
	if _fcagf, _ggcg := _aggb._gdaa.(*pdfFontType0); _ggcg && _fcagf._adgcc != nil {
		if _bcgdf, _dddg := _fcagf.bytesToCharcodes(data); _dddg {
			return _bcgdf
		}
	}
	_adacc := make([]_dg.CharCode, 0, len(data)+len(data)%2)
	if _aggb.baseFields().isCIDFont() {
		if len(data) == 1 {
			data = []byte{0, data[0]}
		}
		if len(data)%2 != 0 {
			_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0064\u0061\u0074\u0061\u003d\u0025\u002b\u0076\u0020t\u006f\u0020\u0065\u0076\u0065n\u0020\u006ce\u006e\u0067\u0074\u0068", data)
			data = append(data, 0)
		}
		for _gdec := 0; _gdec < len(data); _gdec += 2 {
			_fadbe := uint16(data[_gdec])<<8 | uint16(data[_gdec+1])
			_adacc = append(_adacc, _dg.CharCode(_fadbe))
		}
	} else {
		for _, _ecac := range data {
			_adacc = append(_adacc, _dg.CharCode(_ecac))
		}
	}
	return _adacc
}
func (_gcda *DSS) addOCSPs(_bgab [][]byte) ([]*_fed.PdfObjectStream, error) {
	return _gcda.add(&_gcda.OCSPs, _gcda._bece, _bgab)
}

// SetPdfModifiedDate sets the ModDate attribute of the output PDF.
func SetPdfModifiedDate(modifiedDate _e.Time) {
	_abadca.Lock()
	defer _abadca.Unlock()
	_edeaf = modifiedDate
}

// NewPdfAnnotation3D returns a new 3d annotation.
func NewPdfAnnotation3D() *PdfAnnotation3D {
	_dfbe := NewPdfAnnotation()
	_gff := &PdfAnnotation3D{}
	_gff.PdfAnnotation = _dfbe
	_dfbe.SetContext(_gff)
	return _gff
}

// NewPdfPage returns a new PDF page.
func NewPdfPage() *PdfPage {
	_agdb := PdfPage{}
	_agdb._bdgge = _fed.MakeDict()
	_agdb.Resources = NewPdfPageResources()
	_ffba := _fed.PdfIndirectObject{}
	_ffba.PdfObject = _agdb._bdgge
	_agdb._efbb = &_ffba
	return &_agdb
}

// NewStandard14Font returns the standard 14 font named `basefont` as a *PdfFont, or an error if it
// `basefont` is not one of the standard 14 font names.
func NewStandard14Font(basefont StdFontName) (*PdfFont, error) {
	_gfga, _aaca := _abba(basefont)
	if _aaca != nil {
		return nil, _aaca
	}
	if basefont != SymbolName && basefont != ZapfDingbatsName {
		_gfga._ebcbf = _dg.NewWinAnsiEncoder()
	}
	return &PdfFont{_gdaa: &_gfga}, nil
}

// PdfRectangle is a definition of a rectangle.
type PdfRectangle struct {
	Llx float64
	Lly float64
	Urx float64
	Ury float64
}

func (_ebfe *PdfReader) newPdfAnnotationStrikeOut(_dbaf *_fed.PdfObjectDictionary) (*PdfAnnotationStrikeOut, error) {
	_ggb := PdfAnnotationStrikeOut{}
	_cbcf, _afca := _ebfe.newPdfAnnotationMarkupFromDict(_dbaf)
	if _afca != nil {
		return nil, _afca
	}
	_ggb.PdfAnnotationMarkup = _cbcf
	_ggb.QuadPoints = _dbaf.Get("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073")
	return &_ggb, nil
}
func _gfgeg(_gfadf *_fed.PdfObjectDictionary) *VRI {
	_gacbb, _ := _fed.GetString(_gfadf.Get("\u0054\u0055"))
	_fefg, _ := _fed.GetString(_gfadf.Get("\u0054\u0053"))
	return &VRI{Cert: _fedf(_gfadf.Get("\u0043\u0065\u0072\u0074")), OCSP: _fedf(_gfadf.Get("\u004f\u0043\u0053\u0050")), CRL: _fedf(_gfadf.Get("\u0043\u0052\u004c")), TU: _gacbb, TS: _fefg}
}
func _dfebf(_cgfb []byte) ([]byte, error) {
	_gfedc := _c.New()
	if _, _aceac := _ge.Copy(_gfedc, _eb.NewReader(_cgfb)); _aceac != nil {
		return nil, _aceac
	}
	return _gfedc.Sum(nil), nil
}
func _dgfdb(_ggcfg *_fed.PdfObjectDictionary, _cbdcg *fontCommon) (*pdfCIDFontType0, error) {
	if _cbdcg._afge != "\u0043\u0049\u0044F\u006f\u006e\u0074\u0054\u0079\u0070\u0065\u0030" {
		_fef.Log.Debug("\u0045R\u0052\u004fR\u003a\u0020\u0046\u006fn\u0074\u0020\u0053u\u0062\u0054\u0079\u0070\u0065\u0020\u0021\u003d\u0020CI\u0044\u0046\u006fn\u0074\u0054y\u0070\u0065\u0030\u002e\u0020\u0066o\u006e\u0074=\u0025\u0073", _cbdcg)
		return nil, _fed.ErrRangeError
	}
	_bdfc := _cbgcd(_cbdcg)
	_gcgd, _cdfa := _fed.GetDict(_ggcfg.Get("\u0043\u0049\u0044\u0053\u0079\u0073\u0074\u0065\u006d\u0049\u006e\u0066\u006f"))
	if !_cdfa {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043I\u0044\u0053\u0079st\u0065\u006d\u0049\u006e\u0066\u006f \u0028\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0029\u0020\u006d\u0069\u0073\u0073i\u006e\u0067\u002e\u0020\u0066\u006f\u006e\u0074=\u0025\u0073", _cbdcg)
		return nil, ErrRequiredAttributeMissing
	}
	_bdfc.CIDSystemInfo = _gcgd
	_bdfc.DW = _ggcfg.Get("\u0044\u0057")
	_bdfc.W = _ggcfg.Get("\u0057")
	_bdfc.DW2 = _ggcfg.Get("\u0044\u0057\u0032")
	_bdfc.W2 = _ggcfg.Get("\u0057\u0032")
	_bdfc._fabb = 1000.0
	if _cbeff, _cgfcd := _fed.GetNumberAsFloat(_bdfc.DW); _cgfcd == nil {
		_bdfc._fabb = _cbeff
	}
	_aegdf, _ggbea := _bfag(_bdfc.W)
	if _ggbea != nil {
		return nil, _ggbea
	}
	if _aegdf == nil {
		_aegdf = map[_dg.CharCode]float64{}
	}
	_bdfc._dadd = _aegdf
	return _bdfc, nil
}

// GetPatternByName gets the pattern specified by keyName. Returns nil if not existing.
// The bool flag indicated whether it was found or not.
func (_bbabf *PdfPageResources) GetPatternByName(keyName _fed.PdfObjectName) (*PdfPattern, bool) {
	if _bbabf.Pattern == nil {
		return nil, false
	}
	_deaa, _deec := _fed.TraceToDirectObject(_bbabf.Pattern).(*_fed.PdfObjectDictionary)
	if !_deec {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0061\u0074t\u0065\u0072\u006e\u0020\u0065\u006e\u0074r\u0079\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _bbabf.Pattern)
		return nil, false
	}
	if _fdaad := _deaa.Get(keyName); _fdaad != nil {
		_cffba, _gcgfd := _bcggc(_fdaad)
		if _gcgfd != nil {
			_fef.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020f\u0061\u0069l\u0065\u0064\u0020\u0074\u006f\u0020\u006c\u006fa\u0064\u0020\u0070\u0064\u0066\u0020\u0070\u0061\u0074\u0074\u0065\u0072n\u003a\u0020\u0025\u0076", _gcgfd)
			return nil, false
		}
		return _cffba, true
	}
	return nil, false
}

// VRI represents a Validation-Related Information dictionary.
// The VRI dictionary contains validation data in the form of
// certificates, OCSP and CRL information, for a single signature.
// See ETSI TS 102 778-4 V1.1.1 for more information.
type VRI struct {
	Cert []*_fed.PdfObjectStream
	OCSP []*_fed.PdfObjectStream
	CRL  []*_fed.PdfObjectStream
	TU   *_fed.PdfObjectString
	TS   *_fed.PdfObjectString
}

// CharMetrics represents width and height metrics of a glyph.
type CharMetrics = _geg.CharMetrics

// GetCharMetrics returns the char metrics for character code `code`.
func (_aeaad pdfFontType0) GetCharMetrics(code _dg.CharCode) (_geg.CharMetrics, bool) {
	if _aeaad.DescendantFont == nil {
		_fef.Log.Debug("\u0045\u0052R\u004f\u0052\u003a\u0020\u004e\u006f\u0020\u0064\u0065\u0073\u0063\u0065\u006e\u0064\u0061\u006e\u0074\u002e\u0020\u0066\u006f\u006et=\u0025\u0073", _aeaad)
		return _geg.CharMetrics{}, false
	}
	return _aeaad.DescendantFont.GetCharMetrics(code)
}

// PdfFont represents an underlying font structure which can be of type:
// - Type0
// - Type1
// - TrueType
// etc.
type PdfFont struct{ _gdaa pdfFont }

func (_aefa *PdfReader) newPdfAnnotationWatermarkFromDict(_dgeb *_fed.PdfObjectDictionary) (*PdfAnnotationWatermark, error) {
	_dffa := PdfAnnotationWatermark{}
	_dffa.FixedPrint = _dgeb.Get("\u0046\u0069\u0078\u0065\u0064\u0050\u0072\u0069\u006e\u0074")
	return &_dffa, nil
}

// GetCharMetrics returns the character metrics for the specified character code.  A bool flag is
// returned to indicate whether or not the entry was found in the glyph to charcode mapping.
// How it works:
//  1) Return a value the /Widths array (charWidths) if there is one.
//  2) If the font has the same name as a standard 14 font then return width=250.
//  3) Otherwise return no match and let the caller substitute a default.
func (_befd pdfFontSimple) GetCharMetrics(code _dg.CharCode) (_geg.CharMetrics, bool) {
	if _fecd, _ggdc := _befd._dadc[code]; _ggdc {
		return _geg.CharMetrics{Wx: _fecd}, true
	}
	if _geg.IsStdFont(_geg.StdFontName(_befd._daac)) {
		return _geg.CharMetrics{Wx: 250}, true
	}
	return _geg.CharMetrics{}, false
}
func _gfec() _e.Time { _abadca.Lock(); defer _abadca.Unlock(); return _edeaf }

// SetOpenAction sets the OpenAction in the PDF catalog.
// The value shall be either an array defining a destination (12.3.2 "Destinations" PDF32000_2008),
// or an action dictionary representing an action (12.6 "Actions" PDF32000_2008).
func (_bfeg *PdfWriter) SetOpenAction(dest _fed.PdfObject) error {
	if dest == nil || _fed.IsNullObject(dest) {
		return nil
	}
	_bfeg._cdefg.Set("\u004f\u0070\u0065\u006e\u0041\u0063\u0074\u0069\u006f\u006e", dest)
	return _bfeg.addObjects(dest)
}

// ToPdfObject returns the PDF representation of the function.
func (_cgad *PdfFunctionType0) ToPdfObject() _fed.PdfObject {
	if _cgad._dacbd == nil {
		_cgad._dacbd = &_fed.PdfObjectStream{}
	}
	_gbec := _fed.MakeDict()
	_gbec.Set("\u0046\u0075\u006ec\u0074\u0069\u006f\u006e\u0054\u0079\u0070\u0065", _fed.MakeInteger(0))
	_edecg := &_fed.PdfObjectArray{}
	for _, _gdcga := range _cgad.Domain {
		_edecg.Append(_fed.MakeFloat(_gdcga))
	}
	_gbec.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _edecg)
	_gcfe := &_fed.PdfObjectArray{}
	for _, _efgb := range _cgad.Range {
		_gcfe.Append(_fed.MakeFloat(_efgb))
	}
	_gbec.Set("\u0052\u0061\u006eg\u0065", _gcfe)
	_ecgb := &_fed.PdfObjectArray{}
	for _, _aggg := range _cgad.Size {
		_ecgb.Append(_fed.MakeInteger(int64(_aggg)))
	}
	_gbec.Set("\u0053\u0069\u007a\u0065", _ecgb)
	_gbec.Set("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0053\u0061\u006d\u0070\u006c\u0065", _fed.MakeInteger(int64(_cgad.BitsPerSample)))
	if _cgad.Order != 1 {
		_gbec.Set("\u004f\u0072\u0064e\u0072", _fed.MakeInteger(int64(_cgad.Order)))
	}
	_gbec.Set("\u004c\u0065\u006e\u0067\u0074\u0068", _fed.MakeInteger(int64(len(_cgad._eggab))))
	_cgad._dacbd.Stream = _cgad._eggab
	_cgad._dacbd.PdfObjectDictionary = _gbec
	return _cgad._dacbd
}

// NewStandard14FontMustCompile returns the standard 14 font named `basefont` as a *PdfFont.
// If `basefont` is one of the 14 Standard14Font values defined above then NewStandard14FontMustCompile
// is guaranteed to succeed.
func NewStandard14FontMustCompile(basefont StdFontName) *PdfFont {
	_eadab, _beee := NewStandard14Font(basefont)
	if _beee != nil {
		panic(_d.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0053\u0074\u0061n\u0064\u0061\u0072\u0064\u0031\u0034\u0046\u006f\u006e\u0074 \u0025\u0023\u0071", basefont))
	}
	return _eadab
}

// ToPdfObject converts date to a PDF string object.
func (_dccaf *PdfDate) ToPdfObject() _fed.PdfObject {
	_debba := _d.Sprintf("\u0044\u003a\u0025\u002e\u0034\u0064\u0025\u002e\u0032\u0064\u0025\u002e\u0032\u0064\u0025\u002e\u0032\u0064\u0025\u002e\u0032\u0064\u0025\u002e2\u0064\u0025\u0063\u0025\u002e2\u0064\u0027%\u002e\u0032\u0064\u0027", _dccaf._abaff, _dccaf._beaeg, _dccaf._dcbg, _dccaf._gdcccg, _dccaf._dbgdd, _dccaf._eaec, _dccaf._caaae, _dccaf._ecgbg, _dccaf._aabea)
	return _fed.MakeString(_debba)
}

// SetPdfAuthor sets the Author attribute of the output PDF.
func SetPdfAuthor(author string) { _abadca.Lock(); defer _abadca.Unlock(); _eebc = author }

// GetContainingPdfObject implements interface PdfModel.
func (_eaca *PdfFilespec) GetContainingPdfObject() _fed.PdfObject { return _eaca._dfeff }
func _cggde(_ddfd _fed.PdfObject) (*PdfColorspaceSpecialPattern, error) {
	_fef.Log.Trace("\u004e\u0065\u0077\u0020\u0050\u0061\u0074\u0074\u0065\u0072n\u0020\u0043\u0053\u0020\u0066\u0072\u006fm\u0020\u006f\u0062\u006a\u003a\u0020\u0025\u0073\u0020\u0025\u0054", _ddfd.String(), _ddfd)
	_adcbg := NewPdfColorspaceSpecialPattern()
	if _ffcb, _gbcg := _ddfd.(*_fed.PdfIndirectObject); _gbcg {
		_adcbg._afff = _ffcb
	}
	_ddfd = _fed.TraceToDirectObject(_ddfd)
	if _efcb, _badf := _ddfd.(*_fed.PdfObjectName); _badf {
		if *_efcb != "\u0050a\u0074\u0074\u0065\u0072\u006e" {
			return nil, _d.Errorf("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u006e\u0061\u006d\u0065")
		}
		return _adcbg, nil
	}
	_dgfd, _eada := _ddfd.(*_fed.PdfObjectArray)
	if !_eada {
		_fef.Log.Error("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0061t\u0074\u0065\u0072\u006e\u0020\u0043\u0053 \u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0023\u0076", _ddfd)
		return nil, _d.Errorf("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0050\u0061\u0074\u0074e\u0072n\u0020C\u0053\u0020\u006f\u0062\u006a\u0065\u0063t")
	}
	if _dgfd.Len() != 1 && _dgfd.Len() != 2 {
		_fef.Log.Error("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0050\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0043\u0053\u0020\u0061\u0072\u0072\u0061\u0079\u003a %\u0023\u0076", _dgfd)
		return nil, _d.Errorf("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0061\u0074\u0074\u0065r\u006e\u0020\u0043\u0053\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_ddfd = _dgfd.Get(0)
	if _dead, _agef := _ddfd.(*_fed.PdfObjectName); _agef {
		if *_dead != "\u0050a\u0074\u0074\u0065\u0072\u006e" {
			_fef.Log.Error("\u0049\u006e\u0076al\u0069\u0064\u0020\u0050\u0061\u0074\u0074\u0065\u0072n\u0020C\u0053 \u0061r\u0072\u0061\u0079\u0020\u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0023\u0076", _dead)
			return nil, _d.Errorf("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u006e\u0061\u006d\u0065")
		}
	}
	if _dgfd.Len() > 1 {
		_ddfd = _dgfd.Get(1)
		_ddfd = _fed.TraceToDirectObject(_ddfd)
		_ggea, _dfag := NewPdfColorspaceFromPdfObject(_ddfd)
		if _dfag != nil {
			return nil, _dfag
		}
		_adcbg.UnderlyingCS = _ggea
	}
	_fef.Log.Trace("R\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0050\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0077i\u0074\u0068\u0020\u0075\u006e\u0064\u0065\u0072\u006c\u0079in\u0067\u0020\u0063s\u003a \u0025\u0054", _adcbg.UnderlyingCS)
	return _adcbg, nil
}

// ToPdfObject implements interface PdfModel.
func (_gg *PdfAction) ToPdfObject() _fed.PdfObject {
	_ec := _gg._fa
	_bga := _ec.PdfObject.(*_fed.PdfObjectDictionary)
	_bga.Clear()
	_bga.Set("\u0054\u0079\u0070\u0065", _fed.MakeName("\u0041\u0063\u0074\u0069\u006f\u006e"))
	_bga.SetIfNotNil("\u0053", _gg.S)
	_bga.SetIfNotNil("\u004e\u0065\u0078\u0074", _gg.Next)
	return _ec
}

// PdfShadingType5 is a Lattice-form Gouraud-shaded triangle mesh.
type PdfShadingType5 struct {
	*PdfShading
	BitsPerCoordinate *_fed.PdfObjectInteger
	BitsPerComponent  *_fed.PdfObjectInteger
	VerticesPerRow    *_fed.PdfObjectInteger
	Decode            *_fed.PdfObjectArray
	Function          []PdfFunction
}

// ToPdfObject implements interface PdfModel.
func (_dbefb *PdfAnnotationFreeText) ToPdfObject() _fed.PdfObject {
	_dbefb.PdfAnnotation.ToPdfObject()
	_ebca := _dbefb._ffaab
	_bbbed := _ebca.PdfObject.(*_fed.PdfObjectDictionary)
	_dbefb.PdfAnnotationMarkup.appendToPdfDictionary(_bbbed)
	_bbbed.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u0046\u0072\u0065\u0065\u0054\u0065\u0078\u0074"))
	_bbbed.SetIfNotNil("\u0044\u0041", _dbefb.DA)
	_bbbed.SetIfNotNil("\u0051", _dbefb.Q)
	_bbbed.SetIfNotNil("\u0052\u0043", _dbefb.RC)
	_bbbed.SetIfNotNil("\u0044\u0053", _dbefb.DS)
	_bbbed.SetIfNotNil("\u0043\u004c", _dbefb.CL)
	_bbbed.SetIfNotNil("\u0049\u0054", _dbefb.IT)
	_bbbed.SetIfNotNil("\u0042\u0045", _dbefb.BE)
	_bbbed.SetIfNotNil("\u0052\u0044", _dbefb.RD)
	_bbbed.SetIfNotNil("\u0042\u0053", _dbefb.BS)
	_bbbed.SetIfNotNil("\u004c\u0045", _dbefb.LE)
	return _ebca
}
func (_fegg *PdfReader) newPdfAnnotationMovieFromDict(_cdcc *_fed.PdfObjectDictionary) (*PdfAnnotationMovie, error) {
	_bgeg := PdfAnnotationMovie{}
	_bgeg.T = _cdcc.Get("\u0054")
	_bgeg.Movie = _cdcc.Get("\u004d\u006f\u0076i\u0065")
	_bgeg.A = _cdcc.Get("\u0041")
	return &_bgeg, nil
}

// PdfAnnotationInk represents Ink annotations.
// (Section 12.5.6.13).
type PdfAnnotationInk struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	InkList _fed.PdfObject
	BS      _fed.PdfObject
}

func (_cfbe *PdfReader) newPdfPageFromDict(_badcac *_fed.PdfObjectDictionary) (*PdfPage, error) {
	_aeceg := NewPdfPage()
	_aeceg._bdgge = _badcac
	_afdd := *_badcac
	_gebf, _daad := _afdd.Get("\u0054\u0079\u0070\u0065").(*_fed.PdfObjectName)
	if !_daad {
		return nil, _bb.New("\u006d\u0069ss\u0069\u006e\u0067/\u0069\u006e\u0076\u0061lid\u0020Pa\u0067\u0065\u0020\u0064\u0069\u0063\u0074io\u006e\u0061\u0072\u0079\u0020\u0054\u0079p\u0065")
	}
	if *_gebf != "\u0050\u0061\u0067\u0065" {
		return nil, _bb.New("\u0070\u0061\u0067\u0065 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079 \u0054y\u0070\u0065\u0020\u0021\u003d\u0020\u0050a\u0067\u0065")
	}
	if _daeed := _afdd.Get("\u0050\u0061\u0072\u0065\u006e\u0074"); _daeed != nil {
		_aeceg.Parent = _daeed
	}
	if _eagac := _afdd.Get("\u004c\u0061\u0073t\u004d\u006f\u0064\u0069\u0066\u0069\u0065\u0064"); _eagac != nil {
		_bfffb, _effce := _fed.GetString(_eagac)
		if !_effce {
			return nil, _bb.New("\u0070\u0061\u0067\u0065\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u004c\u0061\u0073\u0074\u004d\u006f\u0064\u0069f\u0069\u0065\u0064\u0020\u0021=\u0020\u0073t\u0072\u0069\u006e\u0067")
		}
		_gacd, _dgdcc := NewPdfDate(_bfffb.Str())
		if _dgdcc != nil {
			return nil, _dgdcc
		}
		_aeceg.LastModified = &_gacd
	}
	if _beeec := _afdd.Get("\u0052e\u0073\u006f\u0075\u0072\u0063\u0065s"); _beeec != nil && !_fed.IsNullObject(_beeec) {
		_bcbfd, _ebfbe := _fed.GetDict(_beeec)
		if !_ebfbe {
			return nil, _d.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0065\u0073\u006f\u0075\u0072\u0063e\u0020d\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0054\u0029", _beeec)
		}
		var _dgcdee error
		_aeceg.Resources, _dgcdee = NewPdfPageResourcesFromDict(_bcbfd)
		if _dgcdee != nil {
			return nil, _dgcdee
		}
	} else {
		_bdbcd, _fabae := _aeceg.getParentResources()
		if _fabae != nil {
			return nil, _fabae
		}
		if _bdbcd == nil {
			_bdbcd = NewPdfPageResources()
		}
		_aeceg.Resources = _bdbcd
	}
	if _agfdg := _afdd.Get("\u004d\u0065\u0064\u0069\u0061\u0042\u006f\u0078"); _agfdg != nil {
		_dfcgb, _cegaa := _fed.GetArray(_agfdg)
		if !_cegaa {
			return nil, _bb.New("\u0070\u0061\u0067\u0065\u0020\u004d\u0065\u0064\u0069\u0061\u0042o\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072\u0061\u0079")
		}
		var _cfdab error
		_aeceg.MediaBox, _cfdab = NewPdfRectangle(*_dfcgb)
		if _cfdab != nil {
			return nil, _cfdab
		}
	}
	if _dgcgb := _afdd.Get("\u0043r\u006f\u0070\u0042\u006f\u0078"); _dgcgb != nil {
		_dbbg, _fbadd := _fed.GetArray(_dgcgb)
		if !_fbadd {
			return nil, _bb.New("\u0070a\u0067\u0065\u0020\u0043r\u006f\u0070\u0042\u006f\u0078 \u006eo\u0074 \u0061\u006e\u0020\u0061\u0072\u0072\u0061y")
		}
		var _eadfc error
		_aeceg.CropBox, _eadfc = NewPdfRectangle(*_dbbg)
		if _eadfc != nil {
			return nil, _eadfc
		}
	}
	if _deeg := _afdd.Get("\u0042\u006c\u0065\u0065\u0064\u0042\u006f\u0078"); _deeg != nil {
		_ecfdg, _cbcbd := _fed.GetArray(_deeg)
		if !_cbcbd {
			return nil, _bb.New("\u0070\u0061\u0067\u0065\u0020\u0042\u006c\u0065\u0065\u0064\u0042o\u0078\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072\u0061\u0079")
		}
		var _ebcfc error
		_aeceg.BleedBox, _ebcfc = NewPdfRectangle(*_ecfdg)
		if _ebcfc != nil {
			return nil, _ebcfc
		}
	}
	if _dbbdf := _afdd.Get("\u0054r\u0069\u006d\u0042\u006f\u0078"); _dbbdf != nil {
		_ebee, _eecc := _fed.GetArray(_dbbdf)
		if !_eecc {
			return nil, _bb.New("\u0070a\u0067\u0065\u0020\u0054r\u0069\u006d\u0042\u006f\u0078 \u006eo\u0074 \u0061\u006e\u0020\u0061\u0072\u0072\u0061y")
		}
		var _cagd error
		_aeceg.TrimBox, _cagd = NewPdfRectangle(*_ebee)
		if _cagd != nil {
			return nil, _cagd
		}
	}
	if _dbbdc := _afdd.Get("\u0041\u0072\u0074\u0042\u006f\u0078"); _dbbdc != nil {
		_cgaff, _aebab := _fed.GetArray(_dbbdc)
		if !_aebab {
			return nil, _bb.New("\u0070a\u0067\u0065\u0020\u0041\u0072\u0074\u0042\u006f\u0078\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079")
		}
		var _deebf error
		_aeceg.ArtBox, _deebf = NewPdfRectangle(*_cgaff)
		if _deebf != nil {
			return nil, _deebf
		}
	}
	if _gdbbc := _afdd.Get("\u0042\u006f\u0078C\u006f\u006c\u006f\u0072\u0049\u006e\u0066\u006f"); _gdbbc != nil {
		_aeceg.BoxColorInfo = _gdbbc
	}
	if _fadbeg := _afdd.Get("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"); _fadbeg != nil {
		_aeceg.Contents = _fadbeg
	}
	if _ggfc := _afdd.Get("\u0052\u006f\u0074\u0061\u0074\u0065"); _ggfc != nil {
		_bcaf, _gecdf := _fed.GetInt(_ggfc)
		if !_gecdf {
			return nil, _bb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0061\u0067e\u0020\u0052\u006f\u0074\u0061\u0074\u0065\u0020\u006f\u0062j\u0065\u0063\u0074")
		}
		_cgcga := int64(*_bcaf)
		_aeceg.Rotate = &_cgcga
	}
	if _ebgae := _afdd.Get("\u0047\u0072\u006fu\u0070"); _ebgae != nil {
		_aeceg.Group = _ebgae
	}
	if _fbdac := _afdd.Get("\u0054\u0068\u0075m\u0062"); _fbdac != nil {
		_aeceg.Thumb = _fbdac
	}
	if _efbaa := _afdd.Get("\u0042"); _efbaa != nil {
		_aeceg.B = _efbaa
	}
	if _bfda := _afdd.Get("\u0044\u0075\u0072"); _bfda != nil {
		_aeceg.Dur = _bfda
	}
	if _bfbfe := _afdd.Get("\u0054\u0072\u0061n\u0073"); _bfbfe != nil {
		_aeceg.Trans = _bfbfe
	}
	if _dafg := _afdd.Get("\u0041\u0041"); _dafg != nil {
		_aeceg.AA = _dafg
	}
	if _gagcd := _afdd.Get("\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061"); _gagcd != nil {
		_aeceg.Metadata = _gagcd
	}
	if _ffbf := _afdd.Get("\u0050i\u0065\u0063\u0065\u0049\u006e\u0066o"); _ffbf != nil {
		_aeceg.PieceInfo = _ffbf
	}
	if _ddcdc := _afdd.Get("\u0053\u0074\u0072\u0075\u0063\u0074\u0050\u0061\u0072\u0065\u006e\u0074\u0073"); _ddcdc != nil {
		_aeceg.StructParents = _ddcdc
	}
	if _ebbaf := _afdd.Get("\u0049\u0044"); _ebbaf != nil {
		_aeceg.ID = _ebbaf
	}
	if _fdaba := _afdd.Get("\u0050\u005a"); _fdaba != nil {
		_aeceg.PZ = _fdaba
	}
	if _cfeb := _afdd.Get("\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006fn\u0049\u006e\u0066\u006f"); _cfeb != nil {
		_aeceg.SeparationInfo = _cfeb
	}
	if _cdcf := _afdd.Get("\u0054\u0061\u0062\u0073"); _cdcf != nil {
		_aeceg.Tabs = _cdcf
	}
	if _gabg := _afdd.Get("T\u0065m\u0070\u006c\u0061\u0074\u0065\u0049\u006e\u0073t\u0061\u006e\u0074\u0069at\u0065\u0064"); _gabg != nil {
		_aeceg.TemplateInstantiated = _gabg
	}
	if _dggea := _afdd.Get("\u0050r\u0065\u0073\u0053\u0074\u0065\u0070s"); _dggea != nil {
		_aeceg.PresSteps = _dggea
	}
	if _ebaaa := _afdd.Get("\u0055\u0073\u0065\u0072\u0055\u006e\u0069\u0074"); _ebaaa != nil {
		_aeceg.UserUnit = _ebaaa
	}
	if _dgffg := _afdd.Get("\u0056\u0050"); _dgffg != nil {
		_aeceg.VP = _dgffg
	}
	if _gabge := _afdd.Get("\u0041\u006e\u006e\u006f\u0074\u0073"); _gabge != nil {
		_aeceg.Annots = _gabge
	}
	_aeceg._fdcd = _cfbe
	return _aeceg, nil
}

// CharcodesToUnicode converts the character codes `charcodes` to a slice of runes.
// How it works:
//  1) Use the ToUnicode CMap if there is one.
//  2) Use the underlying font's encoding.
func (_gacbf *PdfFont) CharcodesToUnicode(charcodes []_dg.CharCode) []rune {
	_gaecc, _, _ := _gacbf.CharcodesToUnicodeWithStats(charcodes)
	return _gaecc
}

var _dbafd = map[string]string{"\u0053\u0079\u006d\u0062\u006f\u006c": "\u0053\u0079\u006d\u0062\u006f\u006c\u0045\u006e\u0063o\u0064\u0069\u006e\u0067", "\u005a\u0061\u0070f\u0044\u0069\u006e\u0067\u0062\u0061\u0074\u0073": "Z\u0061p\u0066\u0044\u0069\u006e\u0067\u0062\u0061\u0074s\u0045\u006e\u0063\u006fdi\u006e\u0067"}

// NewPdfAnnotationPrinterMark returns a new printermark annotation.
func NewPdfAnnotationPrinterMark() *PdfAnnotationPrinterMark {
	_adcf := NewPdfAnnotation()
	_acdg := &PdfAnnotationPrinterMark{}
	_acdg.PdfAnnotation = _adcf
	_adcf.SetContext(_acdg)
	return _acdg
}
func _ebed(_bfecd _fed.PdfObject) (*PdfColorspaceDeviceNAttributes, error) {
	_fcbcb := &PdfColorspaceDeviceNAttributes{}
	var _ddda *_fed.PdfObjectDictionary
	switch _ffag := _bfecd.(type) {
	case *_fed.PdfIndirectObject:
		_fcbcb._cfbb = _ffag
		var _aageg bool
		_ddda, _aageg = _ffag.PdfObject.(*_fed.PdfObjectDictionary)
		if !_aageg {
			_fef.Log.Error("\u0044\u0065\u0076\u0069c\u0065\u004e\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075t\u0065 \u0074\u0079\u0070\u0065\u0020\u0065\u0072r\u006f\u0072")
			return nil, _bb.New("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
		}
	case *_fed.PdfObjectDictionary:
		_ddda = _ffag
	case *_fed.PdfObjectReference:
		_aaegd := _ffag.Resolve()
		return _ebed(_aaegd)
	default:
		_fef.Log.Error("\u0044\u0065\u0076\u0069c\u0065\u004e\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075t\u0065 \u0074\u0079\u0070\u0065\u0020\u0065\u0072r\u006f\u0072")
		return nil, _bb.New("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _gbced := _ddda.Get("\u0053u\u0062\u0074\u0079\u0070\u0065"); _gbced != nil {
		_gcbgc, _abec := _fed.TraceToDirectObject(_gbced).(*_fed.PdfObjectName)
		if !_abec {
			_fef.Log.Error("\u0044\u0065vi\u0063\u0065\u004e \u0061\u0074\u0074\u0072ibu\u0074e \u0053\u0075\u0062\u0074\u0079\u0070\u0065 t\u0079\u0070\u0065\u0020\u0065\u0072\u0072o\u0072")
			return nil, _bb.New("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_fcbcb.Subtype = _gcbgc
	}
	if _geab := _ddda.Get("\u0043o\u006c\u006f\u0072\u0061\u006e\u0074s"); _geab != nil {
		_fcbcb.Colorants = _geab
	}
	if _daab := _ddda.Get("\u0050r\u006f\u0063\u0065\u0073\u0073"); _daab != nil {
		_fcbcb.Process = _daab
	}
	if _ccdcc := _ddda.Get("M\u0069\u0078\u0069\u006e\u0067\u0048\u0069\u006e\u0074\u0073"); _ccdcc != nil {
		_fcbcb.MixingHints = _ccdcc
	}
	return _fcbcb, nil
}

// XObjectImage (Table 89 in 8.9.5.1).
// Implements PdfModel interface.
type XObjectImage struct {

	//ColorSpace       PdfObject
	Width            *int64
	Height           *int64
	ColorSpace       PdfColorspace
	BitsPerComponent *int64
	Filter           _fed.StreamEncoder
	Intent           _fed.PdfObject
	ImageMask        _fed.PdfObject
	Mask             _fed.PdfObject
	Matte            _fed.PdfObject
	Decode           _fed.PdfObject
	Interpolate      _fed.PdfObject
	Alternatives     _fed.PdfObject
	SMask            _fed.PdfObject
	SMaskInData      _fed.PdfObject
	Name             _fed.PdfObject
	StructParent     _fed.PdfObject
	ID               _fed.PdfObject
	OPI              _fed.PdfObject
	Metadata         _fed.PdfObject
	OC               _fed.PdfObject
	Stream           []byte
	_agffg           *_fed.PdfObjectStream
}

// StdFontName represents name of a standard font.
type StdFontName = _geg.StdFontName

// GetContainingPdfObject returns the container of the outline tree node (indirect object).
func (_babba *PdfOutlineTreeNode) GetContainingPdfObject() _fed.PdfObject {
	return _babba.GetContext().GetContainingPdfObject()
}

// A returns the value of the A component of the color.
func (_ccaf *PdfColorCalRGB) A() float64 { return _ccaf[0] }
func _daadc(_ecfg *PdfPage) {
	_cbcca := _fed.PdfObjectName("\u0055\u0046\u0031")
	if !_ecfg.Resources.HasFontByName(_cbcca) {
		_ecfg.Resources.SetFontByName(_cbcca, DefaultFont().ToPdfObject())
	}
	_ecfg.ToPdfObject()
}

// Encoder returns the font's text encoder.
func (_dgbbg pdfFontType3) Encoder() _dg.TextEncoder { return _dgbbg._gefc }

// PartialName returns the partial name of the field.
func (_agg *PdfField) PartialName() string {
	_ffdd := ""
	if _agg.T != nil {
		_ffdd = _agg.T.Decoded()
	} else {
		_fef.Log.Debug("\u0046\u0069el\u0064\u0020\u006di\u0073\u0073\u0069\u006eg T\u0020fi\u0065\u006c\u0064\u0020\u0028\u0069\u006eco\u006d\u0070\u0061\u0074\u0069\u0062\u006ce\u0029")
	}
	return _ffdd
}

// SetPdfTitle sets the Title attribute of the output PDF.
func SetPdfTitle(title string) { _abadca.Lock(); defer _abadca.Unlock(); _gfcfc = title }

type pdfFontType3 struct {
	fontCommon
	_fdaf *_fed.PdfIndirectObject

	// These fields are specific to Type 3 fonts.
	CharProcs  _fed.PdfObject
	Encoding   _fed.PdfObject
	FontBBox   _fed.PdfObject
	FontMatrix _fed.PdfObject
	FirstChar  _fed.PdfObject
	LastChar   _fed.PdfObject
	Widths     _fed.PdfObject
	Resources  _fed.PdfObject
	_cadbe     map[_dg.CharCode]float64
	_gefc      _dg.TextEncoder
}

// NewPdfSignature creates a new PdfSignature object.
func NewPdfSignature(handler SignatureHandler) *PdfSignature {
	_gfede := &PdfSignature{Type: _fed.MakeName("\u0053\u0069\u0067"), Handler: handler}
	_debga := &pdfSignDictionary{PdfObjectDictionary: _fed.MakeDict(), _gdgfa: &handler, _agafa: _gfede}
	_gfede._gccdf = _fed.MakeIndirectObject(_debga)
	return _gfede
}
func _dbcg(_fafd _fed.PdfObject) (*PdfColorspaceSpecialIndexed, error) {
	_ebda := NewPdfColorspaceSpecialIndexed()
	if _fdgc, _ebff := _fafd.(*_fed.PdfIndirectObject); _ebff {
		_ebda._bedg = _fdgc
	}
	_fafd = _fed.TraceToDirectObject(_fafd)
	_bdfd, _efeb := _fafd.(*_fed.PdfObjectArray)
	if !_efeb {
		return nil, _d.Errorf("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _bdfd.Len() != 4 {
		return nil, _d.Errorf("\u0069\u006e\u0064\u0065\u0078\u0065\u0064\u0020\u0043\u0053\u003a\u0020\u0069\u006e\u0076a\u006ci\u0064\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068")
	}
	_fafd = _bdfd.Get(0)
	_edcc, _efeb := _fafd.(*_fed.PdfObjectName)
	if !_efeb {
		return nil, _d.Errorf("\u0069n\u0064\u0065\u0078\u0065\u0064\u0020\u0043\u0053\u003a\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u006e\u0061\u006d\u0065")
	}
	if *_edcc != "\u0049n\u0064\u0065\u0078\u0065\u0064" {
		return nil, _d.Errorf("\u0069\u006e\u0064\u0065xe\u0064\u0020\u0043\u0053\u003a\u0020\u0077\u0072\u006f\u006e\u0067\u0020\u006e\u0061m\u0065")
	}
	_fafd = _bdfd.Get(1)
	_abeb, _fgbd := DetermineColorspaceNameFromPdfObject(_fafd)
	if _fgbd != nil {
		return nil, _fgbd
	}
	if _abeb == "\u0049n\u0064\u0065\u0078\u0065\u0064" || _abeb == "\u0050a\u0074\u0074\u0065\u0072\u006e" {
		_fef.Log.Debug("E\u0072\u0072o\u0072\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0068\u0061\u0076\u0065\u0020\u0049\u006e\u0064e\u0078\u0065\u0064\u002f\u0050\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0043S\u0020\u0061\u0073\u0020\u0062\u0061\u0073\u0065\u0020\u0028\u0025v\u0029", _abeb)
		return nil, _fbdeg
	}
	_cbcd, _fgbd := NewPdfColorspaceFromPdfObject(_fafd)
	if _fgbd != nil {
		return nil, _fgbd
	}
	_ebda.Base = _cbcd
	_fafd = _bdfd.Get(2)
	_cccd, _fgbd := _fed.GetNumberAsInt64(_fafd)
	if _fgbd != nil {
		return nil, _fgbd
	}
	if _cccd > 255 {
		return nil, _d.Errorf("\u0069n\u0064\u0065\u0078\u0065d\u0020\u0043\u0053\u003a\u0020I\u006ev\u0061l\u0069\u0064\u0020\u0068\u0069\u0076\u0061l")
	}
	_ebda.HiVal = int(_cccd)
	_fafd = _bdfd.Get(3)
	_ebda.Lookup = _fafd
	_fafd = _fed.TraceToDirectObject(_fafd)
	var _ecab []byte
	if _fffd, _edbg := _fafd.(*_fed.PdfObjectString); _edbg {
		_ecab = _fffd.Bytes()
		_fef.Log.Trace("\u0049\u006e\u0064\u0065\u0078\u0065\u0064\u0020\u0073\u0074r\u0069\u006e\u0067\u0020\u0063\u006f\u006co\u0072\u0020\u0064\u0061\u0074\u0061\u003a\u0020\u0025\u0020\u0064", _ecab)
	} else if _ebfb, _fccf := _fafd.(*_fed.PdfObjectStream); _fccf {
		_fef.Log.Trace("\u0049n\u0064e\u0078\u0065\u0064\u0020\u0073t\u0072\u0065a\u006d\u003a\u0020\u0025\u0073", _fafd.String())
		_fef.Log.Trace("\u0045\u006e\u0063\u006fde\u0064\u0020\u0028\u0025\u0064\u0029\u0020\u003a\u0020\u0025\u0023\u0020\u0078", len(_ebfb.Stream), _ebfb.Stream)
		_cgaag, _acgd := _fed.DecodeStream(_ebfb)
		if _acgd != nil {
			return nil, _acgd
		}
		_fef.Log.Trace("\u0044e\u0063o\u0064\u0065\u0064\u0020\u0028%\u0064\u0029 \u003a\u0020\u0025\u0020\u0058", len(_cgaag), _cgaag)
		_ecab = _cgaag
	} else {
		_fef.Log.Debug("\u0054\u0079\u0070\u0065\u003a\u0020\u0025\u0054", _fafd)
		return nil, _d.Errorf("\u0069\u006e\u0064\u0065\u0078\u0065\u0064\u0020\u0043\u0053\u003a\u0020\u0049\u006e\u0076a\u006ci\u0064\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0066\u006f\u0072\u006d\u0061\u0074")
	}
	if len(_ecab) < _ebda.Base.GetNumComponents()*(_ebda.HiVal+1) {
		_fef.Log.Debug("\u0050\u0044\u0046\u0020\u0049\u006e\u0063o\u006d\u0070\u0061t\u0069\u0062\u0069\u006ci\u0074\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074\u006f\u006f\u0020\u0073\u0068\u006f\u0072\u0074")
		_fef.Log.Debug("\u0046\u0061i\u006c\u002c\u0020\u006c\u0065\u006e\u0028\u0064\u0061\u0074\u0061\u0029\u003a\u0020\u0025\u0064\u002c\u0020\u0063\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073\u003a\u0020\u0025\u0064\u002c\u0020\u0068\u0069\u0056\u0061\u006c\u003a\u0020\u0025\u0064", len(_ecab), _ebda.Base.GetNumComponents(), _ebda.HiVal)
	} else {
		_ecab = _ecab[:_ebda.Base.GetNumComponents()*(_ebda.HiVal+1)]
	}
	_ebda._defd = _ecab
	return _ebda, nil
}

// NewPdfActionImportData returns a new "import data" action.
func NewPdfActionImportData() *PdfActionImportData {
	_cce := NewPdfAction()
	_cda := &PdfActionImportData{}
	_cda.PdfAction = _cce
	_cce.SetContext(_cda)
	return _cda
}
func _eefba(_dfcfb _fed.PdfObject) (*PdfFunctionType2, error) {
	_fega := &PdfFunctionType2{}
	var _fabee *_fed.PdfObjectDictionary
	if _ggec, _gbgec := _dfcfb.(*_fed.PdfIndirectObject); _gbgec {
		_dedag, _cfcegg := _ggec.PdfObject.(*_fed.PdfObjectDictionary)
		if !_cfcegg {
			return nil, _bb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_fega._fbebb = _ggec
		_fabee = _dedag
	} else if _dbgfc, _gffee := _dfcfb.(*_fed.PdfObjectDictionary); _gffee {
		_fabee = _dbgfc
	} else {
		return nil, _bb.New("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	_fef.Log.Trace("\u0046U\u004e\u0043\u0032\u003a\u0020\u0025s", _fabee.String())
	_aeaadc, _dced := _fed.TraceToDirectObject(_fabee.Get("\u0044\u006f\u006d\u0061\u0069\u006e")).(*_fed.PdfObjectArray)
	if !_dced {
		_fef.Log.Error("D\u006fm\u0061\u0069\u006e\u0020\u006e\u006f\u0074\u0020s\u0070\u0065\u0063\u0069fi\u0065\u0064")
		return nil, _bb.New("\u0072\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u006f\u0072\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if _aeaadc.Len() < 0 || _aeaadc.Len()%2 != 0 {
		_fef.Log.Error("D\u006fm\u0061\u0069\u006e\u0020\u0072\u0061\u006e\u0067e\u0020\u0069\u006e\u0076al\u0069\u0064")
		return nil, _bb.New("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0064\u006f\u006da\u0069\u006e\u0020\u0072an\u0067\u0065")
	}
	_efgcd, _geega := _aeaadc.ToFloat64Array()
	if _geega != nil {
		return nil, _geega
	}
	_fega.Domain = _efgcd
	_aeaadc, _dced = _fed.TraceToDirectObject(_fabee.Get("\u0052\u0061\u006eg\u0065")).(*_fed.PdfObjectArray)
	if _dced {
		if _aeaadc.Len() < 0 || _aeaadc.Len()%2 != 0 {
			return nil, _bb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0061\u006e\u0067\u0065")
		}
		_ddebg, _beda := _aeaadc.ToFloat64Array()
		if _beda != nil {
			return nil, _beda
		}
		_fega.Range = _ddebg
	}
	_aeaadc, _dced = _fed.TraceToDirectObject(_fabee.Get("\u0043\u0030")).(*_fed.PdfObjectArray)
	if _dced {
		_ecaed, _cgaf := _aeaadc.ToFloat64Array()
		if _cgaf != nil {
			return nil, _cgaf
		}
		_fega.C0 = _ecaed
	}
	_aeaadc, _dced = _fed.TraceToDirectObject(_fabee.Get("\u0043\u0031")).(*_fed.PdfObjectArray)
	if _dced {
		_beaed, _aaeffd := _aeaadc.ToFloat64Array()
		if _aaeffd != nil {
			return nil, _aaeffd
		}
		_fega.C1 = _beaed
	}
	if len(_fega.C0) != len(_fega.C1) {
		_fef.Log.Error("\u0043\u0030\u0020\u0061nd\u0020\u0043\u0031\u0020\u006e\u006f\u0074\u0020\u006d\u0061\u0074\u0063\u0068\u0069n\u0067")
		return nil, _fed.ErrRangeError
	}
	N, _geega := _fed.GetNumberAsFloat(_fed.TraceToDirectObject(_fabee.Get("\u004e")))
	if _geega != nil {
		_fef.Log.Error("\u004e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020o\u0072\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u002c\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073", _fabee.String())
		return nil, _geega
	}
	_fega.N = N
	return _fega, nil
}

// BorderStyle defines border type, typically used for annotations.
type BorderStyle int

func (_cabc *PdfColorspaceICCBased) String() string {
	return "\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064"
}

// NewPdfOutlineTree returns an initialized PdfOutline tree.
func NewPdfOutlineTree() *PdfOutline {
	_dagcef := NewPdfOutline()
	_dagcef._ffgd = &_dagcef
	return _dagcef
}

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components. The slice should contain a single element between 0 and 1.
func (_gbdb *PdfColorspaceCalGray) ColorFromFloats(vals []float64) (PdfColor, error) {
	if len(vals) != 1 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_bfbd := vals[0]
	if _bfbd < 0.0 || _bfbd > 1.0 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_eggcg := NewPdfColorCalGray(_bfbd)
	return _eggcg, nil
}

// ToPdfObject converts the font to a PDF representation.
func (_dgcge *pdfFontType0) ToPdfObject() _fed.PdfObject {
	if _dgcge._deadb == nil {
		_dgcge._deadb = &_fed.PdfIndirectObject{}
	}
	_cfec := _dgcge.baseFields().asPdfObjectDictionary("\u0054\u0079\u0070e\u0030")
	_dgcge._deadb.PdfObject = _cfec
	if _dgcge.Encoding != nil {
		_cfec.Set("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", _dgcge.Encoding)
	} else if _dgcge._eeabd != nil {
		_cfec.Set("\u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067", _dgcge._eeabd.ToPdfObject())
	}
	if _dgcge.DescendantFont != nil {
		_cfec.Set("\u0044e\u0073c\u0065\u006e\u0064\u0061\u006e\u0074\u0046\u006f\u006e\u0074\u0073", _fed.MakeArray(_dgcge.DescendantFont.ToPdfObject()))
	}
	return _dgcge._deadb
}

// ValidateSignatures validates digital signatures in the document.
func (_fffdff *PdfReader) ValidateSignatures(handlers []SignatureHandler) ([]SignatureValidationResult, error) {
	if _fffdff.AcroForm == nil {
		return nil, nil
	}
	if _fffdff.AcroForm.Fields == nil {
		return nil, nil
	}
	type sigFieldPair struct {
		_egcba *PdfSignature
		_ccaeb *PdfField
		_fgafb SignatureHandler
	}
	var _aabddd []*sigFieldPair
	for _, _efbg := range _fffdff.AcroForm.AllFields() {
		if _efbg.V == nil {
			continue
		}
		if _abafag, _ecfdc := _fed.GetDict(_efbg.V); _ecfdc {
			if _faad, _fagga := _fed.GetNameVal(_abafag.Get("\u0054\u0079\u0070\u0065")); _fagga && _faad == "\u0053\u0069\u0067" {
				_aaggb, _cedgf := _fed.GetIndirect(_efbg.V)
				if !_cedgf {
					_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0063\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0020\u0069s\u0020\u006e\u0069\u006c")
					return nil, ErrTypeCheck
				}
				_adbfa, _fecga := _fffdff.newPdfSignatureFromIndirect(_aaggb)
				if _fecga != nil {
					return nil, _fecga
				}
				var _gcdgb SignatureHandler
				for _, _afcb := range handlers {
					if _afcb.IsApplicable(_adbfa) {
						_gcdgb = _afcb
						break
					}
				}
				_aabddd = append(_aabddd, &sigFieldPair{_egcba: _adbfa, _ccaeb: _efbg, _fgafb: _gcdgb})
			}
		}
	}
	var _ddggc []SignatureValidationResult
	for _, _gbbfe := range _aabddd {
		_efbc := SignatureValidationResult{IsSigned: true, Fields: []*PdfField{_gbbfe._ccaeb}}
		if _gbbfe._fgafb == nil {
			_efbc.Errors = append(_efbc.Errors, "\u0068a\u006ed\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0073\u0065\u0074")
			_ddggc = append(_ddggc, _efbc)
			continue
		}
		_dfgc, _abfgg := _gbbfe._fgafb.NewDigest(_gbbfe._egcba)
		if _abfgg != nil {
			_efbc.Errors = append(_efbc.Errors, "\u0064\u0069\u0067e\u0073\u0074\u0020\u0065\u0072\u0072\u006f\u0072", _abfgg.Error())
			_ddggc = append(_ddggc, _efbc)
			continue
		}
		_gbcea := _gbbfe._egcba.ByteRange
		if _gbcea == nil {
			_efbc.Errors = append(_efbc.Errors, "\u0042\u0079\u0074\u0065\u0052\u0061\u006e\u0067\u0065\u0020\u006e\u006ft\u0020\u0073\u0065\u0074")
			_ddggc = append(_ddggc, _efbc)
			continue
		}
		for _adceg := 0; _adceg < _gbcea.Len(); _adceg = _adceg + 2 {
			_gegc, _ := _fed.GetNumberAsInt64(_gbcea.Get(_adceg))
			_aeadf, _ := _fed.GetIntVal(_gbcea.Get(_adceg + 1))
			if _, _becgc := _fffdff._faefaf.Seek(_gegc, _ge.SeekStart); _becgc != nil {
				return nil, _becgc
			}
			_babaf := make([]byte, _aeadf)
			if _, _cbccdb := _fffdff._faefaf.Read(_babaf); _cbccdb != nil {
				return nil, _cbccdb
			}
			_dfgc.Write(_babaf)
		}
		_acefg, _abfgg := _gbbfe._fgafb.Validate(_gbbfe._egcba, _dfgc)
		if _abfgg != nil {
			return nil, _abfgg
		}
		_acefg.Name = _gbbfe._egcba.Name.Decoded()
		_acefg.Reason = _gbbfe._egcba.Reason.Decoded()
		if _gbbfe._egcba.M != nil {
			_eaedf, _geadf := NewPdfDate(_gbbfe._egcba.M.String())
			if _geadf != nil {
				_acefg.Errors = append(_acefg.Errors, _geadf.Error())
				continue
			}
			_acefg.Date = _eaedf
		}
		_acefg.ContactInfo = _gbbfe._egcba.ContactInfo.Decoded()
		_acefg.Location = _gbbfe._egcba.Location.Decoded()
		_acefg.Fields = _efbc.Fields
		_ddggc = append(_ddggc, _acefg)
	}
	return _ddggc, nil
}

// PdfAction represents an action in PDF (section 12.6 p. 412).
type PdfAction struct {
	_fcc PdfModel
	Type _fed.PdfObject
	S    _fed.PdfObject
	Next _fed.PdfObject
	_fa  *_fed.PdfIndirectObject
}

// PdfActionHide represents a hide action.
type PdfActionHide struct {
	*PdfAction
	T _fed.PdfObject
	H _fed.PdfObject
}

// ToPdfObject returns a PDF object representation of the outline.
func (_caaab *Outline) ToPdfObject() _fed.PdfObject { return _caaab.ToPdfOutline().ToPdfObject() }
func (_dbg *PdfReader) newPdfAnnotationPopupFromDict(_fdde *_fed.PdfObjectDictionary) (*PdfAnnotationPopup, error) {
	_ageg := PdfAnnotationPopup{}
	_ageg.Parent = _fdde.Get("\u0050\u0061\u0072\u0065\u006e\u0074")
	_ageg.Open = _fdde.Get("\u004f\u0070\u0065\u006e")
	return &_ageg, nil
}

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// components. The slice should contain three PdfObjectFloat elements representing
// the A, B and C components of the color.
func (_facf *PdfColorspaceCalRGB) ColorFromPdfObjects(objects []_fed.PdfObject) (PdfColor, error) {
	if len(objects) != 3 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_agce, _edcfd := _fed.GetNumbersAsFloat(objects)
	if _edcfd != nil {
		return nil, _edcfd
	}
	return _facf.ColorFromFloats(_agce)
}

// Hasher is the interface that wraps the basic Write method.
type Hasher interface {
	Write(_gaafcg []byte) (_dgbfd int, _ebcg error)
}

func _bgcca(_gcca *_fed.PdfObjectDictionary) (*PdfShadingType7, error) {
	_gbdba := PdfShadingType7{}
	_ggaadb := _gcca.Get("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065")
	if _ggaadb == nil {
		_fef.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064 \u0061\u0074\u0074\u0072\u0069\u0062\u0075t\u0065\u0020\u006d\u0069\u0073\u0073i\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072C\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_cbeea, _dbbeb := _ggaadb.(*_fed.PdfObjectInteger)
	if !_dbbeb {
		_fef.Log.Debug("\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _ggaadb)
		return nil, _fed.ErrTypeError
	}
	_gbdba.BitsPerCoordinate = _cbeea
	_ggaadb = _gcca.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074")
	if _ggaadb == nil {
		_fef.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064\u0020a\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073\u0073in\u0067\u003a\u0020B\u0069\u0074s\u0050\u0065\u0072\u0043\u006f\u006dp\u006f\u006ee\u006e\u0074")
		return nil, ErrRequiredAttributeMissing
	}
	_cbeea, _dbbeb = _ggaadb.(*_fed.PdfObjectInteger)
	if !_dbbeb {
		_fef.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065r \u0028\u0067\u006ft\u0020%\u0054\u0029", _ggaadb)
		return nil, _fed.ErrTypeError
	}
	_gbdba.BitsPerComponent = _cbeea
	_ggaadb = _gcca.Get("B\u0069\u0074\u0073\u0050\u0065\u0072\u0046\u006c\u0061\u0067")
	if _ggaadb == nil {
		_fef.Log.Debug("\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065r\u0046\u006c\u0061\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_cbeea, _dbbeb = _ggaadb.(*_fed.PdfObjectInteger)
	if !_dbbeb {
		_fef.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072F\u006c\u0061\u0067\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025T\u0029", _ggaadb)
		return nil, _fed.ErrTypeError
	}
	_gbdba.BitsPerComponent = _cbeea
	_ggaadb = _gcca.Get("\u0044\u0065\u0063\u006f\u0064\u0065")
	if _ggaadb == nil {
		_fef.Log.Debug("\u0052\u0065\u0071ui\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069b\u0075t\u0065 \u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_bfddf, _dbbeb := _ggaadb.(*_fed.PdfObjectArray)
	if !_dbbeb {
		_fef.Log.Debug("\u0044\u0065\u0063\u006fd\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _ggaadb)
		return nil, _fed.ErrTypeError
	}
	_gbdba.Decode = _bfddf
	if _agaag := _gcca.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e"); _agaag != nil {
		_gbdba.Function = []PdfFunction{}
		if _ceac, _bbagg := _agaag.(*_fed.PdfObjectArray); _bbagg {
			for _, _cagdc := range _ceac.Elements() {
				_cgdc, _adabb := _bggad(_cagdc)
				if _adabb != nil {
					_fef.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _adabb)
					return nil, _adabb
				}
				_gbdba.Function = append(_gbdba.Function, _cgdc)
			}
		} else {
			_gbfgd, _acdgc := _bggad(_agaag)
			if _acdgc != nil {
				_fef.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _acdgc)
				return nil, _acdgc
			}
			_gbdba.Function = append(_gbdba.Function, _gbfgd)
		}
	}
	return &_gbdba, nil
}

// GetFontByName gets the font specified by keyName. Returns the PdfObject which
// the entry refers to. Returns a bool value indicating whether or not the entry was found.
func (_edba *PdfPageResources) GetFontByName(keyName _fed.PdfObjectName) (_fed.PdfObject, bool) {
	if _edba.Font == nil {
		return nil, false
	}
	_fdbda, _agff := _fed.TraceToDirectObject(_edba.Font).(*_fed.PdfObjectDictionary)
	if !_agff {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006fn\u0061\u0072\u0079\u0021\u0020(\u0067\u006ft\u0020\u0025\u0054\u0029", _fed.TraceToDirectObject(_edba.Font))
		return nil, false
	}
	if _fefb := _fdbda.Get(keyName); _fefb != nil {
		return _fefb, true
	}
	return nil, false
}
func (_dcbd *DSS) add(_dfeg *[]*_fed.PdfObjectStream, _eadbc map[string]*_fed.PdfObjectStream, _fedc [][]byte) ([]*_fed.PdfObjectStream, error) {
	_eeed := make([]*_fed.PdfObjectStream, 0, len(_fedc))
	for _, _accfa := range _fedc {
		_dagac, _febfe := _dfebf(_accfa)
		if _febfe != nil {
			return nil, _febfe
		}
		_bbacd, _cbef := _eadbc[string(_dagac)]
		if !_cbef {
			_bbacd, _febfe = _fed.MakeStream(_accfa, _fed.NewRawEncoder())
			if _febfe != nil {
				return nil, _febfe
			}
			_eadbc[string(_dagac)] = _bbacd
			*_dfeg = append(*_dfeg, _bbacd)
		}
		_eeed = append(_eeed, _bbacd)
	}
	return _eeed, nil
}

// GetContainingPdfObject returns the container of the DSS (indirect object).
func (_egeb *DSS) GetContainingPdfObject() _fed.PdfObject { return _egeb._dcaa }

// EncryptOptions represents encryption options for an output PDF.
type EncryptOptions struct {
	Permissions _ae.Permissions
	Algorithm   EncryptionAlgorithm
}

func (_ddad *PdfReader) newPdfActionJavaScriptFromDict(_bcd *_fed.PdfObjectDictionary) (*PdfActionJavaScript, error) {
	return &PdfActionJavaScript{JS: _bcd.Get("\u004a\u0053")}, nil
}
func (_eacg *PdfReader) newPdfAnnotationSquareFromDict(_bbf *_fed.PdfObjectDictionary) (*PdfAnnotationSquare, error) {
	_cgcb := PdfAnnotationSquare{}
	_beb, _gggc := _eacg.newPdfAnnotationMarkupFromDict(_bbf)
	if _gggc != nil {
		return nil, _gggc
	}
	_cgcb.PdfAnnotationMarkup = _beb
	_cgcb.BS = _bbf.Get("\u0042\u0053")
	_cgcb.IC = _bbf.Get("\u0049\u0043")
	_cgcb.BE = _bbf.Get("\u0042\u0045")
	_cgcb.RD = _bbf.Get("\u0052\u0044")
	return &_cgcb, nil
}

// PdfColorspaceSpecialIndexed is an indexed color space is a lookup table, where the input element
// is an index to the lookup table and the output is a color defined in the lookup table in the Base
// colorspace.
// [/Indexed base hival lookup]
type PdfColorspaceSpecialIndexed struct {
	Base   PdfColorspace
	HiVal  int
	Lookup _fed.PdfObject
	_defd  []byte
	_bedg  *_fed.PdfIndirectObject
}

// SetImage updates XObject Image with new image data.
func (_aeggff *XObjectImage) SetImage(img *Image, cs PdfColorspace) error {
	_aeggff.Filter.UpdateParams(img.GetParamsDict())
	_eaaed, _faacd := _aeggff.Filter.EncodeBytes(img.Data)
	if _faacd != nil {
		return _faacd
	}
	_aeggff.Stream = _eaaed
	_egbde := img.Width
	_aeggff.Width = &_egbde
	_cgcef := img.Height
	_aeggff.Height = &_cgcef
	_fgacb := img.BitsPerComponent
	_aeggff.BitsPerComponent = &_fgacb
	if cs == nil {
		if img.ColorComponents == 1 {
			_aeggff.ColorSpace = NewPdfColorspaceDeviceGray()
		} else if img.ColorComponents == 3 {
			_aeggff.ColorSpace = NewPdfColorspaceDeviceRGB()
		} else if img.ColorComponents == 4 {
			_aeggff.ColorSpace = NewPdfColorspaceDeviceCMYK()
		} else {
			return _bb.New("c\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020u\u006e\u0064\u0065\u0066in\u0065\u0064")
		}
	} else {
		_aeggff.ColorSpace = cs
	}
	return nil
}
func (_bffaf *PdfReader) loadOutlines() (*PdfOutlineTreeNode, error) {
	if _bffaf._cdfggf.GetCrypter() != nil && !_bffaf._cdfggf.IsAuthenticated() {
		return nil, _d.Errorf("\u0066\u0069\u006ce\u0020\u006e\u0065\u0065d\u0020\u0074\u006f\u0020\u0062\u0065\u0020d\u0065\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0020\u0066\u0069\u0072\u0073\u0074")
	}
	_bbcd := _bffaf._bfcdc
	_afddd := _bbcd.Get("\u004f\u0075\u0074\u006c\u0069\u006e\u0065\u0073")
	if _afddd == nil {
		return nil, nil
	}
	_fef.Log.Trace("\u002d\u0048\u0061\u0073\u0020\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u0073")
	_gefbe := _fed.ResolveReference(_afddd)
	_fef.Log.Trace("\u004f\u0075t\u006c\u0069\u006ee\u0020\u0072\u006f\u006f\u0074\u003a\u0020\u0025\u0076", _gefbe)
	if _dafec := _fed.IsNullObject(_gefbe); _dafec {
		_fef.Log.Trace("\u004f\u0075\u0074li\u006e\u0065\u0020\u0072\u006f\u006f\u0074\u0020\u0069s\u0020n\u0075l\u006c \u002d\u0020\u006e\u006f\u0020\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u0073")
		return nil, nil
	}
	_fbcf, _bcebe := _gefbe.(*_fed.PdfIndirectObject)
	if !_bcebe {
		if _, _gdegec := _fed.GetDict(_gefbe); !_gdegec {
			_fef.Log.Debug("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020o\u0075\u0074\u006c\u0069\u006e\u0065\u0020r\u006f\u006f\u0074\u0020\u002d\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067")
			return nil, nil
		}
		_fef.Log.Debug("\u004f\u0075t\u006c\u0069\u006e\u0065\u0020r\u006f\u006f\u0074\u0020\u0069s\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u002e\u0020\u0053\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074")
		_fbcf = _fed.MakeIndirectObject(_gefbe)
	}
	_gaaec, _bcebe := _fbcf.PdfObject.(*_fed.PdfObjectDictionary)
	if !_bcebe {
		return nil, _bb.New("\u006f\u0075\u0074\u006c\u0069n\u0065\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072y")
	}
	_fef.Log.Trace("O\u0075\u0074\u006c\u0069ne\u0020r\u006f\u006f\u0074\u0020\u0064i\u0063\u0074\u003a\u0020\u0025\u0076", _gaaec)
	_cbaaeg, _, _dcdgb := _bffaf.buildOutlineTree(_fbcf, nil, nil, nil)
	if _dcdgb != nil {
		return nil, _dcdgb
	}
	_fef.Log.Trace("\u0052\u0065\u0073\u0075\u006c\u0074\u0069\u006e\u0067\u0020\u006fu\u0074\u006c\u0069\u006e\u0065\u0020\u0074\u0072\u0065\u0065:\u0020\u0025\u0076", _cbaaeg)
	return _cbaaeg, nil
}

// ToInteger convert to an integer format.
func (_eaab *PdfColorLab) ToInteger(bits int) [3]uint32 {
	_ggad := _bg.Pow(2, float64(bits)) - 1
	return [3]uint32{uint32(_ggad * _eaab.L()), uint32(_ggad * _eaab.A()), uint32(_ggad * _eaab.B())}
}

// ButtonType represents the subtype of a button field, can be one of:
// - Checkbox (ButtonTypeCheckbox)
// - PushButton (ButtonTypePushButton)
// - RadioButton (ButtonTypeRadioButton)
type ButtonType int

func _cgafc(_geedd *_fed.PdfObjectDictionary) (*PdfShadingType4, error) {
	_decf := PdfShadingType4{}
	_dbdfa := _geedd.Get("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065")
	if _dbdfa == nil {
		_fef.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064 \u0061\u0074\u0074\u0072\u0069\u0062\u0075t\u0065\u0020\u006d\u0069\u0073\u0073i\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072C\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_cfcca, _gcbed := _dbdfa.(*_fed.PdfObjectInteger)
	if !_gcbed {
		_fef.Log.Debug("\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006f\u0072\u0064\u0069\u006e\u0061\u0074\u0065\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _dbdfa)
		return nil, _fed.ErrTypeError
	}
	_decf.BitsPerCoordinate = _cfcca
	_dbdfa = _geedd.Get("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074")
	if _dbdfa == nil {
		_fef.Log.Debug("\u0052e\u0071\u0075i\u0072\u0065\u0064\u0020a\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006d\u0069\u0073\u0073in\u0067\u003a\u0020B\u0069\u0074s\u0050\u0065\u0072\u0043\u006f\u006dp\u006f\u006ee\u006e\u0074")
		return nil, ErrRequiredAttributeMissing
	}
	_cfcca, _gcbed = _dbdfa.(*_fed.PdfObjectInteger)
	if !_gcbed {
		_fef.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065r \u0028\u0067\u006ft\u0020%\u0054\u0029", _dbdfa)
		return nil, _fed.ErrTypeError
	}
	_decf.BitsPerComponent = _cfcca
	_dbdfa = _geedd.Get("B\u0069\u0074\u0073\u0050\u0065\u0072\u0046\u006c\u0061\u0067")
	if _dbdfa == nil {
		_fef.Log.Debug("\u0052\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0042\u0069\u0074\u0073\u0050\u0065r\u0046\u006c\u0061\u0067")
		return nil, ErrRequiredAttributeMissing
	}
	_cfcca, _gcbed = _dbdfa.(*_fed.PdfObjectInteger)
	if !_gcbed {
		_fef.Log.Debug("B\u0069\u0074\u0073\u0050\u0065\u0072F\u006c\u0061\u0067\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0028\u0067\u006f\u0074\u0020\u0025T\u0029", _dbdfa)
		return nil, _fed.ErrTypeError
	}
	_decf.BitsPerComponent = _cfcca
	_dbdfa = _geedd.Get("\u0044\u0065\u0063\u006f\u0064\u0065")
	if _dbdfa == nil {
		_fef.Log.Debug("\u0052\u0065\u0071ui\u0072\u0065\u0064\u0020\u0061\u0074\u0074\u0072\u0069b\u0075t\u0065 \u006di\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065")
		return nil, ErrRequiredAttributeMissing
	}
	_gcacgb, _gcbed := _dbdfa.(*_fed.PdfObjectArray)
	if !_gcbed {
		_fef.Log.Debug("\u0044\u0065\u0063\u006fd\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0061r\u0072a\u0079\u0020\u0028\u0067\u006f\u0074\u0020%\u0054\u0029", _dbdfa)
		return nil, _fed.ErrTypeError
	}
	_decf.Decode = _gcacgb
	_dbdfa = _geedd.Get("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e")
	if _dbdfa == nil {
		_fef.Log.Debug("\u0052\u0065q\u0075\u0069\u0072\u0065d\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020m\u0069\u0073\u0073\u0069\u006e\u0067\u003a\u0020\u0020\u0046\u0075\u006ec\u0074\u0069\u006f\u006e")
		return nil, ErrRequiredAttributeMissing
	}
	_decf.Function = []PdfFunction{}
	if _gcgda, _caacb := _dbdfa.(*_fed.PdfObjectArray); _caacb {
		for _, _bbdge := range _gcgda.Elements() {
			_gdfdc, _dcgef := _bggad(_bbdge)
			if _dcgef != nil {
				_fef.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _dcgef)
				return nil, _dcgef
			}
			_decf.Function = append(_decf.Function, _gdfdc)
		}
	} else {
		_acgde, _ccdd := _bggad(_dbdfa)
		if _ccdd != nil {
			_fef.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e:\u0020\u0025\u0076", _ccdd)
			return nil, _ccdd
		}
		_decf.Function = append(_decf.Function, _acgde)
	}
	return &_decf, nil
}
func (_edage *pdfFontType0) subsetRegistered() error {
	_cbcc, _aggeg := _edage.DescendantFont._gdaa.(*pdfCIDFontType2)
	if !_aggeg {
		_fef.Log.Debug("\u0046\u006fnt\u0020\u006e\u006ft\u0020\u0073\u0075\u0070por\u0074ed\u0020\u0066\u006f\u0072\u0020\u0073\u0075bs\u0065\u0074\u0074\u0069\u006e\u0067\u0020%\u0054", _edage.DescendantFont)
		return nil
	}
	if _cbcc == nil {
		return nil
	}
	if _cbcc._bgdgb == nil {
		_fef.Log.Debug("\u004d\u0069\u0073si\u006e\u0067\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u006f\u0072")
		return nil
	}
	if _edage._eeabd == nil {
		_fef.Log.Debug("\u004e\u006f\u0020e\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0073\u0075\u0062s\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u0067\u006e\u006f\u0072\u0065\u0064")
		return nil
	}
	_ffccc, _aggeg := _fed.GetStream(_cbcc._bgdgb.FontFile2)
	if !_aggeg {
		_fef.Log.Debug("\u0045\u006d\u0062\u0065\u0064\u0064\u0065\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u0020\u002d\u002d\u0020\u0041\u0042\u004f\u0052T\u0020\u0073\u0075\u0062\u0073\u0065\u0074\u0074\u0069\u006e\u0067")
		return _bb.New("\u0066\u006f\u006e\u0074fi\u006c\u0065\u0032\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064")
	}
	_aeff, _bfcg := _fed.DecodeStream(_ffccc)
	if _bfcg != nil {
		_fef.Log.Debug("\u0044\u0065c\u006f\u0064\u0065 \u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076", _bfcg)
		return _bfcg
	}
	_gdbe, _bfcg := _cg.Parse(_eb.NewReader(_aeff))
	if _bfcg != nil {
		_fef.Log.Debug("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0025\u0064\u0020\u0062\u0079\u0074\u0065\u0020f\u006f\u006e\u0074", len(_ffccc.Stream))
		return _bfcg
	}
	var _fadfg []rune
	var _gade *_cg.Font
	switch _abdf := _edage._eeabd.(type) {
	case *_dg.TrueTypeFontEncoder:
		_fadfg = _abdf.RegisteredRunes()
		_gade, _bfcg = _gdbe.SubsetKeepRunes(_fadfg)
		if _bfcg != nil {
			_fef.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _bfcg)
			return _bfcg
		}
		_abdf.SubsetRegistered()
	case *_dg.IdentityEncoder:
		_fadfg = _abdf.RegisteredRunes()
		_dedeg := make([]_cg.GlyphIndex, len(_fadfg))
		for _acfa, _fdab := range _fadfg {
			_dedeg[_acfa] = _cg.GlyphIndex(_fdab)
		}
		_gade, _bfcg = _gdbe.SubsetKeepIndices(_dedeg)
		if _bfcg != nil {
			_fef.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _bfcg)
			return _bfcg
		}
	case _dg.SimpleEncoder:
		_bgcg := _abdf.Charcodes()
		for _, _cdgfc := range _bgcg {
			_ddbdc, _ddgeb := _abdf.CharcodeToRune(_cdgfc)
			if !_ddgeb {
				_fef.Log.Debug("\u0045\u0052\u0052O\u0052\u003a\u0020\u0075\u006e\u0061\u0062\u006c\u0065\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0063\u0068\u0061\u0072\u0063\u006f\u0064\u0065\u0020\u0074\u006f \u0072\u0075\u006e\u0065\u003a\u0020\u0025\u0064", _cdgfc)
				continue
			}
			_fadfg = append(_fadfg, _ddbdc)
		}
	default:
		return _d.Errorf("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063\u006f\u0064\u0065\u0072\u0020\u0066\u006f\u0072\u0020s\u0075\u0062\u0073\u0065\u0074t\u0069\u006eg\u003a\u0020\u0025\u0054", _edage._eeabd)
	}
	var _cagcg _eb.Buffer
	_bfcg = _gade.Write(&_cagcg)
	if _bfcg != nil {
		_fef.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _bfcg)
		return _bfcg
	}
	if _edage._ecfd != nil {
		_faaab := make(map[_edf.CharCode]rune, len(_fadfg))
		for _, _befa := range _fadfg {
			_gbdf, _gfaef := _edage._eeabd.RuneToCharcode(_befa)
			if !_gfaef {
				continue
			}
			_faaab[_edf.CharCode(_gbdf)] = _befa
		}
		_edage._ecfd = _edf.NewToUnicodeCMap(_faaab)
	}
	_ffccc, _bfcg = _fed.MakeStream(_cagcg.Bytes(), _fed.NewFlateEncoder())
	if _bfcg != nil {
		_fef.Log.Debug("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _bfcg)
		return _bfcg
	}
	_ffccc.Set("\u004ce\u006e\u0067\u0074\u0068\u0031", _fed.MakeInteger(int64(_cagcg.Len())))
	if _caef, _caeeb := _fed.GetStream(_cbcc._bgdgb.FontFile2); _caeeb {
		*_caef = *_ffccc
	} else {
		_cbcc._bgdgb.FontFile2 = _ffccc
	}
	_ecagg := _ddade()
	if len(_edage._daac) > 0 {
		_edage._daac = _gccb(_edage._daac, _ecagg)
	}
	if len(_cbcc._daac) > 0 {
		_cbcc._daac = _gccb(_cbcc._daac, _ecagg)
	}
	if len(_edage._ceab) > 0 {
		_edage._ceab = _gccb(_edage._ceab, _ecagg)
	}
	if _cbcc._bgdgb != nil {
		_fceb, _gfdb := _fed.GetName(_cbcc._bgdgb.FontName)
		if _gfdb && len(_fceb.String()) > 0 {
			_adeb := _gccb(_fceb.String(), _ecagg)
			_cbcc._bgdgb.FontName = _fed.MakeName(_adeb)
		}
	}
	return nil
}
func _deab() string { _abadca.Lock(); defer _abadca.Unlock(); return _acge }

// ToPdfOutline returns a low level PdfOutline object, based on the current
// instance.
func (_befaa *Outline) ToPdfOutline() *PdfOutline {
	_acfdc := NewPdfOutline()
	var _eaega []*PdfOutlineItem
	var _decd int64
	var _dbff *PdfOutlineItem
	for _, _cgebd := range _befaa.Entries {
		_bgfc, _bdba := _cgebd.ToPdfOutlineItem()
		_bgfc.Parent = &_acfdc.PdfOutlineTreeNode
		if _dbff != nil {
			_dbff.Next = &_bgfc.PdfOutlineTreeNode
			_bgfc.Prev = &_dbff.PdfOutlineTreeNode
		}
		_eaega = append(_eaega, _bgfc)
		_decd += _bdba
		_dbff = _bgfc
	}
	_fgdc := int64(len(_eaega))
	_decd += _fgdc
	if _fgdc > 0 {
		_acfdc.First = &_eaega[0].PdfOutlineTreeNode
		_acfdc.Last = &_eaega[_fgdc-1].PdfOutlineTreeNode
		_acfdc.Count = &_decd
	}
	return _acfdc
}

// SetRotation sets the rotation of all pages added to writer. The rotation is
// specified in degrees and must be a multiple of 90.
// The Rotate field of individual pages has priority over the global rotation.
func (_fgdee *PdfWriter) SetRotation(rotate int64) error {
	_bagfc, _bbadc := _fed.GetDict(_fgdee._eeafd)
	if !_bbadc {
		return ErrTypeCheck
	}
	_bagfc.Set("\u0052\u006f\u0074\u0061\u0074\u0065", _fed.MakeInteger(rotate))
	return nil
}

// ToGoTime returns the date in time.Time format.
func (_ccedg PdfDate) ToGoTime() _e.Time {
	_fgfbe := int(_ccedg._ecgbg*60*60 + _ccedg._aabea*60)
	switch _ccedg._caaae {
	case '-':
		_fgfbe = -_fgfbe
	case 'Z':
		_fgfbe = 0
	}
	_aebbg := _d.Sprintf("\u0055\u0054\u0043\u0025\u0063\u0025\u002e\u0032\u0064\u0025\u002e\u0032\u0064", _ccedg._caaae, _ccedg._ecgbg, _ccedg._aabea)
	_eebf := _e.FixedZone(_aebbg, _fgfbe)
	return _e.Date(int(_ccedg._abaff), _e.Month(_ccedg._beaeg), int(_ccedg._dcbg), int(_ccedg._gdcccg), int(_ccedg._dbgdd), int(_ccedg._eaec), 0, _eebf)
}

// ColorFromPdfObjects returns a new PdfColor based on the input slice of color
// components. The slice should contain a single PdfObjectFloat element.
func (_cgced *PdfColorspaceSpecialIndexed) ColorFromPdfObjects(objects []_fed.PdfObject) (PdfColor, error) {
	if len(objects) != 1 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_egdcb, _bfee := _fed.GetNumbersAsFloat(objects)
	if _bfee != nil {
		return nil, _bfee
	}
	return _cgced.ColorFromFloats(_egdcb)
}

// ColorToRGB converts a DeviceN color to an RGB color.
func (_ebgeg *PdfColorspaceDeviceN) ColorToRGB(color PdfColor) (PdfColor, error) {
	if _ebgeg.AlternateSpace == nil {
		return nil, _bb.New("\u0044\u0065\u0076\u0069\u0063\u0065N\u0020\u0061\u006c\u0074\u0065\u0072\u006e\u0061\u0074\u0065\u0020\u0073\u0070a\u0063\u0065\u0020\u0075\u006e\u0064\u0065f\u0069\u006e\u0065\u0064")
	}
	return _ebgeg.AlternateSpace.ColorToRGB(color)
}

// DecodeArray returns the range of color component values in DeviceGray colorspace.
func (_beec *PdfColorspaceDeviceGray) DecodeArray() []float64 { return []float64{0, 1.0} }

// NewPdfColorspaceDeviceN returns an initialized PdfColorspaceDeviceN.
func NewPdfColorspaceDeviceN() *PdfColorspaceDeviceN {
	_bdddb := &PdfColorspaceDeviceN{}
	return _bdddb
}

type modelManager struct {
	_efad map[PdfModel]_fed.PdfObject
	_dded map[_fed.PdfObject]PdfModel
}

// PdfShadingType6 is a Coons patch mesh.
type PdfShadingType6 struct {
	*PdfShading
	BitsPerCoordinate *_fed.PdfObjectInteger
	BitsPerComponent  *_fed.PdfObjectInteger
	BitsPerFlag       *_fed.PdfObjectInteger
	Decode            *_fed.PdfObjectArray
	Function          []PdfFunction
}

// SetPdfCreationDate sets the CreationDate attribute of the output PDF.
func SetPdfCreationDate(creationDate _e.Time) {
	_abadca.Lock()
	defer _abadca.Unlock()
	_facfe = creationDate
}

// ToPdfObject implements interface PdfModel.
func (_ace *PdfAnnotationStrikeOut) ToPdfObject() _fed.PdfObject {
	_ace.PdfAnnotation.ToPdfObject()
	_bdga := _ace._ffaab
	_ggcb := _bdga.PdfObject.(*_fed.PdfObjectDictionary)
	_ace.PdfAnnotationMarkup.appendToPdfDictionary(_ggcb)
	_ggcb.SetIfNotNil("\u0053u\u0062\u0074\u0079\u0070\u0065", _fed.MakeName("\u0053t\u0072\u0069\u006b\u0065\u004f\u0075t"))
	_ggcb.SetIfNotNil("\u0051\u0075\u0061\u0064\u0050\u006f\u0069\u006e\u0074\u0073", _ace.QuadPoints)
	return _bdga
}

// ToPdfObject returns a PDF object representation of the outline item.
func (_gbfg *OutlineItem) ToPdfObject() _fed.PdfObject {
	_agdc, _ := _gbfg.ToPdfOutlineItem()
	return _agdc.ToPdfObject()
}

// GetCharMetrics returns the char metrics for character code `code`.
func (_bfafb pdfCIDFontType0) GetCharMetrics(code _dg.CharCode) (_geg.CharMetrics, bool) {
	_deace := _bfafb._fabb
	if _deca, _cgfe := _bfafb._dadd[code]; _cgfe {
		_deace = _deca
	}
	return _geg.CharMetrics{Wx: _deace}, true
}

// NewXObjectForm creates a brand new XObject Form. Creates a new underlying PDF object stream primitive.
func NewXObjectForm() *XObjectForm {
	_gcegad := &XObjectForm{}
	_ebdaed := &_fed.PdfObjectStream{}
	_ebdaed.PdfObjectDictionary = _fed.MakeDict()
	_gcegad._cedfc = _ebdaed
	return _gcegad
}
func (_cfd *PdfReader) newPdfActionSubmitFormFromDict(_bde *_fed.PdfObjectDictionary) (*PdfActionSubmitForm, error) {
	_bfe, _bfdg := _eec(_bde.Get("\u0046"))
	if _bfdg != nil {
		return nil, _bfdg
	}
	return &PdfActionSubmitForm{F: _bfe, Fields: _bde.Get("\u0046\u0069\u0065\u006c\u0064\u0073"), Flags: _bde.Get("\u0046\u006c\u0061g\u0073")}, nil
}

const (
	ButtonTypeCheckbox ButtonType = iota
	ButtonTypePush     ButtonType = iota
	ButtonTypeRadio    ButtonType = iota
)

func (_ffge *pdfFontSimple) getFontDescriptor() *PdfFontDescriptor {
	if _gdbc := _ffge._bgdgb; _gdbc != nil {
		return _gdbc
	}
	return _ffge._daaa
}

// GetType returns the button field type which returns one of the following
// - PdfFieldButtonPush for push button fields
// - PdfFieldButtonCheckbox for checkbox fields
// - PdfFieldButtonRadio for radio button fields
func (_fcae *PdfFieldButton) GetType() ButtonType {
	_bdada := ButtonTypeCheckbox
	if _fcae.Ff != nil {
		if (uint32(*_fcae.Ff) & FieldFlagPushbutton.Mask()) > 0 {
			_bdada = ButtonTypePush
		} else if (uint32(*_fcae.Ff) & FieldFlagRadio.Mask()) > 0 {
			_bdada = ButtonTypeRadio
		}
	}
	return _bdada
}

// NewPdfDate returns a new PdfDate object from a PDF date string (see 7.9.4 Dates).
// format: "D: YYYYMMDDHHmmSSOHH'mm"
func NewPdfDate(dateStr string) (PdfDate, error) {
	_gddg := PdfDate{}
	_cacce := _bggfdc.FindAllStringSubmatch(dateStr, 1)
	if len(_cacce) < 1 {
		return _gddg, _d.Errorf("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0061\u0074\u0065\u0020s\u0074\u0072\u0069\u006e\u0067\u0020\u0028\u0025\u0073\u0029", dateStr)
	}
	if len(_cacce[0]) != 10 {
		return _gddg, _bb.New("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0065\u0067\u0065\u0078p\u0020\u0067\u0072\u006f\u0075\u0070 \u006d\u0061\u0074\u0063\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020!\u003d\u0020\u0031\u0030")
	}
	_gddg._abaff, _ = _ba.ParseInt(_cacce[0][1], 10, 32)
	_gddg._beaeg, _ = _ba.ParseInt(_cacce[0][2], 10, 32)
	_gddg._dcbg, _ = _ba.ParseInt(_cacce[0][3], 10, 32)
	_gddg._gdcccg, _ = _ba.ParseInt(_cacce[0][4], 10, 32)
	_gddg._dbgdd, _ = _ba.ParseInt(_cacce[0][5], 10, 32)
	_gddg._eaec, _ = _ba.ParseInt(_cacce[0][6], 10, 32)
	if len(_cacce[0][7]) > 0 {
		_gddg._caaae = _cacce[0][7][0]
	} else {
		_gddg._caaae = '+'
	}
	if len(_cacce[0][8]) > 0 {
		_gddg._ecgbg, _ = _ba.ParseInt(_cacce[0][8], 10, 32)
	} else {
		_gddg._ecgbg = 0
	}
	if len(_cacce[0][9]) > 0 {
		_gddg._aabea, _ = _ba.ParseInt(_cacce[0][9], 10, 32)
	} else {
		_gddg._aabea = 0
	}
	return _gddg, nil
}

// GetContentStream returns the XObject Form's content stream.
func (_ggeca *XObjectForm) GetContentStream() ([]byte, error) {
	_fdfb, _ffebg := _fed.DecodeStream(_ggeca._cedfc)
	if _ffebg != nil {
		return nil, _ffebg
	}
	return _fdfb, nil
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_ccacf *PdfShadingType6) ToPdfObject() _fed.PdfObject {
	_ccacf.PdfShading.ToPdfObject()
	_edea, _aedee := _ccacf.getShadingDict()
	if _aedee != nil {
		_fef.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _ccacf.BitsPerCoordinate != nil {
		_edea.Set("\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006f\u0072\u0064i\u006e\u0061\u0074\u0065", _ccacf.BitsPerCoordinate)
	}
	if _ccacf.BitsPerComponent != nil {
		_edea.Set("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074", _ccacf.BitsPerComponent)
	}
	if _ccacf.BitsPerFlag != nil {
		_edea.Set("B\u0069\u0074\u0073\u0050\u0065\u0072\u0046\u006c\u0061\u0067", _ccacf.BitsPerFlag)
	}
	if _ccacf.Decode != nil {
		_edea.Set("\u0044\u0065\u0063\u006f\u0064\u0065", _ccacf.Decode)
	}
	if _ccacf.Function != nil {
		if len(_ccacf.Function) == 1 {
			_edea.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _ccacf.Function[0].ToPdfObject())
		} else {
			_dgeceg := _fed.MakeArray()
			for _, _acagb := range _ccacf.Function {
				_dgeceg.Append(_acagb.ToPdfObject())
			}
			_edea.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _dgeceg)
		}
	}
	return _ccacf._cdcge
}

// HasExtGState checks if ExtGState name is available.
func (_bcgba *PdfPage) HasExtGState(name _fed.PdfObjectName) bool {
	if _bcgba.Resources == nil {
		return false
	}
	if _bcgba.Resources.ExtGState == nil {
		return false
	}
	_bffae, _bdcg := _fed.TraceToDirectObject(_bcgba.Resources.ExtGState).(*_fed.PdfObjectDictionary)
	if !_bdcg {
		_fef.Log.Debug("\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0045\u0078t\u0047\u0053\u0074\u0061\u0074\u0065\u0020\u0064i\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069c\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u003a\u0020\u0025\u0076", _fed.TraceToDirectObject(_bcgba.Resources.ExtGState))
		return false
	}
	_ceaa := _bffae.Get(name)
	_acef := _ceaa != nil
	return _acef
}

// DecodeArray returns the component range values for the Separation colorspace.
func (_aaba *PdfColorspaceSpecialSeparation) DecodeArray() []float64 { return []float64{0, 1.0} }
func (_adebd *pdfCIDFontType0) baseFields() *fontCommon              { return &_adebd.fontCommon }

// NewPdfColorDeviceCMYK returns a new CMYK32 color.
func NewPdfColorDeviceCMYK(c, m, y, k float64) *PdfColorDeviceCMYK {
	_afcfd := PdfColorDeviceCMYK{c, m, y, k}
	return &_afcfd
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_dbac *PdfShadingType1) ToPdfObject() _fed.PdfObject {
	_dbac.PdfShading.ToPdfObject()
	_ggbae, _ebgbg := _dbac.getShadingDict()
	if _ebgbg != nil {
		_fef.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _dbac.Domain != nil {
		_ggbae.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _dbac.Domain)
	}
	if _dbac.Matrix != nil {
		_ggbae.Set("\u004d\u0061\u0074\u0072\u0069\u0078", _dbac.Matrix)
	}
	if _dbac.Function != nil {
		if len(_dbac.Function) == 1 {
			_ggbae.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _dbac.Function[0].ToPdfObject())
		} else {
			_fgeaa := _fed.MakeArray()
			for _, _eabbe := range _dbac.Function {
				_fgeaa.Append(_eabbe.ToPdfObject())
			}
			_ggbae.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _fgeaa)
		}
	}
	return _dbac._cdcge
}

// PdfFieldChoice represents a choice field which includes scrollable list boxes and combo boxes.
type PdfFieldChoice struct {
	*PdfField
	Opt *_fed.PdfObjectArray
	TI  *_fed.PdfObjectInteger
	I   *_fed.PdfObjectArray
}

// GetXObjectByName returns the XObject with the specified keyName and the object type.
func (_febfaf *PdfPageResources) GetXObjectByName(keyName _fed.PdfObjectName) (*_fed.PdfObjectStream, XObjectType) {
	if _febfaf.XObject == nil {
		return nil, XObjectTypeUndefined
	}
	_befag, _fcce := _fed.TraceToDirectObject(_febfaf.XObject).(*_fed.PdfObjectDictionary)
	if !_fcce {
		_fef.Log.Debug("\u0045\u0052\u0052\u004f\u0052:\u0020\u0058\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020a\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0054\u0029", _fed.TraceToDirectObject(_febfaf.XObject))
		return nil, XObjectTypeUndefined
	}
	if _bffecd := _befag.Get(keyName); _bffecd != nil {
		_beffb, _gbaf := _fed.GetStream(_bffecd)
		if !_gbaf {
			_fef.Log.Debug("X\u004f\u0062\u006a\u0065\u0063\u0074 \u006e\u006f\u0074\u0020\u0070\u006fi\u006e\u0074\u0069\u006e\u0067\u0020\u0074o\u0020\u0061\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020%\u0054", _bffecd)
			return nil, XObjectTypeUndefined
		}
		_bgadbd := _beffb.PdfObjectDictionary
		_fcfbf, _gbaf := _fed.TraceToDirectObject(_bgadbd.Get("\u0053u\u0062\u0074\u0079\u0070\u0065")).(*_fed.PdfObjectName)
		if !_gbaf {
			_fef.Log.Debug("\u0058\u004fbj\u0065\u0063\u0074 \u0053\u0075\u0062\u0074ype\u0020no\u0074\u0020\u0061\u0020\u004e\u0061\u006de,\u0020\u0064\u0069\u0063\u0074\u003a\u0020%\u0073", _bgadbd.String())
			return nil, XObjectTypeUndefined
		}
		if *_fcfbf == "\u0049\u006d\u0061g\u0065" {
			return _beffb, XObjectTypeImage
		} else if *_fcfbf == "\u0046\u006f\u0072\u006d" {
			return _beffb, XObjectTypeForm
		} else if *_fcfbf == "\u0050\u0053" {
			return _beffb, XObjectTypePS
		} else {
			_fef.Log.Debug("\u0058\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0053\u0075b\u0074\u0079\u0070\u0065\u0020\u006e\u006ft\u0020\u006b\u006e\u006f\u0077\u006e\u0020\u0028\u0025\u0073\u0029", *_fcfbf)
			return nil, XObjectTypeUndefined
		}
	} else {
		return nil, XObjectTypeUndefined
	}
}

// ReaderToWriterOpts options used to generate a PdfWriter.
type ReaderToWriterOpts struct {
	SkipAcroForm        bool
	SkipInfo            bool
	SkipNameDictionary  bool
	SkipNamedDests      bool
	SkipOCProperties    bool
	SkipOutlines        bool
	SkipPageLabels      bool
	SkipRotation        bool
	PageProcessCallback PageProcessCallback

	// Deprecated: will be removed in v4. Use PageProcessCallback instead.
	PageCallback PageCallback
}

// Size returns the width and the height of the page. The method reports
// the page dimensions as displayed by a PDF viewer (i.e. page rotation is
// taken into account).
func (_bead *PdfPage) Size() (float64, float64, error) {
	_dbaga, _bfdae := _bead.GetMediaBox()
	if _bfdae != nil {
		return 0, 0, _bfdae
	}
	_edfd, _gecac := _dbaga.Width(), _dbaga.Height()
	if _aaabg := _bead.Rotate; _aaabg != nil && *_aaabg%360 != 0 && *_aaabg%90 == 0 {
		if _bcbg := (360 + *_aaabg%360) % 360; _bcbg == 90 || _bcbg == 270 {
			_edfd, _gecac = _gecac, _edfd
		}
	}
	return _edfd, _gecac, nil
}
func (_bgadf *Image) samplesTrimPadding(_gbded []uint32) []uint32 {
	_badff := _bgadf.ColorComponents * int(_bgadf.Width) * int(_bgadf.Height)
	if len(_gbded) == _badff {
		return _gbded
	}
	_bddda := make([]uint32, _badff)
	_aedgf := int(_bgadf.Width) * _bgadf.ColorComponents
	var _dfceg, _ddddd, _daae, _ggeg int
	_ceeee := _eede.BytesPerLine(int(_bgadf.Width), int(_bgadf.BitsPerComponent), _bgadf.ColorComponents)
	for _dfceg = 0; _dfceg < int(_bgadf.Height); _dfceg++ {
		_ddddd = _dfceg * int(_bgadf.Width)
		_daae = _dfceg * _ceeee
		for _ggeg = 0; _ggeg < _aedgf; _ggeg++ {
			_bddda[_ddddd+_ggeg] = _gbded[_daae+_ggeg]
		}
	}
	return _bddda
}

// NewPdfColorspaceLab returns a new Lab colorspace object.
func NewPdfColorspaceLab() *PdfColorspaceLab {
	_cffgb := &PdfColorspaceLab{}
	_cffgb.BlackPoint = []float64{0.0, 0.0, 0.0}
	_cffgb.Range = []float64{-100, 100, -100, 100}
	return _cffgb
}

// PdfAnnotationPopup represents Popup annotations.
// (Section 12.5.6.14).
type PdfAnnotationPopup struct {
	*PdfAnnotation
	Parent _fed.PdfObject
	Open   _fed.PdfObject
}

func _agcd(_gdge _fed.PdfObject) (*PdfColorspaceLab, error) {
	_fgdf := NewPdfColorspaceLab()
	if _dfga, _becg := _gdge.(*_fed.PdfIndirectObject); _becg {
		_fgdf._dfbd = _dfga
	}
	_gdge = _fed.TraceToDirectObject(_gdge)
	_bdae, _aefaa := _gdge.(*_fed.PdfObjectArray)
	if !_aefaa {
		return nil, _d.Errorf("\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
	}
	if _bdae.Len() != 2 {
		return nil, _d.Errorf("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0043\u0061\u006c\u0052G\u0042 \u0063o\u006c\u006f\u0072\u0073\u0070\u0061\u0063e")
	}
	_gdge = _fed.TraceToDirectObject(_bdae.Get(0))
	_edaeb, _aefaa := _gdge.(*_fed.PdfObjectName)
	if !_aefaa {
		return nil, _d.Errorf("\u006c\u0061\u0062\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006ft\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0062j\u0065\u0063\u0074")
	}
	if *_edaeb != "\u004c\u0061\u0062" {
		return nil, _d.Errorf("n\u006ft\u0020\u0061\u0020\u004c\u0061\u0062\u0020\u0063o\u006c\u006f\u0072\u0073pa\u0063\u0065")
	}
	_gdge = _fed.TraceToDirectObject(_bdae.Get(1))
	_efdg, _aefaa := _gdge.(*_fed.PdfObjectDictionary)
	if !_aefaa {
		return nil, _d.Errorf("c\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006ev\u0061l\u0069\u0064")
	}
	_gdge = _efdg.Get("\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074")
	_gdge = _fed.TraceToDirectObject(_gdge)
	_fcbaf, _aefaa := _gdge.(*_fed.PdfObjectArray)
	if !_aefaa {
		return nil, _d.Errorf("\u004c\u0061\u0062\u0020In\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069n\u0074")
	}
	if _fcbaf.Len() != 3 {
		return nil, _d.Errorf("\u004c\u0061b\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0068\u0069\u0074\u0065\u0050\u006f\u0069\u006e\u0074\u0020\u0061rr\u0061\u0079")
	}
	_baab, _fcbc := _fcbaf.GetAsFloat64Slice()
	if _fcbc != nil {
		return nil, _fcbc
	}
	_fgdf.WhitePoint = _baab
	_gdge = _efdg.Get("\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074")
	if _gdge != nil {
		_gdge = _fed.TraceToDirectObject(_gdge)
		_dcdg, _efa := _gdge.(*_fed.PdfObjectArray)
		if !_efa {
			return nil, _d.Errorf("\u004c\u0061\u0062: \u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074")
		}
		if _dcdg.Len() != 3 {
			return nil, _d.Errorf("\u004c\u0061b\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u006c\u0061\u0063\u006b\u0050\u006f\u0069\u006e\u0074\u0020\u0061rr\u0061\u0079")
		}
		_bfbgf, _feadd := _dcdg.GetAsFloat64Slice()
		if _feadd != nil {
			return nil, _feadd
		}
		_fgdf.BlackPoint = _bfbgf
	}
	_gdge = _efdg.Get("\u0052\u0061\u006eg\u0065")
	if _gdge != nil {
		_gdge = _fed.TraceToDirectObject(_gdge)
		_cbfg, _cfgfd := _gdge.(*_fed.PdfObjectArray)
		if !_cfgfd {
			_fef.Log.Error("\u0052\u0061n\u0067\u0065\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
			return nil, _d.Errorf("\u004ca\u0062:\u0020\u0054\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		if _cbfg.Len() != 4 {
			_fef.Log.Error("\u0052\u0061\u006e\u0067\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u0020e\u0072\u0072\u006f\u0072")
			return nil, _d.Errorf("\u004c\u0061b\u003a\u0020\u0052a\u006e\u0067\u0065\u0020\u0065\u0072\u0072\u006f\u0072")
		}
		_eggcgf, _ecbed := _cbfg.GetAsFloat64Slice()
		if _ecbed != nil {
			return nil, _ecbed
		}
		_fgdf.Range = _eggcgf
	}
	return _fgdf, nil
}

// GetContext returns the context of the outline tree node, which is either a
// *PdfOutline or a *PdfOutlineItem. The method returns nil for uninitialized
// tree nodes.
func (_fede *PdfOutlineTreeNode) GetContext() PdfModel {
	if _bgaec, _cacdb := _fede._ffgd.(*PdfOutline); _cacdb {
		return _bgaec
	}
	if _bbgf, _egfb := _fede._ffgd.(*PdfOutlineItem); _egfb {
		return _bbgf
	}
	_fef.Log.Debug("\u0045\u0052RO\u0052\u0020\u0049n\u0076\u0061\u006c\u0069d o\u0075tl\u0069\u006e\u0065\u0020\u0074\u0072\u0065e \u006e\u006f\u0064\u0065\u0020\u0069\u0074e\u006d")
	return nil
}

// NewPdfPageResourcesColorspaces returns a new PdfPageResourcesColorspaces object.
func NewPdfPageResourcesColorspaces() *PdfPageResourcesColorspaces {
	_bdfba := &PdfPageResourcesColorspaces{}
	_bdfba.Names = []string{}
	_bdfba.Colorspaces = map[string]PdfColorspace{}
	_bdfba._bdbfa = &_fed.PdfIndirectObject{}
	return _bdfba
}

// NewPdfActionGoTo3DView returns a new "goTo3DView" action.
func NewPdfActionGoTo3DView() *PdfActionGoTo3DView {
	_gfd := NewPdfAction()
	_fbe := &PdfActionGoTo3DView{}
	_fbe.PdfAction = _gfd
	_gfd.SetContext(_fbe)
	return _fbe
}

// ToPdfObject returns an indirect object containing the signature field dictionary.
func (_fgea *PdfFieldSignature) ToPdfObject() _fed.PdfObject {
	if _fgea.PdfAnnotationWidget != nil {
		_fgea.PdfAnnotationWidget.ToPdfObject()
	}
	_fgea.PdfField.ToPdfObject()
	_fcgf := _fgea._cbaae
	_cdaa := _fcgf.PdfObject.(*_fed.PdfObjectDictionary)
	_cdaa.SetIfNotNil("\u0046\u0054", _fed.MakeName("\u0053\u0069\u0067"))
	_cdaa.SetIfNotNil("\u004c\u006f\u0063\u006b", _fgea.Lock)
	_cdaa.SetIfNotNil("\u0053\u0056", _fgea.SV)
	if _fgea.V != nil {
		_cdaa.SetIfNotNil("\u0056", _fgea.V.ToPdfObject())
	}
	return _fcgf
}

// IsTiling specifies if the pattern is a tiling pattern.
func (_dbbgc *PdfPattern) IsTiling() bool { return _dbbgc.PatternType == 1 }

// Insert adds an outline item as a child of the current outline item,
// at the specified index.
func (_abcdb *OutlineItem) Insert(index uint, item *OutlineItem) {
	_faec := uint(len(_abcdb.Entries))
	if index > _faec {
		index = _faec
	}
	_abcdb.Entries = append(_abcdb.Entries[:index], append([]*OutlineItem{item}, _abcdb.Entries[index:]...)...)
}

const (
	BorderEffectNoEffect BorderEffect = iota
	BorderEffectCloudy   BorderEffect = iota
)

// ColorFromFloats returns a new PdfColor based on the input slice of color
// components.
func (_febag *PdfColorspaceICCBased) ColorFromFloats(vals []float64) (PdfColor, error) {
	if _febag.Alternate == nil {
		if _febag.N == 1 {
			_aaaf := NewPdfColorspaceDeviceGray()
			return _aaaf.ColorFromFloats(vals)
		} else if _febag.N == 3 {
			_adda := NewPdfColorspaceDeviceRGB()
			return _adda.ColorFromFloats(vals)
		} else if _febag.N == 4 {
			_bfbee := NewPdfColorspaceDeviceCMYK()
			return _bfbee.ColorFromFloats(vals)
		} else {
			return nil, _bb.New("I\u0043\u0043\u0020\u0042\u0061\u0073\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0073\u0070\u0061\u0063e\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0061lt\u0065\u0072\u006ea\u0074i\u0076\u0065")
		}
	}
	return _febag.Alternate.ColorFromFloats(vals)
}
func (_gdcf *LTV) getOCSPs(_efcec []*_fe.Certificate, _efaaf map[string]*_fe.Certificate) ([][]byte, error) {
	_dbcc := make([][]byte, 0, len(_efcec))
	for _, _eabfe := range _efcec {
		for _, _aegfd := range _eabfe.OCSPServer {
			if _gdcf.CertClient.IsCA(_eabfe) {
				continue
			}
			_cefg, _ebecc := _efaaf[_eabfe.Issuer.CommonName]
			if !_ebecc {
				_fef.Log.Debug("\u0057\u0041\u0052\u004e:\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067 \u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u003a\u0020\u0069\u0073\u0073\u0075e\u0072\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064")
				continue
			}
			_, _aadea, _edcae := _gdcf.OCSPClient.MakeRequest(_aegfd, _eabfe, _cefg)
			if _edcae != nil {
				_fef.Log.Debug("\u0057\u0041\u0052\u004e:\u0020\u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075e\u0073t\u0020\u0065\u0072\u0072\u006f\u0072\u003a \u0025\u0076", _edcae)
				continue
			}
			_dbcc = append(_dbcc, _aadea)
		}
	}
	return _dbcc, nil
}
func _bcbbb(_dadb *_fed.PdfIndirectObject, _ddgc *_fed.PdfObjectDictionary) (*DSS, error) {
	if _dadb == nil {
		_dadb = _fed.MakeIndirectObject(nil)
	}
	_dadb.PdfObject = _fed.MakeDict()
	_aeaae := map[string]*VRI{}
	if _ffecc, _affc := _fed.GetDict(_ddgc.Get("\u0056\u0052\u0049")); _affc {
		for _, _gccd := range _ffecc.Keys() {
			if _aeed, _ggba := _fed.GetDict(_ffecc.Get(_gccd)); _ggba {
				_aeaae[_eed.ToUpper(_gccd.String())] = _gfgeg(_aeed)
			}
		}
	}
	return &DSS{Certs: _fedf(_ddgc.Get("\u0043\u0065\u0072t\u0073")), OCSPs: _fedf(_ddgc.Get("\u004f\u0043\u0053P\u0073")), CRLs: _fedf(_ddgc.Get("\u0043\u0052\u004c\u0073")), VRI: _aeaae, _dcaa: _dadb}, nil
}
func (_ffe *PdfReader) newPdfActionURIFromDict(_ccfc *_fed.PdfObjectDictionary) (*PdfActionURI, error) {
	return &PdfActionURI{URI: _ccfc.Get("\u0055\u0052\u0049"), IsMap: _ccfc.Get("\u0049\u0073\u004da\u0070")}, nil
}

// Clear clears flag fl from the flag and returns the resulting flag.
func (_ffeg FieldFlag) Clear(fl FieldFlag) FieldFlag { return FieldFlag(_ffeg.Mask() &^ fl.Mask()) }

// PdfOutline represents a PDF outline dictionary (Table 152 - p. 376).
type PdfOutline struct {
	PdfOutlineTreeNode
	Parent *PdfOutlineTreeNode
	Count  *int64
	_cbad  *_fed.PdfIndirectObject
}

var ImageHandling ImageHandler = DefaultImageHandler{}

// GetNumComponents returns the number of color components of the colorspace device.
// Returns 3 for an RGB device.
func (_dcf *PdfColorspaceDeviceRGB) GetNumComponents() int { return 3 }

// ToPdfObject converts colorspace to a PDF object. [/Indexed base hival lookup]
func (_bafba *PdfColorspaceSpecialIndexed) ToPdfObject() _fed.PdfObject {
	_ccac := _fed.MakeArray(_fed.MakeName("\u0049n\u0064\u0065\u0078\u0065\u0064"))
	_ccac.Append(_bafba.Base.ToPdfObject())
	_ccac.Append(_fed.MakeInteger(int64(_bafba.HiVal)))
	_ccac.Append(_bafba.Lookup)
	if _bafba._bedg != nil {
		_bafba._bedg.PdfObject = _ccac
		return _bafba._bedg
	}
	return _ccac
}

// SignatureHandler interface defines the common functionality for PDF signature handlers, which
// need to be capable of validating digital signatures and signing PDF documents.
type SignatureHandler interface {
	IsApplicable(_cbdbe *PdfSignature) bool
	Validate(_deacd *PdfSignature, _cgcdf Hasher) (SignatureValidationResult, error)

	// InitSignature sets the PdfSignature parameters.
	InitSignature(*PdfSignature) error
	NewDigest(_bdaeg *PdfSignature) (Hasher, error)
	Sign(_edgdbg *PdfSignature, _dcaac Hasher) error
}

func (_eggaf *DSS) addCerts(_cbgc [][]byte) ([]*_fed.PdfObjectStream, error) {
	return _eggaf.add(&_eggaf.Certs, _eggaf._ffga, _cbgc)
}
func (_eag *PdfReader) newPdfActionMovieFromDict(_fdc *_fed.PdfObjectDictionary) (*PdfActionMovie, error) {
	return &PdfActionMovie{Annotation: _fdc.Get("\u0041\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e"), T: _fdc.Get("\u0054"), Operation: _fdc.Get("\u004fp\u0065\u0072\u0061\u0074\u0069\u006fn")}, nil
}
func (_ceeed *PdfSignature) extractChainFromCert() ([]*_fe.Certificate, error) {
	var _cgffc *_fed.PdfObjectArray
	switch _cfgg := _ceeed.Cert.(type) {
	case *_fed.PdfObjectString:
		_cgffc = _fed.MakeArray(_cfgg)
	case *_fed.PdfObjectArray:
		_cgffc = _cfgg
	default:
		return nil, _d.Errorf("\u0069n\u0076\u0061l\u0069\u0064\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072e\u0020\u0063\u0065\u0072\u0074\u0069f\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054", _cfgg)
	}
	var _agab _eb.Buffer
	for _, _cafaa := range _cgffc.Elements() {
		_ecfde, _ccdgea := _fed.GetString(_cafaa)
		if !_ccdgea {
			return nil, _d.Errorf("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0074\u0079p\u0065\u0020\u0069\u006e\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065 \u0063\u0065r\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u0063h\u0061\u0069\u006e\u003a\u0020\u0025\u0054", _cafaa)
		}
		if _, _dbcae := _agab.Write(_ecfde.Bytes()); _dbcae != nil {
			return nil, _dbcae
		}
	}
	return _fe.ParseCertificates(_agab.Bytes())
}

// Height returns the height of `rect`.
func (_ccgb *PdfRectangle) Height() float64 { return _bg.Abs(_ccgb.Ury - _ccgb.Lly) }

// ToInteger convert to an integer format.
func (_dccg *PdfColorCalRGB) ToInteger(bits int) [3]uint32 {
	_abac := _bg.Pow(2, float64(bits)) - 1
	return [3]uint32{uint32(_abac * _dccg.A()), uint32(_abac * _dccg.B()), uint32(_abac * _dccg.C())}
}

// ColorFromPdfObjects returns a new PdfColor based on input color components. The input PdfObjects should
// be numeric.
func (_bbbf *PdfColorspaceDeviceN) ColorFromPdfObjects(objects []_fed.PdfObject) (PdfColor, error) {
	if len(objects) != _bbbf.GetNumComponents() {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_eadfe, _gdgc := _fed.GetNumbersAsFloat(objects)
	if _gdgc != nil {
		return nil, _gdgc
	}
	return _bbbf.ColorFromFloats(_eadfe)
}

// GetAllContentStreams gets all the content streams for a page as one string.
func (_cbccd *PdfPage) GetAllContentStreams() (string, error) {
	_cfef, _efgbc := _cbccd.GetContentStreams()
	if _efgbc != nil {
		return "", _efgbc
	}
	return _eed.Join(_cfef, "\u0020"), nil
}

// SetColorSpace sets `r` colorspace object to `colorspace`.
func (_bbgfg *PdfPageResources) SetColorSpace(colorspace *PdfPageResourcesColorspaces) {
	_bbgfg._ebfeb = colorspace
}

// GetNumComponents returns the number of color components (4 for CMYK32).
func (_eddf *PdfColorDeviceCMYK) GetNumComponents() int { return 4 }

// DetermineColorspaceNameFromPdfObject determines PDF colorspace from a PdfObject.  Returns the colorspace name and
// an error on failure. If the colorspace was not found, will return an empty string.
func DetermineColorspaceNameFromPdfObject(obj _fed.PdfObject) (_fed.PdfObjectName, error) {
	var _cfceg *_fed.PdfObjectName
	var _aada *_fed.PdfObjectArray
	if _gcd, _fgdb := obj.(*_fed.PdfIndirectObject); _fgdb {
		if _bcegg, _cbaec := _gcd.PdfObject.(*_fed.PdfObjectArray); _cbaec {
			_aada = _bcegg
		} else if _faf, _bbce := _gcd.PdfObject.(*_fed.PdfObjectName); _bbce {
			_cfceg = _faf
		}
	} else if _cbbe, _ddbe := obj.(*_fed.PdfObjectArray); _ddbe {
		_aada = _cbbe
	} else if _fcbe, _faae := obj.(*_fed.PdfObjectName); _faae {
		_cfceg = _fcbe
	}
	if _cfceg != nil {
		switch *_cfceg {
		case "\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079", "\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B", "\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b":
			return *_cfceg, nil
		case "\u0050a\u0074\u0074\u0065\u0072\u006e":
			return *_cfceg, nil
		}
	}
	if _aada != nil && _aada.Len() > 0 {
		if _defe, _gage := _aada.Get(0).(*_fed.PdfObjectName); _gage {
			switch *_defe {
			case "\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079", "\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B", "\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b":
				if _aada.Len() == 1 {
					return *_defe, nil
				}
			case "\u0043a\u006c\u0047\u0072\u0061\u0079", "\u0043\u0061\u006c\u0052\u0047\u0042", "\u004c\u0061\u0062":
				return *_defe, nil
			case "\u0049\u0043\u0043\u0042\u0061\u0073\u0065\u0064", "\u0050a\u0074\u0074\u0065\u0072\u006e", "\u0049n\u0064\u0065\u0078\u0065\u0064":
				return *_defe, nil
			case "\u0053\u0065\u0070\u0061\u0072\u0061\u0074\u0069\u006f\u006e", "\u0044e\u0076\u0069\u0063\u0065\u004e":
				return *_defe, nil
			}
		}
	}
	return "", nil
}

// ToPdfObject returns the PDF representation of the shading dictionary.
func (_aceag *PdfShadingType2) ToPdfObject() _fed.PdfObject {
	_aceag.PdfShading.ToPdfObject()
	_cabgb, _dbdfc := _aceag.getShadingDict()
	if _dbdfc != nil {
		_fef.Log.Error("\u0055\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073\u0020\u0073\u0068\u0061\u0064\u0069\u006e\u0067\u0020di\u0063\u0074")
		return nil
	}
	if _cabgb == nil {
		_fef.Log.Error("\u0053\u0068\u0061\u0064in\u0067\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u0073\u0020\u006e\u0069\u006c")
		return nil
	}
	if _aceag.Coords != nil {
		_cabgb.Set("\u0043\u006f\u006f\u0072\u0064\u0073", _aceag.Coords)
	}
	if _aceag.Domain != nil {
		_cabgb.Set("\u0044\u006f\u006d\u0061\u0069\u006e", _aceag.Domain)
	}
	if _aceag.Function != nil {
		if len(_aceag.Function) == 1 {
			_cabgb.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _aceag.Function[0].ToPdfObject())
		} else {
			_beecg := _fed.MakeArray()
			for _, _adecaa := range _aceag.Function {
				_beecg.Append(_adecaa.ToPdfObject())
			}
			_cabgb.Set("\u0046\u0075\u006e\u0063\u0074\u0069\u006f\u006e", _beecg)
		}
	}
	if _aceag.Extend != nil {
		_cabgb.Set("\u0045\u0078\u0074\u0065\u006e\u0064", _aceag.Extend)
	}
	return _aceag._cdcge
}

// ToGoImage converts the unidoc Image to a golang Image structure.
func (_gbba *Image) ToGoImage() (_ee.Image, error) {
	_fef.Log.Trace("\u0043\u006f\u006e\u0076er\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0067\u006f\u0020\u0069\u006d\u0061g\u0065")
	_bcab, _dcbf := _eede.NewImage(int(_gbba.Width), int(_gbba.Height), int(_gbba.BitsPerComponent), _gbba.ColorComponents, _gbba.Data, _gbba._caeaf, _gbba._ccdge)
	if _dcbf != nil {
		return nil, _dcbf
	}
	return _bcab, nil
}

// SetAction sets the PDF action for the annotation link.
func (_eac *PdfAnnotationLink) SetAction(action *PdfAction) {
	_eac._cge = action
	if action == nil {
		_eac.A = nil
	}
}

// PageCallback callback function used in page loading
// that could be used to modify the page content.
//
// Deprecated: will be removed in v4. Use PageProcessCallback instead.
type PageCallback func(_fdbb int, _edgc *PdfPage)

// SetReason sets the `Reason` field of the signature.
func (_cdged *PdfSignature) SetReason(reason string) { _cdged.Reason = _fed.MakeString(reason) }

// PdfAnnotationText represents Text annotations.
// (Section 12.5.6.4 p. 402).
type PdfAnnotationText struct {
	*PdfAnnotation
	*PdfAnnotationMarkup
	Open       _fed.PdfObject
	Name       _fed.PdfObject
	State      _fed.PdfObject
	StateModel _fed.PdfObject
}

// FlattenFieldsWithOpts flattens the AcroForm fields of the reader using the
// provided field appearance generator and the specified options. If no options
// are specified, all form fields are flattened.
// If a filter function is provided using the opts parameter, only the filtered
// fields are flattened. Otherwise, all form fields are flattened.
// At the end of the process, the AcroForm contains all the fields which were
// not flattened. If all fields are flattened, the reader's AcroForm field
// is set to nil.
func (_aefbe *PdfReader) FlattenFieldsWithOpts(appgen FieldAppearanceGenerator, opts *FieldFlattenOpts) error {
	return _aefbe.flattenFieldsWithOpts(false, appgen, opts)
}

// GetXObjectImageByName returns the XObjectImage with the specified name from the
// page resources, if it exists.
func (_dbcff *PdfPageResources) GetXObjectImageByName(keyName _fed.PdfObjectName) (*XObjectImage, error) {
	_gebg, _cdabga := _dbcff.GetXObjectByName(keyName)
	if _gebg == nil {
		return nil, nil
	}
	if _cdabga != XObjectTypeImage {
		return nil, _bb.New("\u006e\u006f\u0074 \u0061\u006e\u0020\u0069\u006d\u0061\u0067\u0065")
	}
	_bgac, _befb := NewXObjectImageFromStream(_gebg)
	if _befb != nil {
		return nil, _befb
	}
	return _bgac, nil
}

// PdfColorPattern represents a pattern color.
type PdfColorPattern struct {
	Color       PdfColor
	PatternName _fed.PdfObjectName
}

func (_dgdf *PdfPattern) getDict() *_fed.PdfObjectDictionary {
	if _gcced, _dggf := _dgdf._fbefb.(*_fed.PdfIndirectObject); _dggf {
		_faea, _egdf := _gcced.PdfObject.(*_fed.PdfObjectDictionary)
		if !_egdf {
			return nil
		}
		return _faea
	} else if _eagg, _eebbd := _dgdf._fbefb.(*_fed.PdfObjectStream); _eebbd {
		return _eagg.PdfObjectDictionary
	} else {
		_fef.Log.Debug("\u0054r\u0079\u0069\u006e\u0067\u0020\u0074\u006f a\u0063\u0063\u0065\u0073\u0073\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020d\u0069\u0063t\u0069\u006f\u006ea\u0072\u0079\u0020\u006f\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006f\u0062j\u0065\u0063t \u0074\u0079\u0070e\u0020\u0028\u0025\u0054\u0029", _dgdf._fbefb)
		return nil
	}
}

// ToPdfObject returns the button field dictionary within an indirect object.
func (_efebc *PdfFieldButton) ToPdfObject() _fed.PdfObject {
	_efebc.PdfField.ToPdfObject()
	_aeda := _efebc._cbaae
	_gcgf := _aeda.PdfObject.(*_fed.PdfObjectDictionary)
	_gcgf.Set("\u0046\u0054", _fed.MakeName("\u0042\u0074\u006e"))
	if _efebc.Opt != nil {
		_gcgf.Set("\u004f\u0070\u0074", _efebc.Opt)
	}
	return _aeda
}
func _abcea(_gcfba _fed.PdfObject) {
	_fef.Log.Debug("\u006f\u0062\u006a\u003a\u0020\u0025\u0054\u0020\u0025\u0073", _gcfba, _gcfba.String())
	if _fbfaa, _ggaaf := _gcfba.(*_fed.PdfObjectStream); _ggaaf {
		_fegff, _ecbdd := _fed.DecodeStream(_fbfaa)
		if _ecbdd != nil {
			_fef.Log.Debug("\u0045r\u0072\u006f\u0072\u003a\u0020\u0025v", _ecbdd)
			return
		}
		_fef.Log.Debug("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073", _fegff)
	} else if _bdab, _aeggg := _gcfba.(*_fed.PdfIndirectObject); _aeggg {
		_fef.Log.Debug("\u0025\u0054\u0020%\u0076", _bdab.PdfObject, _bdab.PdfObject)
		_fef.Log.Debug("\u0025\u0073", _bdab.PdfObject.String())
	}
}

// GetContainingPdfObject returns the container of the image object (indirect object).
func (_acbdbg *XObjectImage) GetContainingPdfObject() _fed.PdfObject { return _acbdbg._agffg }

type pdfFontSimple struct {
	fontCommon
	_gedd  *_fed.PdfIndirectObject
	_dadc  map[_dg.CharCode]float64
	_ebcbf _dg.TextEncoder
	_cffd  _dg.TextEncoder
	_daaa  *PdfFontDescriptor

	// Encoding is subject to limitations that are described in 9.6.6, "Character Encoding".
	// BaseFont is derived differently.
	FirstChar _fed.PdfObject
	LastChar  _fed.PdfObject
	Widths    _fed.PdfObject
	Encoding  _fed.PdfObject
	_abef     *_geg.RuneCharSafeMap
}

// Field returns the parent form field of the widget annotation, if one exists.
// NOTE: the method returns nil if the parent form field has not been parsed.
func (_edfc *PdfAnnotationWidget) Field() *PdfField { return _edfc._eagb }

// ColorFromPdfObjects gets the color from a series of pdf objects (3 for rgb).
func (_eggd *PdfColorspaceDeviceRGB) ColorFromPdfObjects(objects []_fed.PdfObject) (PdfColor, error) {
	if len(objects) != 3 {
		return nil, _bb.New("r\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b")
	}
	_dfgge, _ecgc := _fed.GetNumbersAsFloat(objects)
	if _ecgc != nil {
		return nil, _ecgc
	}
	return _eggd.ColorFromFloats(_dfgge)
}

// PdfAnnotationRichMedia represents Rich Media annotations.
type PdfAnnotationRichMedia struct {
	*PdfAnnotation
	RichMediaSettings _fed.PdfObject
	RichMediaContent  _fed.PdfObject
}
